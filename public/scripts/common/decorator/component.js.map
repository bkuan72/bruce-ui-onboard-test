{"version":3,"sources":["scripts/common/decorator/component.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;IAOA,SAAgB,SAAS,CAAC,MAAwB;QAC9C,OAAO,UAAC,MAAW;YACf,gEAAgE;YAChE,IAAI,CAAC,MAAM,CAAC,QAAQ,EAAE;gBAClB,MAAM,CAAC,QAAQ,GAAG,+BAA+B,CAAC;aACrD;YAED,EAAE,CAAC,UAAU,CAAC,QAAQ,CAAC,MAAM,CAAC,IAAI,EAC9B;gBACI,SAAS,EACT;oBACI,eAAe,EAAE,UAAS,MAAgC,EAAE,aAAa;wBACrE,MAAM,GAAG,MAAM,IAA+B,EAAE,CAAC;wBACjD,MAAM,CAAC,OAAO,GAAiB,aAAa,CAAC,OAAO,CAAC;wBACrD,OAAO,IAAW,MAAO,CAAC,MAAM,CAAC,CAAC;oBACtC,CAAC;iBACJ;gBACD,QAAQ,EAAE,8EAA4E,MAAM,CAAC,QAAQ,iBAAc;aACtH,CAAC,CAAC;YACP,OAAa,MAAM,CAAC;QACxB,CAAC,CAAC;IACN,CAAC;IArBD,8BAqBC;IAMD;QAA2E,qCAAU;QAWjF,2BAAY,MAAgC;YAA5C,YACI,iBAAO,SAEV;YAbD,gDAAgD;YACzC,eAAS,GAAgC,EAAE,CAAC,UAAU,CAAC,KAAK,CAAC,CAAC;YAErE,kCAAkC;YAC3B,iBAAW,GAAY,KAAK,CAAC;YAQhC,KAAI,CAAC,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;;QAClC,CAAC;QAED;;WAEG;QACI,oCAAQ,GAAf;YACI,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC;QAC5B,CAAC;QAED;;;;WAIG;QACI,6CAAiB,GAAxB,UAAyB,WAAsC,EAAE,QAAoB;YACjF,IAAI,CAAC,WAAW,IAAI,CAAC,QAAQ,EAAE;gBAC3B,OAAO;aACV;YAED,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,WAAW,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACzC,IAAI,GAAG,GAAG,WAAW,CAAE,CAAC,CAAE,CAAC;gBAC3B,IAAI,CAAC,aAAa,CAAC,GAAG,CAAC,SAAS,CAAC,cAAM,OAAA,QAAQ,EAAE,EAAV,CAAU,CAAC,CAAC,CAAC;aACvD;QACL,CAAC;QACL,wBAAC;IAAD,CAtCA,AAsCC,CAtC0E,uBAAU,GAsCpF;IAtCY,8CAAiB","file":"component.js","sourcesContent":["import { Disposable } from \"./../utils/disposable\";\n\nexport interface IComponentParams {\n    name: string;\n    template: string;\n}\n\nexport function Component(params: IComponentParams) {\n    return (target: any): any => {\n        // This stops knockout from spamming logs about empty templates.\n        if (!params.template) {\n            params.template = \"<!-- NO TEMPLATE PROVIDED -->\";\n        }\n\n        ko.components.register(params.name,\n            {\n                viewModel:\n                {\n                    createViewModel: function(params: IAbstractComponentParams, componentInfo) {\n                        params = params || <IAbstractComponentParams> {};\n                        params.element = <HTMLElement> componentInfo.element;\n                        return new (<any> target)(params);\n                    }\n                },\n                template: `<!-- ko template: {afterRender: $component.rendered.bind($component)} -->${params.template}<!-- /ko -->`\n            });\n        return <any> target;\n    };\n}\n\nexport interface IAbstractComponentParams {\n    element: HTMLElement;\n}\n\nexport class AbstractComponent<T extends IAbstractComponentParams> extends Disposable {\n    // General use loading indicator for components.\n    public IsLoading: KnockoutObservable<boolean> = ko.observable(false);\n\n    // Set to true after first render.\n    public hasRendered: boolean = false;\n\n    // The component HTML element.\n    protected element: HTMLElement;\n\n\n    constructor(params: IAbstractComponentParams) {\n        super();\n        this.element = params.element;\n    }\n\n    /**\n     * Called on component HTML render.\n     */\n    public rendered(): void {\n        this.hasRendered = true;\n    }\n\n    /**\n     * Pass an array of knockout observables and a callback to trigger when any of the given observables get updated.\n     * @param observables \n     * @param callback \n     */\n    public subscribeObsArray(observables: KnockoutObservable<any>[], callback: () => void): void {\n        if (!observables || !callback) {\n            return;\n        }\n\n        for (let i = 0; i < observables.length; i++) {\n            let obs = observables[ i ];\n            this.addDisposable(obs.subscribe(() => callback()));\n        }\n    }\n}"]}