var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
define("api/session-api", ["require", "exports", "bruce-maps-widget", "api/abstract-api"], function (require, exports, bruce_maps_widget_1, abstract_api_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SessionAPI = void 0;
    class SessionAPI extends abstract_api_1.AbstractAPI {
        constructor(environment) {
            super("SSID");
            this.environment = environment;
            this.init();
        }
        /**
         * Returns session api instance corresponding to provided parameters.
         * @param environment
         */
        static getInstance(environment) {
            if (environment == null) {
                throw ("Cannot create instance of session api without environment");
            }
            let instances = SessionAPI._instances;
            let instance = instances.find(x => x.environment == environment);
            if (instance) {
                return instance;
            }
            else {
                let newInstance = new SessionAPI(environment);
                SessionAPI._instances.push(newInstance);
                return newInstance;
            }
        }
        /**
         * Initializes the session api link.
         */
        init() {
            let base = "";
            switch (this.environment) {
                case bruce_maps_widget_1.EEnvironmentType.DEV:
                    base = "https://idm.nextspace-dev.net/";
                    break;
                case bruce_maps_widget_1.EEnvironmentType.STAGING:
                    base = "https://idm.nextspace-stg.net/";
                    break;
                case bruce_maps_widget_1.EEnvironmentType.UAT:
                    base = "https://idm.nextspace-uat.net/";
                    break;
                default:
                    base = "https://idm.nextspace.host/";
                    break;
            }
            this.BASE_URL = base;
        }
        /**
         * Performs GET request with SessionAPI instance prefix.
         * @param url
         * @param onError
         */
        GET(url, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.get(this.BASE_URL + url, onError);
            });
        }
        /**
         * Performs POST request with SessionAPI instance prefix.
         * @param url
         * @param data
         * @param onError
         */
        POST(url, data, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.post(this.BASE_URL + url, data, onError);
            });
        }
        /**
         * Performs PUT request with SessionAPI instance prefix.
         * @param url
         * @param data
         * @param onError
         */
        PUT(url, data, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.put(this.BASE_URL + url, data, onError);
            });
        }
        /**
         * Performs DELETE request with SessionAPI instance prefix.
         * @param url
         * @param onError
         */
        DELETE(url, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.delete(this.BASE_URL + url, onError);
            });
        }
        /**
         * Performs POST UPLOAD request with SessionAPI instance prefix.
         * @param url
         * @param blob
         * @param progress
         * @param onError
         */
        UPLOAD(url, blob, progress = null, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.upload(this.BASE_URL + url, blob, progress, onError);
            });
        }
    }
    exports.SessionAPI = SessionAPI;
    // Array of all unique instances.
    SessionAPI._instances = [];
});
define("bruce-models/common/utc", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UTC = exports.EMonth = void 0;
    /**
     * The possible values for 'm' in UTC class.
     */
    var EMonth;
    (function (EMonth) {
        EMonth[EMonth["January"] = 1] = "January";
        EMonth[EMonth["February"] = 2] = "February";
        EMonth[EMonth["March"] = 3] = "March";
        EMonth[EMonth["April"] = 4] = "April";
        EMonth[EMonth["May"] = 5] = "May";
        EMonth[EMonth["June"] = 6] = "June";
        EMonth[EMonth["July"] = 7] = "July";
        EMonth[EMonth["August"] = 8] = "August";
        EMonth[EMonth["September"] = 9] = "September";
        EMonth[EMonth["October"] = 10] = "October";
        EMonth[EMonth["November"] = 11] = "November";
        EMonth[EMonth["December"] = 12] = "December";
    })(EMonth = exports.EMonth || (exports.EMonth = {}));
    class UTC {
        constructor(rawData) {
            // Seconds.
            this.ss = 0;
            // Minutes.
            this.mm = 0;
            // Hours.
            this.hh = 0;
            // Days.
            this.d = 0;
            // Month.
            this.m = 0;
            // Years.
            this.y = 0;
            this.Update(rawData);
        }
        /**
         * Returns current state as raw JSON.
         */
        get JSON() {
            let utc = {
                ss: this.ss,
                mm: this.mm,
                hh: this.hh,
                d: this.d,
                m: this.m,
                y: this.y
            };
            return utc;
        }
        get Date() {
            return new Date(this.y, this.m - 1, this.d, this.hh, this.mm, this.ss, 0);
        }
        get TotalSeconds() {
            // Cannot just multiply numbers we have because 'month' is arbitrary and we don't want the headache to handle it ourselves.
            let date = this.Date;
            let seconds = date.getTime() / 1000;
            return seconds;
        }
        /**
         * Returns user readable text to represent how long has passed since recorded time.
         */
        get FormattedPassedTime() {
            let now = new Date();
            let nowBruceUTC = UTC.BruceUTCFromDate(now);
            let secondsDifference = UTC.getDifference(this, nowBruceUTC);
            let formatted = UTC.FormatSeconds(secondsDifference);
            return formatted;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ss != null) {
                this.ss = rawData.ss;
            }
            if (rawData.mm != null) {
                this.mm = rawData.mm;
            }
            if (rawData.hh != null) {
                this.hh = rawData.hh;
            }
            if (rawData.d != null) {
                this.d = rawData.d;
            }
            if (rawData.m != null) {
                this.m = rawData.m;
            }
            if (rawData.y != null) {
                this.y = rawData.y;
            }
        }
        /**
         * Returns bruce utc from given date object.
         * @param date
         */
        static BruceUTCFromDate(date) {
            let raw = {
                y: date.getUTCFullYear(),
                m: date.getUTCMonth() + 1,
                d: date.getUTCDate(),
                hh: date.getUTCHours(),
                mm: date.getUTCMinutes(),
                ss: date.getUTCSeconds()
            };
            return new UTC(raw);
        }
        /**
         * Returns difference in seconds between two given bruce dates.
         * @param bruceDate1
         * @param bruceDate2
         */
        static getDifference(bruceDate1, bruceDate2) {
            let date1 = bruceDate1.Date;
            let date2 = bruceDate2.Date;
            let diffTime = Math.abs(date2.getTime() - date1.getTime());
            let diffSeconds = Math.ceil(diffTime / (1000));
            return diffSeconds;
        }
        /**
         * Returns given seconds formatted for UI.
         * @param seconds
         */
        static FormatSeconds(seconds) {
            if (seconds <= -1) {
                return "none";
            }
            let timeSuffix;
            if (seconds < (60)) // max 1 minute
             {
                timeSuffix = seconds == 1 ? "second" : "seconds";
            }
            else if (seconds < (60 * 60)) // max 1 hour
             {
                seconds = Math.round(seconds / 60 * 100) / 100;
                timeSuffix = seconds == 1 ? "minute" : "minutes";
            }
            else if (seconds < (60 * 60 * 24)) // max 24 hours
             {
                seconds = Math.round(seconds / 60 / 60 * 100) / 100;
                timeSuffix = seconds == 1 ? "hour" : "hours";
            }
            else if (seconds < (60 * 60 * 24 * 7)) // max 7 days
             {
                seconds = Math.round(seconds / 60 / 60 / 24 * 100) / 100;
                timeSuffix = seconds == 1 ? "day" : "days";
            }
            else // no max, shown in weeks
             {
                seconds = Math.round(seconds / 60 / 60 / 24 / 7 * 100) / 100;
                timeSuffix = seconds == 1 ? "week" : "weeks";
            }
            return seconds + " " + timeSuffix;
        }
    }
    exports.UTC = UTC;
});
define("bruce-models/session/bruce-permission", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EBrucePermissionPrefixes = exports.EBrucePermission = void 0;
    /**
     * Standalone Bruce account-wide permissions.
     */
    var EBrucePermission;
    (function (EBrucePermission) {
        // Admin permission will enable all others.
        EBrucePermission["ADMIN"] = "ADMIN";
        EBrucePermission["LOGIN"] = "LOGIN";
        EBrucePermission["DELETE_ENTITY_TYPE"] = "DELETE_ENTITY_TYPE";
        EBrucePermission["CREATE_ENTITY_TYPE"] = "CREATE_ENTITY_TYPE";
        EBrucePermission["UPDATE_ENTITY_TYPE"] = "UPDATE_ENTITY_TYPE";
    })(EBrucePermission = exports.EBrucePermission || (exports.EBrucePermission = {}));
    /**
     * Permissions that are not standalone but instead prefix a contextual ID.
     */
    var EBrucePermissionPrefixes;
    (function (EBrucePermissionPrefixes) {
        EBrucePermissionPrefixes["ACCESS_PROJECT_VIEW"] = "UIVIEW_";
        EBrucePermissionPrefixes["MANAGE_PROJECT_VIEW_BOOKMARKS"] = "UIVIEW_MANAGE_BOOKMARKS_";
        EBrucePermissionPrefixes["ACCESS_TILESET"] = "TILESET_";
    })(EBrucePermissionPrefixes = exports.EBrucePermissionPrefixes || (exports.EBrucePermissionPrefixes = {}));
});
define("bruce-models/common/cartesian3", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cartesian3 = void 0;
    class Cartesian3 {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                x: this.x,
                y: this.y,
                z: this.z
            };
            return data;
        }
        /**
         * (Override)
         * @returns cartesian3 as x,y,z string.
         */
        toString() {
            return `${this.x},${this.y},${this.z}`;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new Cartesian3(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (rawData.x != null) {
                this.x = rawData.x;
            }
            if (rawData.y != null) {
                this.y = rawData.y;
            }
            if (rawData.z != null) {
                this.z = rawData.z;
            }
        }
        /**
         * Returns if the current position is valid.
         * @returns: true = valid, false = invalid.
         */
        isValid() {
            return Cartesian3.Validate(this);
        }
        /**
         * Validates if a given position doesn't have null values.
         * @param position
         * @returns: true = valid, false = invalid.
         */
        static Validate(position) {
            if (!position) {
                return false;
            }
            else if (!position.x && position.x != 0) {
                return false;
            }
            else if (!position.y && position.y != 0) {
                return false;
            }
            else if (!position.z && position.z != 0) {
                return false;
            }
            return true;
        }
    }
    exports.Cartesian3 = Cartesian3;
});
define("bruce-models/common/cartesian2", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cartesian2 = void 0;
    class Cartesian2 {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                x: this.x,
                y: this.y
            };
            return data;
        }
        /**
         * (Override)
         * @returns Cartesian2 as x,y string.
         */
        toString() {
            return `${this.x},${this.y}`;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new Cartesian2(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (rawData.x != null) {
                this.x = rawData.x;
            }
            if (rawData.y != null) {
                this.y = rawData.y;
            }
        }
        /**
         * Returns if the current position is valid.
         * @returns: true = valid, false = invalid.
         */
        isValid() {
            return Cartesian2.Validate(this);
        }
        /**
         * Validates if a given position doesn't have null values.
         * @param position
         * @returns: true = valid, false = invalid.
         */
        static Validate(position) {
            if (!position) {
                return false;
            }
            else if (!position.x && position.x != 0) {
                return false;
            }
            else if (!position.y && position.y != 0) {
                return false;
            }
            return true;
        }
        /**
         * Makes sure first and last position are equal.
         * @param positions
         * @returns closed variant of provided positions.
         */
        static CloseRing(positions) {
            if (positions.length < 2) {
                return positions;
            }
            let tmp = positions.concat([]);
            let p1 = tmp[0];
            let p2 = tmp[tmp.length - 1];
            if (p1.x != p2.x || p1.y != p2.y) {
                tmp.push(p1);
            }
            return tmp;
        }
        /**
         * Returns if given ring is closed.
         * @param positions
         */
        static IsClosedRing(positions) {
            if (positions.length < 2) {
                return true;
            }
            let p1 = positions[0];
            let p2 = positions[positions.length - 1];
            return p1.x == p2.x && p1.y == p2.y;
        }
    }
    exports.Cartesian2 = Cartesian2;
});
define("utils/math-utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MathUtils = void 0;
    class MathUtils {
        /**
         * Rounds using epsilon to provided amount of decimals.
         * @param num
         * @param decimals
         * @returns
         */
        static Round(num, decimals) {
            let tmp = "1";
            for (let i = 0; i < decimals; i++) {
                tmp += "0";
            }
            let d = parseFloat(tmp);
            return Math.round((num + Number.EPSILON) * d) / d;
        }
        /**
         * Returns if a given value is within a range.
         * This is boundaries inclusive.
         * @param val
         * @param lower
         * @param upper
         * @returns
         */
        static IsWithinRange(val, lower, upper) {
            return val <= upper && val >= lower;
        }
        /**
         * Returns a random integer value between a given range.
         * This is boundaries inclusive.
         * @param min
         * @param max
         * @returns
         */
        static RandInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
    }
    exports.MathUtils = MathUtils;
});
define("bruce-models/common/boundaries", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Boundaries = void 0;
    class Boundaries {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current state as raw JSON.
         */
        get JSON() {
            let data = {
                maxLatitude: this.maxLatitude,
                minLatitude: this.minLatitude,
                maxLongitude: this.maxLongitude,
                minLongitude: this.minLongitude,
                maxAltitude: this.maxAltitude,
                minAltitude: this.minAltitude
            };
            return data;
        }
        /**
         * Returns if geometry is valid.
         * (Checks if lat/lon values aren't null or 0).
         */
        get isValid() {
            return !!this.maxLatitude && !!this.minLatitude && !!this.minLongitude && !!this.maxLongitude;
        }
        /**
         * Returns if boundaries include altitude values.
         * Warning, this checks if not null, 0 is a valid value.
         */
        get hasAltitude() {
            return this.maxAltitude != null && this.minAltitude != null;
        }
        /**
         * Zeroes the boundary values.
         * @param onlyNulls If only null/undefined values should be zerod.
         */
        Zero(onlyNulls) {
            if (!onlyNulls || this.maxAltitude == null) {
                this.maxAltitude = 0;
            }
            if (!onlyNulls || this.minAltitude == null) {
                this.minAltitude = 0;
            }
            if (!onlyNulls || this.maxLatitude == null) {
                this.maxLatitude = 0;
            }
            if (!onlyNulls || this.minLatitude == null) {
                this.minLatitude = 0;
            }
            if (!onlyNulls || this.maxLongitude == null) {
                this.maxLongitude = 0;
            }
            if (!onlyNulls || this.minLongitude == null) {
                this.minLongitude = 0;
            }
        }
        /**
         * Increases boundaries to include provided point.
         * @param point
         */
        IncludePoint(point) {
            if (this.maxLatitude == null || point.latitude > this.maxLatitude) {
                this.maxLatitude = point.latitude;
            }
            if (this.maxLongitude == null || point.longitude > this.maxLongitude) {
                this.maxLongitude = point.longitude;
            }
            if (this.minLatitude == null || point.latitude < this.minLatitude) {
                this.minLatitude = point.latitude;
            }
            if (this.minLongitude == null || point.longitude < this.minLongitude) {
                this.minLongitude = point.longitude;
            }
            if (point.altitude != null) {
                if (this.maxAltitude == null || point.altitude > this.maxAltitude) {
                    this.maxAltitude = point.altitude;
                }
                if (this.minAltitude == null || point.altitude < this.minAltitude) {
                    this.minAltitude = point.altitude;
                }
            }
        }
        /**
         * Increases boundaries to include provided points.
         * @param points
         */
        IncludePoints(points) {
            for (let i = 0; i < points.length; i++) {
                this.IncludePoint(points[i]);
            }
        }
        /**
         * Increases boundaries instance using given boundaries.
         * @param boundaries
         */
        IncludeBoundaries(boundaries) {
            let maxPoint = { latitude: boundaries.maxLatitude, longitude: boundaries.maxLongitude, altitude: boundaries.maxAltitude };
            let minPoint = { latitude: boundaries.minLatitude, longitude: boundaries.minLongitude, altitude: boundaries.minAltitude };
            this.IncludePoints([maxPoint, minPoint]);
        }
        /**
         * Returns the boundaries center point.
         * Will return NULL if no center can be calculated.
         */
        CalculateCenter() {
            if (this.isValid) {
                let carto = {
                    altitude: 0,
                    latitude: 0,
                    longitude: 0
                };
                let latTotal = this.maxLatitude + this.minLatitude;
                let lonTotal = this.maxLongitude + this.minLongitude;
                if (latTotal != 0) {
                    carto.latitude = latTotal / 2;
                }
                if (lonTotal != 0) {
                    carto.longitude = lonTotal / 2;
                }
                if (this.hasAltitude) {
                    let altTotal = this.maxAltitude + this.minAltitude;
                    if (altTotal != 0) {
                        carto.altitude = altTotal / 2;
                    }
                }
                return carto;
            }
            else {
                return null;
            }
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.maxLatitude != null) {
                this.maxLatitude = rawData.maxLatitude;
            }
            if (rawData.minLatitude != null) {
                this.minLatitude = rawData.minLatitude;
            }
            if (rawData.maxLongitude != null) {
                this.maxLongitude = rawData.maxLongitude;
            }
            if (rawData.minLongitude != null) {
                this.minLongitude = rawData.minLongitude;
            }
            if (rawData.maxAltitude != null) {
                this.maxAltitude = rawData.maxAltitude;
            }
            if (rawData.minAltitude != null) {
                this.minAltitude = rawData.minAltitude;
            }
        }
        /**
         * Creates boundaries instance from given geometry.
         * Returns null if unable to do so.
         * @param geometry
         */
        static FromGeometry(geometry) {
            return geometry === null || geometry === void 0 ? void 0 : geometry.CalculateBoundaries();
        }
    }
    exports.Boundaries = Boundaries;
});
define("bruce-models/common/bruce-list", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("bruce-models/common/lod", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LOD = void 0;
    class LOD {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                "ClientFile.ID": this["ClientFile.ID"],
                "Entity.ID": this["Entity.ID"],
                "LODCategory.Key": this["LODCategory.Key"],
                Level: this.Level
            };
            data = object_utils_1.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData["ClientFile.ID"] != null) {
                this["ClientFile.ID"] = rawData["ClientFile.ID"];
            }
            if (rawData["Entity.ID"] != null) {
                this["Entity.ID"] = rawData["Entity.ID"];
            }
            if (rawData["LODCategory.Key"] != null) {
                this["LODCategory.Key"] = rawData["LODCategory.Key"];
            }
            if (rawData.Level != null) {
                this.Level = rawData.Level;
            }
        }
        /**
         * Constructs URL to an entity LOD.
         * This method will check if URL is valid before returning.
         * @param entityId
         * @param lodCategoryId
         * @param lodLevel
         * @param strict Strict means it won't dribble down to find any LOD at or under given LOD level.
         */
        static getURL(api, entityId, lodCategoryId, lodLevel, strict = false) {
            return __awaiter(this, void 0, void 0, function* () {
                let result = null;
                try {
                    let lodRecord = yield api.get(api.BRUCE_URL + `entity/${entityId}/lodRecord/${lodCategoryId}/${lodLevel}`);
                    if (lodRecord["ClientFile.ID"]) {
                        result = api.BRUCE_URL + `entity/${entityId}/lod/${lodCategoryId}/${lodLevel}`;
                        if (strict) {
                            result = result + "?strict=true";
                        }
                    }
                }
                catch (_a) {
                    result = null;
                }
                return Promise.resolve(result);
            });
        }
        /**
         * Constructs URL to an entity LOD.
         * This method will not check if URL is valid.
         * @param entityId
         * @param lodCategoryId
         * @param lodLevel
         * @param strict Strict means it won't dribble down to find any LOD at or under given LOD level.
         */
        static getUncheckedURL(api, entityId, lodCategoryId, lodLevel, strict = false) {
            let result = api.BRUCE_URL + `entity/${entityId}/lod/${lodCategoryId}/${lodLevel}`;
            if (strict) {
                result = result + "?strict=true";
            }
            return result;
        }
        /**
         * Updates entity LOD file corresponding to given details.
         * @param api
         * @param entityId
         * @param clientFileId
         * @param lodTypeId
         * @param lodLevel
         */
        static UpdateEntityLOD(api, entityId, clientFileId, lodTypeId, lodLevel) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let reqData = {
                        "Level": lodLevel,
                        "ClientFile.ID": clientFileId
                    };
                    let data = yield api.post(api.BRUCE_URL + `entity/${entityId}/lod/${lodTypeId}/0`, JSON.stringify(reqData));
                    if (data) {
                        return new LOD(data);
                    }
                    else {
                        return null;
                    }
                }
                catch (e) {
                    console.log(">>Error: Failed to update entity LOD.");
                    console.log(e);
                }
                return null;
            });
        }
    }
    exports.LOD = LOD;
});
define("bruce-models/common/bruce", ["require", "exports", "bruce-models/common/utc"], function (require, exports, utc_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Bruce = void 0;
    class Bruce {
        constructor(rawData) {
            // Layer ids this entity is associated with.
            this["Layer.ID"] = [];
            this.Update(rawData);
        }
        /**
         * Returns current state as raw JSON.
         */
        get JSON() {
            let data = {
                "CreatedBy.User.ID": this["CreatedBy.User.ID"],
                "EntityType.ID": this["EntityType.ID"],
                ID: this.ID,
                "Layer.ID": this["Layer.ID"],
                CreatedTime: null,
                LOD: []
            };
            if (this.CreatedTime) {
                data.CreatedTime = this.CreatedTime.JSON;
            }
            if (this.LOD) {
                data.LOD = this.LOD.map(x => x === null || x === void 0 ? void 0 : x.JSON);
            }
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData["CreatedBy.User.ID"] != null) {
                this["CreatedBy.User.ID"] = rawData["CreatedBy.User.ID"];
            }
            if (rawData.CreatedTime != null) {
                this.CreatedTime = new utc_1.UTC(rawData.CreatedTime);
            }
            if (rawData["EntityType.ID"] != null) {
                this["EntityType.ID"] = rawData["EntityType.ID"];
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData["Layer.ID"] != null) {
                this["Layer.ID"] = rawData["Layer.ID"];
            }
        }
    }
    exports.Bruce = Bruce;
});
define("bruce-models/common/transformation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transformation = void 0;
    class Transformation {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current state as raw JSON.
         */
        get JSON() {
            let data = {
                heading: this.heading,
                pitch: this.pitch,
                roll: this.roll,
                scale: this.scale
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.heading != null) {
                this.heading = rawData.heading;
            }
            if (rawData.pitch != null) {
                this.pitch = rawData.pitch;
            }
            if (rawData.roll != null) {
                this.roll = rawData.roll;
            }
            if (rawData.scale != null) {
                this.scale = rawData.scale;
            }
        }
    }
    exports.Transformation = Transformation;
});
define("utils/hash", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Hash = void 0;
    class Hash {
        /**
         * Hash function.
         * https://stackoverflow.com/questions/7616461/generate-a-hash-from-string-in-javascript
        */
        static Cyrb53Hash(str, seed = 0) {
            let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
            for (let i = 0, ch; i < str.length; i++) {
                ch = str.charCodeAt(i);
                h1 = Math.imul(h1 ^ ch, 2654435761);
                h2 = Math.imul(h2 ^ ch, 1597334677);
            }
            h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507) ^ Math.imul(h2 ^ (h2 >>> 13), 3266489909);
            h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507) ^ Math.imul(h1 ^ (h1 >>> 13), 3266489909);
            return (4294967296 * (2097151 & h2) + (h1 >>> 0)) + "";
        }
    }
    exports.Hash = Hash;
});
define("entry-points/common/bruce-meta", ["require", "exports", "utils/hash"], function (require, exports, hash_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceMeta = void 0;
    class BruceMeta {
        /**
         *
         * @param path The path to the top element.
         * @param entityType
         * @param string
         */
        constructor(path, entityType, clientAccountId) {
            this.entityTypeId = entityType;
            this.entityPath = path;
            this.clientAccountId = clientAccountId;
        }
        get clientAccountId() {
            return this._clientAccountId;
        }
        set clientAccountId(value) {
            this._hash = null;
            this._clientAccountId = value;
        }
        /**
         * Extract the id from the path
         */
        static EntityID(path) {
            if (path && path.length > 0) {
                return path[path.length - 1];
            }
            return null;
        }
        /**
         * Extract the id from the path
         */
        EntityID() {
            return BruceMeta.EntityID(this.entityPath);
        }
        /**
         * @param path the full item path
         */
        static HashPath(path) {
            if (path.length == 0) {
                return null;
            }
            let hashedPath = [];
            for (let i = 0; i < path.length; i++) {
                let id = path[i];
                let hash = hash_1.Hash.Cyrb53Hash(id);
                hashedPath.push(hash);
            }
            return "".concat(...hashedPath);
        }
        /**
         * @param path the full item path
         */
        HashPath() {
            if (this._hash) {
                return this._hash;
            }
            else {
                let hash = BruceMeta.HashPath(this.entityPath);
                this._hash = hash;
                return hash;
            }
        }
    }
    exports.BruceMeta = BruceMeta;
});
define("utils/bruce-event", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceEvent = void 0;
    /**
     * Class for creating and dispatching events comfortably.
     */
    class BruceEvent {
        constructor() {
            // Counter to help differentiate subscriptions.
            this._counter = 0;
            // Record of all callback subscriptions for this event.
            this.callbacks = [];
        }
        /**
         * Subscribes to the event.
         * Returns remove callback to call when wanting to unsubscribe.
         * @param callback Callback to call when the event triggers.
         */
        Subscribe(callback) {
            let id = this._counter++;
            let newBruceEventCallback = {
                _id: id,
                removeCallback: () => {
                    this.Unsubscribe(id);
                },
                callback: callback
            };
            this.callbacks.push(newBruceEventCallback);
            return newBruceEventCallback.removeCallback;
        }
        /**
         * Unsubscribes a callback corresponding to a given callback id.
         * @param id
         */
        Unsubscribe(id) {
            let index = this.callbacks.findIndex(x => x._id == id);
            if (index > -1) {
                this.callbacks.splice(index, 1);
            }
            else {
                // Do nothing.
            }
        }
        /**
         * Notifies all subscribers with given data.
         * @param data
         */
        Trigger(data) {
            let callbacks = this.callbacks;
            for (let i = 0; i < callbacks.length; i++) {
                let callback = callbacks[i];
                if (callback.callback) {
                    callback.callback(data);
                }
            }
        }
        /**
         * Clears all subscriptions.
         */
        Clear() {
            this.callbacks = [];
        }
    }
    exports.BruceEvent = BruceEvent;
});
define("entry-points/common/view-monitor-ifs", ["require", "exports", "bruce-maps-widget"], function (require, exports, bruce_maps_widget_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CPointDegrees = exports.CBoundsDegrees = exports.CBoundsRadians = exports.IBoundsUtils = void 0;
    class IBoundsUtils {
        static IsEqual(a, b) {
            if ((a == null) || (b == null)) {
                return false;
            }
            if (a.east != b.east) {
                return false;
            }
            if (a.west != b.west) {
                return false;
            }
            if (a.north != b.north) {
                return false;
            }
            if (a.south != b.south) {
                return false;
            }
            if (a.Units != b.Units) {
                return false;
            }
            return true;
        }
        static IsPointInBounds(point, bounds) {
            let between = (a, b, c) => {
                if ((Math.min(b, c) <= a) && (a <= Math.max(b, c))) {
                    return true;
                }
                return false;
            };
            if (point.Units != bounds.Units) {
                return false;
            }
            if (!between(point.longitude, bounds.west, bounds.east)) {
                return false;
            }
            if (!between(point.latitude, bounds.north, bounds.south)) {
                return false;
            }
            return true;
        }
    }
    exports.IBoundsUtils = IBoundsUtils;
    class CBoundsRadians {
        constructor() {
            this.Units = "Radians";
        }
        IsEqual(other) {
            return IBoundsUtils.IsEqual(this, other);
        }
    }
    exports.CBoundsRadians = CBoundsRadians;
    class CBoundsDegrees {
        constructor() {
            this.Units = "Degrees";
        }
        IsEqual(other) {
            return IBoundsUtils.IsEqual(this, other);
        }
        static FromRadians(rads) {
            if (!rads.Units.includes("Radians")) {
                return null;
            }
            let result = new CBoundsDegrees();
            result.east = bruce_maps_widget_2.DrawingUtils.RadToDeg(rads.east);
            result.west = bruce_maps_widget_2.DrawingUtils.RadToDeg(rads.west);
            result.south = bruce_maps_widget_2.DrawingUtils.RadToDeg(rads.south);
            result.north = bruce_maps_widget_2.DrawingUtils.RadToDeg(rads.north);
            return result;
        }
    }
    exports.CBoundsDegrees = CBoundsDegrees;
    class CPointDegrees {
        constructor() {
            this.Units = "Degrees";
        }
        IsEqual(other) {
            if (other == null) {
                return false;
            }
            if (this.Units != other.Units) {
                return false;
            }
            if (this.longitude != other.longitude) {
                return false;
            }
            if (this.latitude != other.latitude) {
                return false;
            }
            if (this.altitude != other.altitude) {
                return false;
            }
            return true;
        }
    }
    exports.CPointDegrees = CPointDegrees;
});
define("bruce-models/common/dictionary", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Dictionary = void 0;
    /**
     * Dictionary model that provides additonal functionality for interacting with values as if they were keys.
     */
    class Dictionary {
        constructor(rawData = null) {
            this.data = {};
            if (rawData) {
                for (let key in rawData) {
                    this.data[key] = rawData[key];
                }
            }
        }
        /**
         * Returns instance as raw data.
         */
        get JSON() {
            return object_utils_2.ObjectUtils.Dereference(this.data, true);
        }
        /**
         * @returns an array of all keys
         */
        GetKeys() {
            return Object.keys(this.data);
        }
        /**
         * @returns all values.
         */
        getValues() {
            let values = [];
            let keys = this.GetKeys();
            for (let i = 0; i < keys.length; i++) {
                let value = this.data[keys[i]];
                values.push(value);
            }
            return values;
        }
        /**
         * Clears all dictionary data.
         */
        Clear() {
            delete this.data;
            this.data = {};
        }
        /**
         * Swaps keys and values to create a new dictionary.
         * Values cannot be objects.
         * @returns raw data dictionary.
         */
        getFlippedData() {
            let data = this.data;
            let flipped = {};
            for (let key in data) {
                let value = data[key];
                flipped[value] = key;
            }
            return new Dictionary(flipped);
        }
        /**
         * Assigns value by given key.
         * @param key
         * @param value
         */
        Assign(key, value) {
            this.data[key] = value;
        }
        /**
         * Deletes if able by given key.
         * @param key
         */
        Delete(key) {
            if (this.data[key]) {
                delete this.data[key];
            }
        }
        /**
         * Deletes if able by given value.
         * @param value
         */
        DeleteByValue(value) {
            let flipped = this.getFlippedData();
            let key = flipped.Get(value);
            if (key) {
                this.Delete(key);
            }
        }
        /**
         * Retrieves data by given key.
         * @param key
         * @returns
         */
        Get(key) {
            return this.data[key];
        }
        /**
         * Retrieves data by given value.
         * @param value
         * @returns
         */
        GetByValue(value) {
            let flipped = this.getFlippedData();
            let key = flipped.Get(value);
            return key;
        }
    }
    exports.Dictionary = Dictionary;
});
define("bruce-models/common/sort-order", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SortOrder = void 0;
    var SortOrder;
    (function (SortOrder) {
        SortOrder[SortOrder["None"] = 0] = "None";
        SortOrder[SortOrder["Asc"] = 1] = "Asc";
        SortOrder[SortOrder["Desc"] = -1] = "Desc";
    })(SortOrder = exports.SortOrder || (exports.SortOrder = {}));
});
define("bruce-models/common/entity-filter", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityFilter = void 0;
    class EntityFilter {
        constructor(params) {
            // Maximum number of entities.
            this.pageSize = 0;
            // The page number the filter is going through.
            this.pageIndex = 0;
            this.Update(params);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(params) {
            // Cannot update with null data.
            if (!params) {
                return;
            }
            if (params.orderBy != null) {
                this.orderBy = params.orderBy;
            }
            if (params.entityTypeId != null) {
                this.entityTypeId = params.entityTypeId;
            }
            if (params.layerIds != null) {
                this.layerIds = params.layerIds;
            }
            if (params.bounds != null) {
                this.bounds = params.bounds;
            }
            if (params.pageSize != null) {
                this.pageSize = params.pageSize;
            }
            if (params.pageIndex != null) {
                this.pageIndex = params.pageIndex;
            }
            if (params.lodCategoryId != null) {
                this.lodCategoryId = params.lodCategoryId;
            }
            if (params.sortOrder != null) {
                this.sortOrder = params.sortOrder;
            }
            if (params.entityTypeConditions != null) {
                this.entityTypeConditions = params.entityTypeConditions;
            }
        }
    }
    exports.EntityFilter = EntityFilter;
});
define("bruce-models/common/complex-files-filter-row", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComplexFilesFilterRow = exports.EComplexFilterRowOperator = exports.EComplexFilesFilterRowColumn = void 0;
    var EComplexFilesFilterRowColumn;
    (function (EComplexFilesFilterRowColumn) {
        EComplexFilesFilterRowColumn["ID"] = "id";
        EComplexFilesFilterRowColumn["Name"] = "name";
        EComplexFilesFilterRowColumn["DateTime"] = "date";
        EComplexFilesFilterRowColumn["MIMEType"] = "mimeType";
        EComplexFilesFilterRowColumn["Size"] = "size";
        EComplexFilesFilterRowColumn["User"] = "user";
        EComplexFilesFilterRowColumn["Extesion"] = "extension";
        EComplexFilesFilterRowColumn["Extension"] = "extension";
    })(EComplexFilesFilterRowColumn = exports.EComplexFilesFilterRowColumn || (exports.EComplexFilesFilterRowColumn = {}));
    var EComplexFilterRowOperator;
    (function (EComplexFilterRowOperator) {
        EComplexFilterRowOperator["AND"] = "AND";
        EComplexFilterRowOperator["OR"] = "OR";
    })(EComplexFilterRowOperator = exports.EComplexFilterRowOperator || (exports.EComplexFilterRowOperator = {}));
    class ComplexFilesFilterRow {
        constructor(rawData) {
            // If we are including or excluding files that match this filter.
            this.includes = true;
            // Row operator (AND or OR).
            this.rowOperator = EComplexFilterRowOperator.AND;
            // Sub filter rows.
            this.rows = [];
            this.Update(rawData);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.column != null) {
                this.column = rawData.column;
            }
            if (rawData.value != null) {
                this.value = rawData.value;
            }
            if (rawData.valueOperator != null) {
                this.valueOperator = rawData.valueOperator;
            }
            if (rawData.includes != null) {
                this.includes = rawData.includes;
            }
            if (rawData.rowOperator != null) {
                this.rowOperator = rawData.rowOperator;
            }
            if (rawData.rows != null) {
                this.rows = ComplexFilesFilterRow.FilesFilterRowsFromRaw(rawData.rows);
            }
        }
        /**
         * Returns filter row instances from given raw data.
         * @param rawData
         */
        static FilesFilterRowsFromRaw(rawData) {
            if (rawData && rawData.length) {
                let rows = [];
                for (let i = 0; i < rawData.length; i++) {
                    let raw = rawData[i];
                    let row = new ComplexFilesFilterRow(raw);
                    rows.push(row);
                }
                return rows;
            }
            return [];
        }
    }
    exports.ComplexFilesFilterRow = ComplexFilesFilterRow;
});
define("bruce-models/common/complex-files-filter", ["require", "exports", "bruce-models/common/complex-files-filter-row"], function (require, exports, complex_files_filter_row_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ComplexFilesFilter = exports.EComplexFilesFilterSortOrder = exports.EComplexFilesFilterColumn = void 0;
    var EComplexFilesFilterColumn;
    (function (EComplexFilesFilterColumn) {
        EComplexFilesFilterColumn["ID"] = "id";
        EComplexFilesFilterColumn["Name"] = "filename";
        EComplexFilesFilterColumn["DateTime"] = "datetime";
        EComplexFilesFilterColumn["MIMEType"] = "mimeType";
        EComplexFilesFilterColumn["Size"] = "size";
        EComplexFilesFilterColumn["User"] = "user";
    })(EComplexFilesFilterColumn = exports.EComplexFilesFilterColumn || (exports.EComplexFilesFilterColumn = {}));
    var EComplexFilesFilterSortOrder;
    (function (EComplexFilesFilterSortOrder) {
        EComplexFilesFilterSortOrder["ASC"] = "asc";
        EComplexFilesFilterSortOrder["DEC"] = "desc";
    })(EComplexFilesFilterSortOrder = exports.EComplexFilesFilterSortOrder || (exports.EComplexFilesFilterSortOrder = {}));
    class ComplexFilesFilter {
        constructor(rawData) {
            // Page size for results.
            this.PageSize = 50;
            // Page index for results.
            this.PageIndex = 0;
            // What column should the results be ordered by.
            this.OrderBy = EComplexFilesFilterColumn.DateTime;
            // The sort order.
            this.SortOrder = EComplexFilesFilterSortOrder.ASC;
            // The file purpose. Null for purpose not to be included in filter.
            this.Purpose = "";
            // Rows containing information about filtering the files.
            this.FilterRows = [];
            this.Update(rawData);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.PageSize != null) {
                this.PageSize = rawData.PageSize;
            }
            if (rawData.PageIndex != null) {
                this.PageIndex = rawData.PageIndex;
            }
            if (rawData.OrderBy != null) {
                this.OrderBy = rawData.OrderBy;
            }
            if (rawData.SortOrder != null) {
                this.SortOrder = rawData.SortOrder;
            }
            if (rawData.Purpose != null) {
                this.Purpose = rawData.Purpose;
            }
            if (rawData.FilterRows != null) {
                this.FilterRows = complex_files_filter_row_1.ComplexFilesFilterRow.FilesFilterRowsFromRaw(rawData.FilterRows);
            }
        }
    }
    exports.ComplexFilesFilter = ComplexFilesFilter;
});
define("bruce-models/common/client-file", ["require", "exports", "utils/object-utils", "bruce-models/common/utc"], function (require, exports, object_utils_3, utc_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientFile = void 0;
    /**
     * Represents a file in the bruce system.
     */
    class ClientFile {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a;
            let data = {
                ID: this.ID,
                UploadedTimeUTC: (_a = this.UploadedTimeUTC) === null || _a === void 0 ? void 0 : _a.JSON,
                FileExt: this.FileExt,
                MIMEType: this.MIMEType,
                OriginalFileName: this.OriginalFileName,
                OriginalLength: this.OriginalLength,
                "UploadedByUser.ID": this["UploadedByUser.ID"],
                Purpose: this.Purpose
            };
            data = object_utils_3.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns URL to client file download.
         * @param api
         * @returns
         */
        getDownloadURL(api) {
            return ClientFile.getClientFileURL(api, this.ID);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.UploadedTimeUTC != null) {
                this.UploadedTimeUTC = new utc_2.UTC(rawData.UploadedTimeUTC);
            }
            if (rawData.FileExt != null) {
                this.FileExt = rawData.FileExt;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.MIMEType != null) {
                this.MIMEType = rawData.MIMEType;
            }
            if (rawData.OriginalFileName != null) {
                this.OriginalFileName = rawData.OriginalFileName;
            }
            if (rawData.OriginalLength != null) {
                this.OriginalLength = rawData.OriginalLength;
            }
            if (rawData["UploadedByUser.ID"] != null) {
                this["UploadedByUser.ID"] = rawData["UploadedByUser.ID"];
            }
            if (rawData.Purpose != null) {
                this.Purpose = rawData.Purpose;
            }
        }
        /**
         * Deletes the client file record.
         * @param api
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield api.delete(api.BRUCE_URL + `file/${this.ID}`);
                }
                catch (e) {
                    console.log("Error: Failed to delete client file by id: " + this.ID);
                    console.log(e);
                }
            });
        }
        /**
         * Returns client file instance corresponding to a client file id.
         * @param api
         * @param fileId
         * @returns
         */
        static getClientFileById(api, fileId) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield ClientFile.getClientFileRawById(api, fileId);
                if (data) {
                    return new ClientFile(data);
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Returns client file raw data corresponding to a client file id.
         * @param api
         * @param fileId
         * @returns
         */
        static getClientFileRawById(api, fileId) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield api.get(api.BRUCE_URL + `file/${fileId}/details`);
                    return data;
                }
                catch (e) {
                    console.log(">>Error: Failed to get client file by id: " + fileId);
                    console.log(e);
                }
                return null;
            });
        }
        /**
         * Uploads blob as a client file and returns the record data.
         * @param api
         * @param file
         * @param progress
         * @returns
         */
        static postUploadClientFile(api, file, progress) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield api.upload(api.BRUCE_URL + "file/uploadNew", file, progress);
                    if (data) {
                        return new ClientFile(data);
                    }
                }
                catch (e) {
                    console.log(">>Error: Failed to upload client file.");
                    console.log(file);
                }
                return null;
            });
        }
        /**
         * Delete client files by given file ids.
         * @param api
         * @param fileIds
         */
        static DeleteClientFilesByIDs(api, fileIds) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = {
                        Items: fileIds
                    };
                    yield api.post(api.BRUCE_URL + "deleteFiles", JSON.stringify(data));
                }
                catch (e) {
                    console.log("Error: Failed to delete client files by ids.");
                    console.log(fileIds);
                    console.log(e);
                }
            });
        }
        /**
         * Returns client file records corresponding to given complex filter.
         * @param api
         * @param complexFilter
         * @returns
         */
        static GetComplexFilteredFiles(api, complexFilter) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield api.post(api.BRUCE_URL + "files/filtered", JSON.stringify(complexFilter));
                    if (data && data.Items) {
                        let files = [];
                        for (let i = 0; i < data.Items.length; i++) {
                            let file = new ClientFile(data.Items[i]);
                            files.push(file);
                        }
                        return files;
                    }
                    else {
                        return [];
                    }
                }
                catch (e) {
                    console.log(">>Error: Failed to get files by complex filter.");
                    console.log(complexFilter);
                    console.log(e);
                }
                return [];
            });
        }
        /**
         * Returns URL to client file download corresponding to a client file id.
         * @param api
         * @param fileId
         */
        static getClientFileURL(api, fileId) {
            return api.BRUCE_URL + `file/${fileId}`;
        }
        /**
         * Returns dictionary of purpose keys and the amount of files corresponding to that purpose that exist.
         * @param api
         * @returns
         */
        static getFilePurposeCounts(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.get(api.BRUCE_URL + "file/purpose/counts");
            });
        }
        /**
         * Returns dictionary of file extesion keys and the amount of files corresponding to that purpose that exist.
         * @param api
         * @returns
         */
        static getFileExtensionCounts(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.get(api.BRUCE_URL + "file/extension/counts");
            });
        }
        /**
         * Returns dictionary of MIMEType keys and the amount of files corresponding to that purpose that exist.
         * @param api
         * @returns
         */
        static getFileMIMETypeCounts(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.get(api.BRUCE_URL + "file/mimetype/counts");
            });
        }
        /**
         * Returns dictionary of user id keys and the amount of files corresponding to that purpose that exist.
         * @param api
         * @returns
         */
        static getFileUserCounts(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.get(api.BRUCE_URL + "file/user/counts");
            });
        }
    }
    exports.ClientFile = ClientFile;
});
define("bruce-models/pending-action/pending-action-progress-message", ["require", "exports", "bruce-models/common/sort-order", "bruce-models/common/utc"], function (require, exports, sort_order_1, utc_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PendingActionProgressMessage = void 0;
    /**
     * Represents a progress message record related to a pending action.
     */
    class PendingActionProgressMessage {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current state of progress message as raw JSON data.
         */
        get JSON() {
            var _a;
            let message = {
                ID: this.ID,
                "PendingAction.ID": this.PendingActionID,
                "CreatedBy.Application": this.CreatedByApplication,
                "Created.Time": (_a = this.CreatedTime) === null || _a === void 0 ? void 0 : _a.JSON,
                "Message.Type": this.MessageType,
                Message: this.MessageText
            };
            return message;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData["PendingAction.ID"] != null) {
                this.PendingActionID = rawData["PendingAction.ID"];
            }
            if (rawData["CreatedBy.Application"] != null) {
                this.CreatedByApplication = rawData["CreatedBy.Application"];
            }
            if (rawData["Created.Time"] != null) {
                this.CreatedTime = new utc_3.UTC(rawData["Created.Time"]);
            }
            if (rawData["Message.Type"] != null) {
                this.MessageType = rawData["Message.Type"];
            }
            if (rawData.Message != null) {
                this.MessageText = rawData.Message;
            }
        }
        /**
         * Returns progress messages corresponding to a given pending action ID.
         * @param api
         * @param pendingActionId
         * @param order: Default = ASC
         * @param index: Default = 0
         * @param amount: Default = 500
         * @returns
         */
        static GetMessagesForPendingActionID(api, pendingActionId, order, index, amount) {
            return __awaiter(this, void 0, void 0, function* () {
                let messages = [];
                if (amount == null) {
                    amount = 500;
                }
                if (index == null) {
                    index = 0;
                }
                if (order == null) {
                    order = sort_order_1.SortOrder.Asc;
                }
                let args = `?SortOrder=${order == sort_order_1.SortOrder.Desc ? "DESC" : "ASC"}&PageSize=${amount}&PageIndex=${index}`;
                let data = yield api.get(api.BRUCE_URL + `pendingAction/${pendingActionId}/progressMessages` + args);
                let items = data.Items;
                for (let i = 0; i < items.length; i++) {
                    let message = new PendingActionProgressMessage(items[i]);
                    messages.push(message);
                }
                return messages;
            });
        }
    }
    exports.PendingActionProgressMessage = PendingActionProgressMessage;
});
define("bruce-models/pending-action/pending-action", ["require", "exports", "bruce-models/common/utc", "bruce-models/pending-action/pending-action-progress-message"], function (require, exports, utc_4, pending_action_progress_message_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PendingAction = exports.EPendingActionStatus = void 0;
    var EPendingActionStatus;
    (function (EPendingActionStatus) {
        EPendingActionStatus["InProgress"] = "IN_PROGRESS";
        EPendingActionStatus["Cancelled"] = "CANCELLED";
        EPendingActionStatus["Complete"] = "COMPLETE";
        EPendingActionStatus["Failed"] = "FAILED";
    })(EPendingActionStatus = exports.EPendingActionStatus || (exports.EPendingActionStatus = {}));
    /**
     * Represents a record for a running process on the server.
     */
    class PendingAction {
        constructor(rawData) {
            // Progress messages associated with this pending action.
            // Won't be automatically loaded, call load method.
            this.progressMessages = [];
            this.Update(rawData);
        }
        /**
         * Returns current state of pending action as raw JSON data.
         */
        get JSON() {
            var _a, _b, _c;
            let pendingAction = {
                ID: this.ID,
                Description: this.Description,
                "CreatedByUser.ID": this.CreatedByUserID,
                "CreatedBy.Application": this.CreatedByApplication,
                "Created.Time": (_a = this.CreatedTime) === null || _a === void 0 ? void 0 : _a.JSON,
                "Completed.Time": (_b = this.CompletedTime) === null || _b === void 0 ? void 0 : _b.JSON,
                Progress: this.Progress,
                Result: this.Result,
                Status: this.Status,
                lastUpdated: (_c = this.lastUpdated) === null || _c === void 0 ? void 0 : _c.JSON
            };
            return pendingAction;
        }
        get HasCompleted() {
            return this.Status != EPendingActionStatus.InProgress;
        }
        get CompletionPercent() {
            if (this.HasCompleted) {
                return 100;
            }
            let progress = this.Progress;
            if (progress == null) {
                return 0;
            }
            let percent = progress > 100 ? 100 : progress < 0 ? 0 : progress;
            return percent;
        }
        get FormattedResult() {
            let result = this.Result;
            if (result) {
                try {
                    let obj = JSON.parse(result);
                    let formatted = JSON.stringify(obj, undefined, 2);
                    return formatted;
                }
                catch (_a) {
                }
                return result.trim();
            }
            else {
                return "";
            }
        }
        /**
         * Returns formatted for UI elapsed time.
         */
        get Elapsed() {
            let date2 = this.CompletedTime;
            if (!date2) {
                date2 = utc_4.UTC.BruceUTCFromDate(new Date());
            }
            let difference = utc_4.UTC.getDifference(this.CreatedTime, date2);
            let formatted = utc_4.UTC.FormatSeconds(difference);
            return formatted;
        }
        /**
         * Updates instance using given arbitrary JSON data.
         * @param rawData
         * @returns
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData["CreatedBy.Application"] != null) {
                this.CreatedByApplication = rawData["CreatedBy.Application"];
            }
            if (rawData["Created.Time"] != null) {
                this.CreatedTime = new utc_4.UTC(rawData["Created.Time"]);
            }
            if (rawData["CreatedByUser.ID"] != null) {
                this.CreatedByUserID = rawData["CreatedByUser.ID"];
            }
            if (rawData.Result != null) {
                this.Result = rawData.Result;
            }
            if (rawData.Progress != null) {
                this.Progress = rawData.Progress;
            }
            if (rawData["Completed.Time"] != null) {
                this.CompletedTime = new utc_4.UTC(rawData["Completed.Time"]);
            }
            if (rawData.Description != null) {
                this.Description = rawData.Description;
            }
            if (rawData.Status != null) {
                this.Status = rawData.Status;
            }
            if (rawData.lastUpdated) {
                this.lastUpdated = new utc_4.UTC(rawData.lastUpdated);
            }
        }
        /**
         * Notifies to cancel current pending action.
         * Warning: It is up to the individual process to handle the cancel.
         * This means if a process does not check if the action is cancelled then it will continue running.
         */
        CallCancel(api) {
            return __awaiter(this, void 0, void 0, function* () {
                yield api.delete(api.BRUCE_URL + `pendingAction/${this.ID}`);
            });
        }
        /**
         * Loads/reloads and returns progress message records for current pending action.
         */
        LoadMessages(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let messages = yield pending_action_progress_message_1.PendingActionProgressMessage.GetMessagesForPendingActionID(api, this.ID);
                this.progressMessages = messages;
                return messages;
            });
        }
        /**
         * Gets current DB record for pending action and runs an update on instance.
         * @param refreshMessages If progress messages should be reloaded.
         */
        Refresh(api, refreshMessages = false) {
            return __awaiter(this, void 0, void 0, function* () {
                let rawData = yield PendingAction.GetRawPendingActionByID(api, this.ID);
                this.Update(rawData);
                if (refreshMessages === true) {
                    yield this.LoadMessages(api);
                }
            });
        }
        /**
         * Returns pending actions that may be useful for the current user to see.
         * @param stricter True means only return very recent actions.
         * @returns
         */
        static GetImportantPendingActions(api, stricter = false) {
            return __awaiter(this, void 0, void 0, function* () {
                let pendingActions = [];
                try {
                    let data = yield api.get(api.BRUCE_URL + `pendingActions/important?Update=${stricter}`);
                    let items = data.Items;
                    for (let i = 0; i < items.length; i++) {
                        let pendingAction = new PendingAction(items[i]);
                        pendingActions.push(pendingAction);
                    }
                }
                catch (e) {
                    console.log(">>Error: Failed to request important pending actions.");
                    console.log(e);
                }
                return pendingActions;
            });
        }
        /**
         * Returns pending action record by ID.
         * @param pendingActionId
         * @returns
         */
        static GetPendingActionByID(api, pendingActionId) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield PendingAction.GetRawPendingActionByID(api, pendingActionId);
                if (data && data.ID != null) {
                    return new PendingAction(data);
                }
                return null;
            });
        }
        /**
         * Returns raw pending action data by ID.
         * @param pendingActionId
         */
        static GetRawPendingActionByID(api, pendingActionId) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.get(api.BRUCE_URL + `pendingAction/${pendingActionId}`);
                return data;
            });
        }
    }
    exports.PendingAction = PendingAction;
});
define("bruce-models/common/authoring-settings", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthoringTool = void 0;
    var AuthoringTool;
    (function (AuthoringTool) {
        AuthoringTool["Model3D"] = "3DMODEL";
        AuthoringTool["Point"] = "POINT";
        AuthoringTool["Polygon"] = "POLYGON";
        AuthoringTool["Polyline"] = "POLYLINE";
    })(AuthoringTool = exports.AuthoringTool || (exports.AuthoringTool = {}));
});
define("bruce-models/common/entity-type-visual-settings", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("bruce-models/common/entity-type", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityType = exports.EEntityTypeAttributeType = void 0;
    var EEntityTypeAttributeType;
    (function (EEntityTypeAttributeType) {
        EEntityTypeAttributeType["String"] = "String";
        EEntityTypeAttributeType["Double"] = "Double";
        EEntityTypeAttributeType["Integer"] = "Integer";
        EEntityTypeAttributeType["Datetime"] = "Datetime";
        EEntityTypeAttributeType["Structure"] = "Structure";
        EEntityTypeAttributeType["Geometry"] = "Geometry";
    })(EEntityTypeAttributeType = exports.EEntityTypeAttributeType || (exports.EEntityTypeAttributeType = {}));
    class EntityType {
        constructor(rawData) {
            this.IsDeleted = false;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                ID: this.ID,
                IsDeleted: this.IsDeleted,
                Name: this.Name,
                Description: this.Description,
                Data: this.Data,
                DataSchema: this.DataSchema,
                DisplayNameAttributePath: this.DisplayNameAttributePath,
                "DisplaySetting.ID": this["DisplaySetting.ID"],
                VisualSettings: this.VisualSettings,
                AuthoringSettings: this.AuthoringSettings
            };
            data = object_utils_4.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new EntityType(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.IsDeleted != null) {
                this.IsDeleted = rawData.IsDeleted;
            }
            if (rawData.Name != null) {
                this.Name = rawData.Name;
            }
            if (rawData.Description != null) {
                this.Description = rawData.Description;
            }
            if (rawData.Data != null) {
                this.Data = rawData.Data;
            }
            if (rawData.DataSchema != null) {
                if (typeof rawData.DataSchema === "string") {
                    rawData.DataSchema = JSON.parse(rawData.DataSchema);
                }
                else {
                    this.DataSchema = rawData.DataSchema;
                }
            }
            if (rawData.DisplayNameAttributePath != null) {
                this.DisplayNameAttributePath = rawData.DisplayNameAttributePath;
            }
            if (rawData.ID != null) {
                this["DisplaySetting.ID"] = rawData["DisplaySetting.ID"];
            }
            if (rawData.VisualSettings != null) {
                this.VisualSettings = rawData.VisualSettings;
            }
            if (rawData.AuthoringSettings != null) {
                this.AuthoringSettings = rawData.AuthoringSettings;
            }
        }
        /**
         * Returns array of attribute paths used for entity names.
         * If none exist then empty array is returned.
         */
        GetEntityNamePaths() {
            let names = this.DisplayNameAttributePath ? this.DisplayNameAttributePath.split(",") : null;
            return names == null ? [] : names;
        }
        /**
         * Returns entity type corresponding to given id.
         * @param api
         * @param entityTypeId
         */
        static GetByID(api, entityTypeId) {
            return __awaiter(this, void 0, void 0, function* () {
                let cacheData = api.entityTypeCache.Get(entityTypeId);
                if (cacheData) {
                    return cacheData;
                }
                let data = yield api.GET("entityType/" + entityTypeId);
                if (data) {
                    let entityType = new EntityType(data);
                    api.entityTypeCache.Set(entityTypeId, entityType);
                    return entityType;
                }
                return null;
            });
        }
    }
    exports.EntityType = EntityType;
});
define("utils/bruce-path-utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrucePathUtils = void 0;
    class BrucePathUtils {
        /**
         * Tries to guess if given string is a legacy path.
         * Legacy paths were dot seperated such as "a.b".
         * @param path
         */
        static GuessIsLegacyPath(path) {
            if (!path) {
                path = "";
            }
            let dividerIndex = path.indexOf("\"/\"");
            if (dividerIndex > -1) {
                return false;
            }
            return path.indexOf(".") > -1;
        }
        /**
         * Unwraps a given path into an array.
         * @param path
         */
        static ParsePath(path) {
            if (!path) {
                return [];
            }
            let broken = path.split("\"/\"");
            if (broken.length > 0) {
                let top = broken[0];
                if (top.length > 0) {
                    if (top.charAt(0) == "\"") {
                        top = top.substring(1);
                    }
                    broken[0] = top;
                }
                let endIndex = broken.length - 1;
                let bot = broken[endIndex];
                if (bot.length > 0) {
                    if (bot.charAt(bot.length - 1) == "\"") {
                        bot = bot.substring(0, bot.length - 1);
                    }
                    broken[endIndex] = bot;
                }
            }
            return broken;
        }
        /**
         * Unwraps a given legacy path into an array.
         * @param path
         */
        static ParseLegacyPath(path) {
            let broken = path.split(".");
            for (let i = 0; i < broken.length; i++) {
                let piece = broken[0];
                if (piece.charAt(0) == "\"") {
                    piece = broken[0] = piece.substring(1);
                }
                if (piece.charAt(piece.length - 1) == "\"") {
                    broken[0] = piece.substring(0, piece.length - 1);
                }
            }
            return broken;
        }
        /**
         * Wraps a given path into a string.
         * @param path
         */
        static WrapPath(path) {
            let tmp = "\"";
            for (let i = 0; i < path.length; i++) {
                let section = path[i];
                tmp += section;
                if (i < path.length - 1) {
                    tmp += "\"/\"";
                }
            }
            tmp += "\"";
            return tmp;
        }
        /**
         * Converts legacy wrapped path into new path.
         * @param path
         */
        static LegacyPathToPath(path) {
            let unwrapped = BrucePathUtils.ParseLegacyPath(path);
            return BrucePathUtils.WrapPath(unwrapped);
        }
    }
    exports.BrucePathUtils = BrucePathUtils;
});
define("bruce-models/common/bruce-info", ["require", "exports", "bruce-models/common/bruce", "bruce-models/common/boundaries", "bruce-models/common/transformation", "bruce-models/common/geometry", "utils/object-utils", "entry-points/common/bruce-meta", "bruce-models/common/sort-order", "bruce-models/common/cartographic", "api/abstract-api", "bruce-models/pending-action/pending-action", "bruce-models/common/entity-type", "utils/bruce-path-utils"], function (require, exports, bruce_1, boundaries_1, transformation_1, geometry_1, object_utils_5, bruce_meta_1, sort_order_2, cartographic_1, abstract_api_2, pending_action_1, entity_type_1, bruce_path_utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceInfo = void 0;
    class BruceInfo {
        constructor(rawData) {
            // The raw JSON this instance was instantiated with.
            this._raw = {};
            // Bruce related information.
            this.Bruce = new bruce_1.Bruce(null);
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns raw JSON data using current instance data.
         */
        get JSON() {
            let data = Object.assign(Object.assign({}, this.raw), { Bruce: this.Bruce.JSON, position: this.position, HTMLDescription: this.HTMLDescription });
            if (this.location) {
                data.location = this.location.JSON;
            }
            else if (data.location) {
                delete data.location;
            }
            if (this.boundaries) {
                data.boundaries = this.boundaries.JSON;
            }
            else if (data.boundaries) {
                delete data.boundaries;
            }
            if (this.transform) {
                data.transform = this.transform.JSON;
            }
            else if (data.transform) {
                delete data.transform;
            }
            if (this.geometry) {
                data.geometry = this.geometry.JSON;
            }
            else if (data.geometry) {
                delete data.geometry;
            }
            data = object_utils_5.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns value from raw data by given key.
         * @Warning: Do not request properties that are defaults found in the class.
         * @param key
         */
        GetRawProperty(key) {
            return this.raw[key];
        }
        /**
         * Returns a cloned instance.
         * @param randomiseId: If a new random UID should be applied to the clone.
         */
        Clone(randomiseId = false) {
            let clone = new BruceInfo(this.JSON);
            if (randomiseId) {
                clone.Bruce.ID = object_utils_5.ObjectUtils.UID();
            }
            return clone;
        }
        /**
         * Adds entity layer to the entity. (Tags it).
         * Don't forget to call SaveUpdate().
         * @param layerId
         */
        addEntityLayer(layerId) {
            let layers = this.Bruce["Layer.ID"];
            layers.splice(layers.indexOf(layerId), 1);
            this.Bruce["Layer.ID"] = layers;
        }
        /**
         * Removes entity layer from the entity. (Removes a tag).
         * Don't forget to call SaveUpdate().
         * @param layerId
         */
        removeEntityLayer(layerId) {
            let layers = this.Bruce["Layer.ID"];
            let index = layers.indexOf(layerId);
            if (index < 0) {
                layers.push(layerId);
            }
            this.Bruce["Layer.ID"] = layers;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            // Let's start by applying arbitrary data.
            let defaults = ["Bruce", "location", "position", "boundaries", "transform", "geometry", "HTMLDescription"];
            let keys = Object.keys(rawData);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                if (!defaults.includes(key)) {
                    this._raw[key] = rawData[key];
                }
            }
            if (rawData.Bruce != null) {
                this.Bruce.Update(rawData.Bruce);
            }
            if (rawData.location != null) {
                this.location = new cartographic_1.Cartographic(rawData.location);
            }
            if (rawData.position != null) {
                this.position = rawData.position;
            }
            if (rawData.boundaries != null) {
                this.boundaries = new boundaries_1.Boundaries(rawData.boundaries);
            }
            if (rawData.transform != null) {
                this.transform = new transformation_1.Transformation(rawData.transform);
            }
            if (rawData.geometry != null) {
                this.geometry = BruceInfo.ParseGeometry(rawData.geometry);
            }
            if (rawData.HTMLDescription != null) {
                this.HTMLDescription = rawData.HTMLDescription;
            }
        }
        /**
         * Updates or creates bruce record.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let ET = this.Bruce["EntityType.ID"];
                    let ID = this.Bruce.ID;
                    let requestDataStr = JSON.stringify(this.JSON);
                    let requestURL = api.BRUCE_URL + "entity"
                        + (ID ? "/" + ID : "")
                        + "?dataoverride=true"
                        + (ET != null && ET != "" ? "&BruceEntityType=" + ET : "");
                    let data = yield api.post(requestURL, requestDataStr);
                    this.Update(data);
                    return this;
                }
                catch (e) {
                    console.log(">>Error: Failed to save entity record.");
                    console.log(this);
                    console.log(e);
                }
            });
        }
        /**
         * Deletes bruce record associated with this bruce info instance.
         * @param api
         */
        DeleteRecord(api) {
            return __awaiter(this, void 0, void 0, function* () {
                yield api.delete(api.BRUCE_URL + `entity/${this.Bruce.ID}`);
            });
        }
        /**
         * Checks the entity's entity type settings for any name attribute paths.
         * If end result is null it will return entity ID.
         * @param api
         */
        CalculateName(api) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                let entityTypeId = (_a = this.Bruce) === null || _a === void 0 ? void 0 : _a["EntityType.ID"];
                if (entityTypeId) {
                    try {
                        let entityType = yield entity_type_1.EntityType.GetByID(api, entityTypeId);
                        if (entityType) {
                            let namePaths = entityType.GetEntityNamePaths();
                            if (namePaths.length > 0) {
                                let JSON = this.JSON;
                                for (let i = 0; i < namePaths.length; i++) {
                                    let wrappedPath = namePaths[i];
                                    let path;
                                    if (bruce_path_utils_1.BrucePathUtils.GuessIsLegacyPath(wrappedPath)) {
                                        path = bruce_path_utils_1.BrucePathUtils.ParseLegacyPath(wrappedPath);
                                    }
                                    else {
                                        path = bruce_path_utils_1.BrucePathUtils.ParsePath(wrappedPath);
                                    }
                                    let name = object_utils_5.ObjectUtils.FindValue(JSON, path, null);
                                    if (name) {
                                        return name;
                                    }
                                }
                            }
                        }
                    }
                    catch (_c) {
                    }
                }
                return (_b = this.Bruce) === null || _b === void 0 ? void 0 : _b.ID;
            });
        }
        /**
         * Parses good / bad geometry data into geometry model.
         * @param geometry
         */
        static ParseGeometry(geometry) {
            if (typeof geometry == "string") {
                let positions = [];
                let geometryParsed = (geometry || "").split(";");
                for (let i = 0; i < geometryParsed.length; i++) {
                    let data = geometryParsed[i];
                    let points = geometry_1.Geometry.ParsePoints(data);
                    if (points && points.length > 0) {
                        positions = positions.concat(points);
                    }
                }
                // Remove duplicates that are "in a row".
                positions = geometry_1.Geometry.CleanCartographicPoints(positions);
                let newGeometry = new geometry_1.Geometry(null);
                if (positions.length > 0) {
                    let topPoint = positions[0];
                    newGeometry.Point = `${topPoint.latitude},${topPoint.longitude}` + (topPoint.altitude != null ? `,${topPoint.altitude}` : "");
                    if (positions.length > 1) {
                        newGeometry.Polygon = [geometry_1.Geometry.PolygonFromCartographicPoints(positions)];
                    }
                    if (positions.length > 2) {
                        newGeometry.LineString = geometry_1.Geometry.LineStringFromCartographicPoints(positions);
                    }
                }
                return newGeometry;
            }
            else if (geometry instanceof geometry_1.Geometry) {
                return geometry;
            }
            else {
                return new geometry_1.Geometry(geometry);
            }
        }
        /**
         * Return bruce record by bruce meta.
         * @param api
         * @param meta
         * @returns
         */
        static GetByMeta(api, meta) {
            return __awaiter(this, void 0, void 0, function* () {
                let entityId = meta.EntityID();
                let entityTypeId = meta.entityTypeId;
                let cache = api.entityCache.Get(entityId);
                if (cache) {
                    return cache;
                }
                try {
                    let data = yield api.get(api.BRUCE_URL + `entity/${entityId}` + (entityTypeId ? "?BruceEntityType=" + entityTypeId : ""));
                    if (data) {
                        let entity = new BruceInfo(data);
                        api.entityCache.Set(entityId, entity);
                        return entity;
                    }
                    return null;
                }
                catch (_a) {
                    console.log(">>Error: Failed to find entity record by id: " + entityId + ", entity type: " + entityTypeId);
                }
                return null;
            });
        }
        /**
         * Returns bruce record by entity id.
         * @param api
         * @param id
         */
        static GetById(api, id) {
            return __awaiter(this, void 0, void 0, function* () {
                let cache = api.entityCache.Get(id);
                if (cache) {
                    return cache;
                }
                try {
                    let data = yield api.get(api.BRUCE_URL + `entity/${id}`);
                    if (data) {
                        let entity = new BruceInfo(data);
                        api.entityCache.Set(id, entity);
                        return entity;
                    }
                    return null;
                }
                catch (_a) {
                    console.log(">>Error: Failed to find entity record by id: " + id);
                }
                return null;
            });
        }
        /**
         * Returns bruce records by id list.
         * @param api
         * @param ids
         */
        static GetList(api, ids) {
            return __awaiter(this, void 0, void 0, function* () {
                let result = [];
                let realRequestIds = [];
                ids.forEach(id => {
                    let cachedEntity = api.entityCache.Get(id);
                    if (cachedEntity) {
                        result.push(cachedEntity);
                    }
                    else {
                        realRequestIds.push(id);
                    }
                });
                if (realRequestIds.length > 0) {
                    try {
                        let request = {
                            Filter: {
                                ID: {
                                    in: realRequestIds
                                }
                            },
                            PageSize: realRequestIds.length
                        };
                        let data = yield api.post(api.BRUCE_URL + "entities", JSON.stringify(request));
                        let items = data === null || data === void 0 ? void 0 : data.Items;
                        items.forEach(element => {
                            let parsed = new BruceInfo(element);
                            api.entityCache.Set(element.Bruce.ID, parsed);
                            result.push(parsed);
                        });
                    }
                    catch (_a) {
                    }
                }
                return result;
            });
        }
        /**
         * Returns bruce records by filter.
         * @param api
         * @param filter
         * @returns
         */
        static GetListByFilter(api, filter) {
            return __awaiter(this, void 0, void 0, function* () {
                filter = filter || {};
                let requestFilter = {};
                if (filter.entityTypeConditions) {
                    requestFilter = Object.assign({}, filter.entityTypeConditions);
                }
                if (filter.layerIds != null) {
                    requestFilter["Bruce.Layer.ID"] =
                        {
                            equals: filter.layerIds.length == 0 ? null : filter.layerIds
                        };
                }
                if (filter.bounds) {
                    requestFilter["geometry"] =
                        {
                            "intersects": [
                                filter.bounds.south,
                                filter.bounds.north,
                                filter.bounds.west,
                                filter.bounds.east
                            ]
                        };
                }
                let URL = api.BRUCE_URL + "entities" +
                    // Page size and index.
                    `?PageSize=${filter.pageSize}&PageIndex=${filter.pageIndex}` +
                    // Entity type id.
                    (filter.entityTypeId ? `&BruceEntityType=${filter.entityTypeId}` : "") +
                    // Lod.
                    (filter.lodCategoryId ? "&LODType=" + filter.lodCategoryId : "") +
                    // Attribute filter.
                    (object_utils_5.ObjectUtils.isEmpty(requestFilter) ? "" : "&Filter=" + abstract_api_2.AbstractAPI.Encode(JSON.stringify(requestFilter))) +
                    // Sorting.
                    (object_utils_5.ObjectUtils.isEmpty(filter.orderBy) ? "" : "&OrderBy=" + abstract_api_2.AbstractAPI.Encode(JSON.stringify(filter.orderBy))) +
                    (filter.sortOrder ? `&SortOrder=${filter.sortOrder == sort_order_2.SortOrder.Asc ? "ASC" : "DESC"}` : "");
                let parsedBruceInfos = [];
                let data = yield api.get(URL);
                let rawBruceInfos = data.Items;
                for (let i = 0; i < rawBruceInfos.length; i++) {
                    let rawInfo = rawBruceInfos[i];
                    let parsed = new BruceInfo(rawInfo);
                    parsedBruceInfos.push(parsed);
                    // Cache individual entity.
                    api.entityCache.Set(parsed.Bruce.ID, parsed);
                }
                return parsedBruceInfos;
            });
        }
        /**
         * Generates a grid of entities from given polygon geometry.
         * @param api
         * @param entityTypeId where to put generated entities.
         * @param polygons
         * @param size in meter squared. Default is 0.1 which is 1 hectare. 0.1 = 100x100 m2.
         */
        static GenerateCellEntities(api, entityTypeId, polygons, size = 0.1) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let requestData = {
                        EntityTypeId: entityTypeId,
                        Items: polygons,
                        Size: size
                    };
                    let data = yield api.post(api.BRUCE_URL + "geography/polygonSplit", JSON.stringify(requestData));
                    if (data && data.EntityIDs) {
                        let split = data.EntityIDs.split(",");
                        let entityIds = [];
                        for (let i = 0; i < split.length; i++) {
                            let splitId = split[i];
                            entityIds.push(splitId.trim());
                        }
                        return entityIds;
                    }
                    else {
                        return [];
                    }
                }
                catch (e) {
                    console.log(">>Error: Failed to generate cell entities from polygon geometry.");
                    console.log(polygons);
                    console.log(e);
                }
            });
        }
        /**
        * Gets a list of entities (uses and updates cache).
        * @param entityIds
        */
        static GetEntitiesByList(api, entityIds) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
                    let result = [];
                    let realRequestIds = [];
                    entityIds.forEach(id => {
                        let cachedEntity = api.entityCache.Get(id);
                        if (cachedEntity) {
                            result.push(cachedEntity);
                        }
                        else {
                            realRequestIds.push(id);
                        }
                    });
                    if (realRequestIds.length > 0) {
                        try {
                            let request = {
                                Filter: {
                                    ID: {
                                        in: realRequestIds
                                    }
                                },
                                PageSize: realRequestIds.length
                            };
                            let data = yield api.post(api.BRUCE_URL + "entities", JSON.stringify(request));
                            let items = data === null || data === void 0 ? void 0 : data.Items;
                            items.forEach(element => {
                                let parsed = new BruceInfo(element);
                                api.entityCache.Set(element.Bruce.ID, parsed);
                                result.push(parsed);
                            });
                        }
                        catch (_a) {
                        }
                        res(result);
                    }
                    else {
                        res(result);
                    }
                }));
            });
        }
        /**
         * Returns a list of entities for a specific filter conditions
         */
        static GetEntitiesByFilter(api, filter) {
            return __awaiter(this, void 0, void 0, function* () {
                filter = filter || {};
                let requestFilter = {};
                if (filter.entityTypeConditions) {
                    requestFilter = Object.assign({}, filter.entityTypeConditions);
                }
                if (filter.layerIds != null && filter.layerIds.length > 0) {
                    requestFilter["Bruce.Layer.ID"] =
                        {
                            equals: filter.layerIds
                        };
                }
                if (filter.bounds) {
                    requestFilter["geometry"] =
                        {
                            "intersects": [
                                filter.bounds.south,
                                filter.bounds.north,
                                filter.bounds.west,
                                filter.bounds.east
                            ]
                        };
                }
                let URL = api.BRUCE_URL + "entities" +
                    // Page size and index.
                    `?PageSize=${filter.pageSize}&PageIndex=${filter.pageIndex}` +
                    // Entity type id.
                    (filter.entityTypeId ? `&BruceEntityType=${filter.entityTypeId}` : "") +
                    // Lod.
                    (filter.lodCategoryId ? "&LODType=" + filter.lodCategoryId : "") +
                    // Attribute filter.
                    (object_utils_5.ObjectUtils.isEmpty(requestFilter) ? "" : "&Filter=" + abstract_api_2.AbstractAPI.Encode(JSON.stringify(requestFilter))) +
                    // Sorting.
                    (object_utils_5.ObjectUtils.isEmpty(filter.orderBy) ? "" : "&OrderBy=" + abstract_api_2.AbstractAPI.Encode(JSON.stringify(filter.orderBy))) +
                    (filter.sortOrder ? `&SortOrder=${filter.sortOrder == sort_order_2.SortOrder.Asc ? "ASC" : "DESC"}` : "");
                let parsedBruceInfos = [];
                let data = yield api.get(URL);
                let rawBruceInfos = data.Items;
                for (let i = 0; i < rawBruceInfos.length; i++) {
                    let rawInfo = rawBruceInfos[i];
                    let parsed = new BruceInfo(rawInfo);
                    parsedBruceInfos.push(parsed);
                    // Cache individual entity.
                    api.entityCache.Set(parsed.Bruce.ID, parsed);
                }
                return parsedBruceInfos;
            });
        }
        /**
         * Returns list of entity ids corresponding to entity instance IDs from given array of entity ID paths.
         * @param entityIdPaths
         */
        static GetInstanceIDs(api, entityIdPaths) {
            return __awaiter(this, void 0, void 0, function* () {
                let instanceIds = [];
                let toCheck = [];
                for (let i = 0; i < entityIdPaths.length; i++) {
                    let path = entityIdPaths[i];
                    if (path.length <= 0) {
                        instanceIds[i] = "";
                    }
                    else if (path.length == 1) {
                        instanceIds[i] = path[0];
                    }
                    else {
                        let hashPath = bruce_meta_1.BruceMeta.HashPath(path);
                        let cacheData = api.instanceIdCache.Get(hashPath);
                        if (cacheData) {
                            instanceIds[i] = cacheData;
                        }
                        else {
                            toCheck.push(path);
                            instanceIds[i] = null;
                        }
                    }
                }
                if (toCheck.length > 0) {
                    let res = yield api.POST("entity/instance/list", JSON.stringify({
                        "EntityPaths": toCheck
                    }));
                    for (let i = 0; i < entityIdPaths.length; i++) {
                        let path = entityIdPaths[i];
                        let val = instanceIds[i];
                        if (val == null) {
                            val = res.EntityIDs.shift();
                            instanceIds[i] = val;
                            let hashPath = bruce_meta_1.BruceMeta.HashPath(path);
                            api.instanceIdCache.Set(hashPath, val);
                        }
                    }
                }
                return instanceIds;
            });
        }
        /**
         * Returns PendingAction which will be populated with entity instance IDs from given array of entity ID paths.
         * @param entityIdPaths
         */
        static GetInstanceIDsPA(api, entityIdPaths) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.POST("entity/instance/list/PA", JSON.stringify({
                    "EntityPaths": entityIdPaths
                }));
                if (data && data.PendingAction) {
                    return new pending_action_1.PendingAction(data.PendingAction);
                }
                return null;
            });
        }
        /**
         * Stacks entity polygons on top of each other and has them cut-out each other so none are intersecting.
         * This will return a new set of bruce info instances with the update geometries, not update the given ones.
         * @param api
         * @param entities
         */
        static DisjointEntities(api, entities) {
            return __awaiter(this, void 0, void 0, function* () {
                let reqData = {
                    Items: entities.map(x => x.JSON)
                };
                let res = yield api.post(api.BRUCE_URL + "geography/entityDisjoint", JSON.stringify(reqData));
                let infos = [];
                for (let i = 0; i < res.Items.length; i++) {
                    let info = new BruceInfo(res.Items[i]);
                    infos.push(info);
                }
                return infos;
            });
        }
        /**
         * Truncates given entities to a boundary.
         * @param api
         * @param entities
         * @param boundary
         */
        static TruncateEntities(api, entities, boundary) {
            return __awaiter(this, void 0, void 0, function* () {
                let requestData = {
                    MainArea: boundary.JSON,
                    Items: entities.map(x => x.JSON)
                };
                let data = yield api.post(api.BRUCE_URL + "geography/truncateToArea", JSON.stringify(requestData));
                return data.Items.map(x => new BruceInfo(x));
            });
        }
    }
    exports.BruceInfo = BruceInfo;
});
define("bruce-models/common/polygon", ["require", "exports", "utils/object-utils", "bruce-models/common/bruce-info", "bruce-models/common/cartographic", "bruce-models/common/geometry"], function (require, exports, object_utils_6, bruce_info_1, cartographic_2, geometry_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Polygon = exports.PolygonFacing = void 0;
    var PolygonFacing;
    (function (PolygonFacing) {
        // Inner ringes are used for holes.
        PolygonFacing["in"] = "in";
        PolygonFacing["out"] = "out";
    })(PolygonFacing = exports.PolygonFacing || (exports.PolygonFacing = {}));
    class Polygon {
        constructor(rawData) {
            this.Facing = PolygonFacing.out;
            // Height of the polygon if an outer ring.
            // -1 if not set.
            this.Height = -1;
            this.Update(rawData);
        }
        /**
         * Returns current state as raw JSON.
         */
        get JSON() {
            let data = {
                Facing: this.Facing,
                LinearRing: this.LinearRing,
                Height: this.Height
            };
            data.Height = +data.Height;
            if (!data.Height) {
                data.Height = 0;
            }
            // In raw data we exclude unset height.
            else if (data.Height < 0) {
                delete data.Height;
            }
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new Polygon(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.Facing != null) {
                this.Facing = rawData.Facing;
            }
            if (rawData.LinearRing != null) {
                this.LinearRing = rawData.LinearRing;
            }
            if (rawData.Height != null) {
                this.Height = rawData.Height;
            }
        }
        /**
         * Returns points defining the linear ring.
         */
        getParsedCartographicPositions() {
            return geometry_2.Geometry.ParsePoints(this.LinearRing);
        }
        /**
         * Returns an array of polygons from a given raw json.
         * @param rawData
         */
        static PolygonArrayFromRaw(rawData) {
            if (rawData.length != null) {
                let parsed = [];
                for (let i = 0; i < rawData.length; i++) {
                    let rawRow = rawData[i];
                    let parsedRow = new Polygon(rawRow);
                    parsed.push(parsedRow);
                }
                return parsed;
            }
            return [];
        }
        /**
         * Makes sure given polygon points are closed.
         */
        static Close(positions) {
            if (positions.length < 2) {
                return positions;
            }
            else {
                // So we dont affect the referenced object
                let tmp = [].concat(positions);
                // If the first and last points do not match, add first point to end
                let f = tmp[0];
                let l = tmp[tmp.length - 1];
                if (tmp.length > 2 && !cartographic_2.Cartographic.IsEqual(f, l)) {
                    tmp.push(tmp[0]);
                }
                return tmp;
            }
        }
        /**
         * Checks if there are outlier points to remove.
         * @param polygon
         */
        static Fix(polygon) {
            let tmp = polygon.map(x => x.JSON).map(y => new Polygon(y));
            for (let i = 0; i < tmp.length; i++) {
                let piece = tmp[i];
                let points = geometry_2.Geometry.ParsePoints(piece.LinearRing);
                // Arbitrary number because this seems to be a problem mostly with larger polygons.
                if (points.length > 5) {
                    let negLatDings = 0;
                    let negLonDings = 0;
                    for (let i = 0; i < points.length; i++) {
                        let point = points[i];
                        if (point.latitude < 0) {
                            negLatDings += 1;
                        }
                        if (point.longitude < 0) {
                            negLonDings += 1;
                        }
                    }
                    let percent = Math.floor(points.length / 100);
                    // If there are less than 1% of points in negative range.
                    // Remove negative lat points.
                    if (negLatDings <= percent) {
                        points = points.filter(x => x.latitude > 0);
                    }
                    // If there are 99% or more negative points.
                    // Remove positive lat points.
                    else if (negLatDings >= percent * 99) {
                        points = points.filter(x => x.latitude < 0);
                    }
                    // If there are less than 1% of points in negative range.
                    // Remove negative lon points.
                    if (negLonDings <= percent) {
                        points = points.filter(x => x.longitude > 0);
                    }
                    // If there are 99% or more negative points.
                    // Remove positive lon points.
                    else if (negLonDings >= percent * 99) {
                        points = points.filter(x => x.longitude < 0);
                    }
                }
                piece.LinearRing = geometry_2.Geometry.LineStringFromCartographicPoints(points);
            }
            return tmp;
        }
        /**
         * Truncates inner rings to outer ring.
         * @param api
         * @param polygon
         */
        static TruncateHoles(api, polygon) {
            return __awaiter(this, void 0, void 0, function* () {
                let holes = polygon.filter(x => x.Facing == PolygonFacing.in);
                if (holes.length <= 0) {
                    return polygon;
                }
                let outerRings = polygon.filter(x => x.Facing == PolygonFacing.out);
                if (outerRings.length > 1 || outerRings.length <= 0) {
                    return polygon;
                }
                let outerRing = outerRings[0];
                let boundary = new geometry_2.Geometry(null);
                boundary.Polygon = [new Polygon(outerRing.JSON)];
                let holeEntities = holes.map(x => new bruce_info_1.BruceInfo({ geometry: { Polygon: [x.JSON] } }));
                holeEntities.forEach((hole) => {
                    hole.Bruce.ID = object_utils_6.ObjectUtils.UID();
                    if (hole.geometry.Polygon.length > 0) {
                        hole.geometry.Polygon[0].Facing = PolygonFacing.out;
                    }
                });
                let newPolygon = [outerRing];
                let res = yield bruce_info_1.BruceInfo.TruncateEntities(api, holeEntities, boundary);
                for (let i = 0; i < res.length; i++) {
                    let entity = res[i];
                    let polygons = entity.geometry.Polygon;
                    for (let j = 0; j < polygons.length; j++) {
                        let polygon = entity.geometry.Polygon;
                        if (polygon.length > 0) {
                            for (let k = 0; k < polygon.length; k++) {
                                let ring = polygon[k];
                                ring.Facing = PolygonFacing.in;
                            }
                            newPolygon = newPolygon.concat(polygon);
                        }
                    }
                }
                return newPolygon;
            });
        }
    }
    exports.Polygon = Polygon;
});
define("bruce-models/common/geometry", ["require", "exports", "utils/math-utils", "utils/object-utils", "bruce-models/common/boundaries", "bruce-models/common/polygon"], function (require, exports, math_utils_1, object_utils_7, boundaries_2, polygon_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Geometry = void 0;
    class Geometry {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns if the geometry instance has any sort of valid geometry.
         */
        get hasGeometry() {
            if (this.Polygon && this.Polygon.length > 0) {
                return true;
            }
            else if (this.LineString && this.LineString.length > 0) {
                return true;
            }
            else if (this.Point && this.Point.length > 0) {
                return true;
            }
            else if (this.MultiSurface && this.MultiSurface.length > 0) {
                return true;
            }
            else if (this.MultiGeometry) {
                for (let i = 0; i < this.MultiGeometry.length; i++) {
                    let geo = this.MultiGeometry[i];
                    if (geo.hasGeometry) {
                        return true;
                    }
                }
            }
            return false;
        }
        /**
         * Returns current state as raw JSON.
         */
        get JSON() {
            let data = {};
            if (this.Point) {
                data.Point = this.Point;
            }
            else if (data.Point) {
                delete data.Point;
            }
            if (this.LineString) {
                data.LineString = this.LineString;
            }
            else if (data.LineString) {
                delete data.LineString;
            }
            if (this.MultiSurface && this.MultiSurface.length > 0) {
                data.MultiSurface = this.MultiSurface;
            }
            else if (data.MultiSurface) {
                delete data.MultiSurface;
            }
            let polygon = this.Polygon;
            if (polygon && polygon.length > 0) {
                data.Polygon = [];
                for (let i = 0; i < polygon.length; i++) {
                    let p = polygon[i];
                    data.Polygon.push(p.JSON);
                }
            }
            else if (data.Polygon) {
                delete data.Polygon;
            }
            let multiGeometry = this.MultiGeometry;
            if (multiGeometry && multiGeometry.length > 0) {
                data.MultiGeometry = [];
                for (let i = 0; i < multiGeometry.length; i++) {
                    let mg = multiGeometry[i];
                    data.MultiGeometry.push(mg.JSON);
                }
            }
            else if (data.MultiGeometry) {
                delete data.MultiGeometry;
            }
            return data;
        }
        /**
         * Empties out the instance to create new geometry.
         */
        Empty() {
            this.Polygon = null;
            this.MultiGeometry = null;
            this.MultiSurface = null;
            this.Point = null;
            this.LineString = null;
        }
        /**
        * Updates instance using given raw data.
        * @param rawData
        */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.Polygon != null) {
                this.Polygon = polygon_1.Polygon.PolygonArrayFromRaw(rawData.Polygon);
            }
            if (rawData.MultiGeometry != null) {
                this.MultiGeometry = Geometry.GeometryArrayFromRaw(rawData.MultiGeometry);
            }
            if (rawData.Point != null) {
                this.Point = rawData.Point;
            }
            if (rawData.LineString != null) {
                this.LineString = rawData.LineString;
            }
            if (rawData.MultiSurface != null) {
                this.MultiSurface = rawData.MultiSurface;
            }
        }
        /**
         * Calculates boundaries for the current geometry instance.
         * Returns null if no boundaries can be calculated.
         */
        CalculateBoundaries() {
            let boundaries = new boundaries_2.Boundaries(null);
            let point = this.Point;
            if (point) {
                let points = Geometry.ParsePoints(point);
                if (points) {
                    boundaries.IncludePoints(points);
                }
            }
            let polyline = this.LineString;
            if (polyline) {
                let points = Geometry.ParsePoints(polyline);
                if (points) {
                    boundaries.IncludePoints(points);
                }
            }
            let polygonBoxes = this.Polygon;
            let polygon = polygonBoxes ? polygonBoxes.find(x => x.Facing == polygon_1.PolygonFacing.out) : null;
            if (polygon && polygon.LinearRing) {
                let points = Geometry.ParsePoints(polygon.LinearRing);
                if (points) {
                    boundaries.IncludePoints(points);
                }
            }
            let multiGeometry = this.MultiGeometry;
            if (multiGeometry) {
                for (let i = 0; i < multiGeometry.length; i++) {
                    let geo = multiGeometry[i];
                    let geoBounds = geo.CalculateBoundaries();
                    if (geoBounds) {
                        boundaries.IncludeBoundaries(geoBounds);
                    }
                }
            }
            if (boundaries.isValid) {
                return boundaries;
            }
            else {
                return null;
            }
        }
        /**
         * Calculates center position of all geometry.
         * Returns null if no position can be calculated.
         */
        CalculatePosition() {
            let boundaries = this.CalculateBoundaries();
            if (boundaries === null || boundaries === void 0 ? void 0 : boundaries.isValid) {
                return boundaries.CalculateCenter();
            }
            else {
                return null;
            }
        }
        /**
         * Scans through multigeometry and top-layer geometry to try find single instance of polygon.
         * This is useful because an entity can have 1 polygon but it sits in multi-geometry.
         * @param returnNullOnMulti If null should be returned if multiple polygons are found. If false then will return last found case.
         */
        GetPolygon(returnNullOnMulti = true) {
            let polygon;
            let ticks = 0;
            if (this.Polygon && this.Polygon.length > 0) {
                polygon = this.Polygon;
                ticks += 1;
            }
            if (this.MultiGeometry && this.MultiGeometry.length > 0) {
                for (let i = 0; i < this.MultiGeometry.length; i++) {
                    let geo = this.MultiGeometry[i];
                    if (geo.Polygon && geo.Polygon.length > 0) {
                        polygon = geo.Polygon;
                        ticks += 1;
                    }
                }
            }
            return ticks > 1 && returnNullOnMulti == true ? null : ticks > 0 ? polygon : null;
        }
        /**
         * If polygon in top-layer isn't null, will return just that.
         * Otherwise it combines all polygons found in multi-geometry and returns them.
         */
        GetPolygons() {
            let polygon = [];
            if (this.Polygon && this.Polygon.length > 0) {
                polygon = [this.Polygon];
            }
            else if (this.MultiGeometry && this.MultiGeometry.length > 0) {
                for (let i = 0; i < this.MultiGeometry.length; i++) {
                    let geo = this.MultiGeometry[i];
                    if (geo.Polygon && geo.Polygon.length > 0) {
                        polygon.push(geo.Polygon);
                    }
                }
            }
            return polygon;
        }
        /**
         * Calculates area in meters squared of the current geometry instance.
         * On error will return null.
         * @param api
         */
        CalculateArea(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let geo = this.JSON;
                let reqData = {
                    Items: [geo]
                };
                let res = yield api.post(api.BRUCE_URL + "geography/calculateArea", JSON.stringify(reqData));
                if (res && res.Area && res.Area > -1) {
                    return res.Area;
                }
                return null;
            });
        }
        /**
         * Simplifies geometry.
         * @param api
         * @param allowedError in meters, higher number will simplify more.
         */
        Simplify(api, allowedError = 0.0001) {
            return __awaiter(this, void 0, void 0, function* () {
                let geo = this.JSON;
                let reqData = {
                    Item: geo,
                    Error: allowedError,
                    isAbsolute: false
                };
                let res = yield api.post(api.BRUCE_URL + "geography/smoothGeometry", JSON.stringify(reqData));
                if (res && res.Item) {
                    let updatedGeo = JSON.parse(res.Item);
                    if (updatedGeo) {
                        this.Update(updatedGeo);
                    }
                }
            });
        }
        /**
         * Returns an array of geometries from a given raw json.
         * @param rawData
         */
        static GeometryArrayFromRaw(rawData) {
            if (rawData.length == null) {
                rawData = [rawData];
            }
            if (rawData.length != null) {
                let parsed = [];
                for (let i = 0; i < rawData.length; i++) {
                    let rawRow = rawData[i];
                    let parsedRow = new Geometry(rawRow);
                    parsed.push(parsedRow);
                }
                return parsed;
            }
            return [];
        }
        /**
         * Merges given polygons that share boundaries.
         * If all polygons share boundaries then returned data should only have 1 polygon.
         * @param api
         * @param polygons
         * @param allowance: allowed distance between lines. Default is roughly 10cm.
         */
        static MergePolygons(api, polygons, allowance = 1e-6) {
            return __awaiter(this, void 0, void 0, function* () {
                let reqData = {
                    Items: []
                };
                for (let i = 0; i < polygons.length; i++) {
                    let polygon = polygons[i];
                    reqData.Items.push({
                        Polygon: polygon.map(x => x.JSON)
                    });
                }
                let url = `geography/polygonUnion?allowance=${allowance}`;
                let data = yield api.POST(url, JSON.stringify(reqData));
                if (data && data.Items) {
                    let geo = new Geometry(null);
                    if (data.Items.length == 1) {
                        geo = new Geometry(data.Items[0]);
                    }
                    else {
                        geo.MultiGeometry = [];
                        for (let i = 0; i < data.Items.length; i++) {
                            let geoPiece = data.Items[i];
                            geo.MultiGeometry.push(new Geometry(geoPiece));
                        }
                    }
                    return geo;
                }
                return new Geometry(null);
            });
        }
        /**
         * Stacks geometries on top of eachother and cuts any overlapping parts out of eachother.
         * Top geometry will remain uncut.
         * If a geometry was split into two disconnected pieces, then two geometries are returned.
         * If a geometry is fully cut to 0 size, no geometry is returned for that piece.
         * @param api
         * @param geometries
         */
        static DisjoinGeometries(api, geometries) {
            return __awaiter(this, void 0, void 0, function* () {
                let reqData = {
                    Items: geometries.map(x => x.JSON)
                };
                let data = yield api.post(api.BRUCE_URL + "geography/geometryDisjoint", JSON.stringify(reqData));
                if (data && data.Items) {
                    let newGeometries = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        let geometry = new Geometry(data.Items[i]);
                        newGeometries.push(geometry);
                    }
                    return newGeometries;
                }
                else {
                    return [];
                }
            });
        }
        /**
         * Returns polygon geometry from cartographic positions.
         * Please make sure points are in degrees.
         * @param points
         */
        static PolygonFromCartographicPoints(points) {
            let polygon = new polygon_1.Polygon(null);
            polygon.Facing = polygon_1.PolygonFacing.out;
            let carto = points[0];
            let ringString = `${carto.longitude},${carto.latitude}` + (carto.altitude != null ? `,${carto.altitude}` : "");
            for (let i = 1; i < points.length; i++) {
                carto = points[i];
                ringString += ` ${carto.longitude},${carto.latitude}` + (carto.altitude != null ? `,${carto.altitude}` : "");
            }
            polygon.LinearRing = ringString;
            return polygon;
        }
        /**
         * Returns line string geometry from given cartographic positions.
         * Please make sure points are in degrees.
         * @param points
         */
        static LineStringFromCartographicPoints(points) {
            let carto = points[0];
            let lineString = `${carto.longitude},${carto.latitude}` + (carto.altitude != null ? `,${carto.altitude}` : "");
            for (let i = 1; i < points.length; i++) {
                carto = points[i];
                lineString += ` ${carto.longitude},${carto.latitude}` + (carto.altitude != null ? `,${carto.altitude}` : "");
            }
            return lineString;
        }
        /**
         * Returns an array of positions without duplicate positions next to eachother.
         * Eg: [a, a, b, c] would return [a, b, c].
         * @param positions
         */
        static CleanCartesian3Points(positions) {
            let filteredList = [];
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                let lastPos = filteredList.length > 0 ? filteredList[filteredList.length - 1] : null;
                if (!lastPos || (pos.x != lastPos.x || pos.y != lastPos.y || pos.z != lastPos.z)) {
                    filteredList.push(pos);
                }
            }
            return filteredList;
        }
        /**
         * Returns an array of positions without duplicate positions next to eachother.
         * Eg: [a, a, b, c] would return [a, b, c].
         * @param positions
         */
        static CleanCartographicPoints(positions) {
            let filteredList = [];
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                let lastPos = filteredList.length > 0 ? filteredList[filteredList.length - 1] : null;
                if (!lastPos || (pos.latitude != lastPos.latitude || pos.longitude != lastPos.longitude || pos.altitude != lastPos.altitude)) {
                    filteredList.push(pos);
                }
            }
            return filteredList;
        }
        /**
         * Takes the string of points we recieve from the bruce JSON and turns it into cartographic positions.
         * TODO: actually make it disconnected rings and not connected ones.
         */
        static ParsePoints(source) {
            let result = [];
            // Clean string.
            //source = source.replace(/(\r\n|\n|\r|\)|\()/g, "");
            source = source.replace(/[^\d.,-\s]/g, "");
            //console.log(source);
            let splitterCoordinates = " ";
            let splitterAxis = ",";
            let commaIndex = source.indexOf(",");
            let spaceIndex = source.indexOf(" ");
            if ((spaceIndex > -1 && commaIndex > spaceIndex) || commaIndex <= -1) {
                splitterCoordinates = ",";
                splitterAxis = " ";
            }
            let points = source.trim().split(splitterCoordinates);
            points = points.filter(a => a != "");
            for (let i = 0; i < points.length; i++) {
                let pointData = points[i];
                let coords = pointData.trim().split(splitterAxis);
                if (coords.length == 2 || coords.length == 3) {
                    let longitude = object_utils_7.ObjectUtils.parseNum(coords[0]);
                    let latitude = object_utils_7.ObjectUtils.parseNum(coords[1]);
                    let altitude = coords.length >= 3 ? object_utils_7.ObjectUtils.parseNum(coords[2]) : 0;
                    if (longitude != null && latitude != null) {
                        result.push({
                            altitude: altitude,
                            latitude: latitude,
                            longitude: longitude
                        });
                    }
                    else {
                        // Bad points.
                    }
                }
            }
            return result;
        }
        /**
         * Returns clone of given positions with applied precision.
         * After applying precision it is recommended to run 'CleanCartographicPoints'.
         * @param positions
         * @param decimals
         */
        static SetPrecision(positions, decimals = 6) {
            let newPositions = [];
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                let newPos = {
                    altitude: null,
                    latitude: null,
                    longitude: null
                };
                if (pos.altitude) {
                    newPos.altitude = math_utils_1.MathUtils.Round(pos.altitude, decimals);
                }
                else {
                    newPos.altitude = 0;
                }
                newPos.latitude = math_utils_1.MathUtils.Round(pos.latitude, decimals);
                newPos.longitude = math_utils_1.MathUtils.Round(pos.longitude, decimals);
                newPositions.push(newPos);
            }
            return newPositions;
        }
    }
    exports.Geometry = Geometry;
});
define("bruce-models/common/line", ["require", "exports", "bruce-models/common/cartographic", "bruce-models/common/geometry"], function (require, exports, cartographic_3, geometry_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LineCarto = exports.Line2D = void 0;
    class Line2D {
        constructor(line) {
            this.start = line.start;
            this.end = line.end;
        }
        /**
         * Returns line instance from given points.
         * @param start
         * @param end
         * @returns
         */
        static LineFromPoints(start, end) {
            return new Line2D({ start: start, end: end });
        }
        /**
         * Returns line instance from given line cartographic.
         * @param lineCarto
         */
        static LineFromLineCarto(lineCarto) {
            let line = new Line2D({
                start: {
                    x: lineCarto.start.longitude,
                    y: lineCarto.start.latitude
                },
                end: {
                    x: lineCarto.end.longitude,
                    y: lineCarto.end.latitude
                }
            });
            return line;
        }
    }
    exports.Line2D = Line2D;
    class LineCarto {
        constructor(line) {
            this.start = line.start;
            this.end = line.end;
        }
        /**
         * Returns line instance from given points.
         * @param start
         * @param end
         * @returns
         */
        static LineFromPoints(start, end) {
            return new LineCarto({ start: start, end: end });
        }
        /**
         * Returns line instance from given points.
         * Will convert values to radians.
         * @param start
         * @param end
         * @returns
         */
        static LineFromDegreesPoints(start, end) {
            let line = new LineCarto({
                start: cartographic_3.Cartographic.toRadians(start),
                end: cartographic_3.Cartographic.toRadians(end)
            });
            return line;
        }
        /**
         * Returns a line from a given linearRing.
         * Warning: This function assumes linearRing is in Degrees so it converts points to Radians.
         * Warning: This will only use the first and last points of the linear ring as this is not a polyline.
         * @param linearRing
         */
        static LineFromLinearRing(linearRing) {
            let points = geometry_3.Geometry.ParsePoints(linearRing);
            if (points && points.length > 1) {
                let line = new LineCarto({
                    start: cartographic_3.Cartographic.toRadians(points[0]),
                    end: cartographic_3.Cartographic.toRadians(points[points.length - 1])
                });
                return line;
            }
            return null;
        }
    }
    exports.LineCarto = LineCarto;
});
define("utils/drawing-utils", ["require", "exports", "bruce-models/common/cartesian2"], function (require, exports, cartesian2_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DrawingUtils = void 0;
    class DrawingUtils {
        static GetGradientFromLine(line) {
            let p1 = line.start;
            let p2 = line.end;
            return (p2.y - p1.y) / (p2.x - p1.x);
        }
        static GetEquationFromLine(line) {
            let m = DrawingUtils.GetGradientFromLine(line);
            let c = (m * line.end.x - line.end.y) * -1;
            let equation = {
                c: c,
                m: m
            };
            return equation;
        }
        static GetPerpindicularEquationFromLineForPoint(line, point) {
            let m = -DrawingUtils.GetGradientFromLine(line);
            let c = (m * point.x - point.y) * -1;
            let equation = {
                c: c,
                m: m
            };
            return equation;
        }
        static GetLineIntersection(eq1, eq2) {
            let b1 = -1;
            let b2 = -1;
            let c1 = eq1.c;
            let c2 = eq2.c;
            let a1 = eq1.m;
            let a2 = eq2.m;
            let x = ((b1 * c2) - (b2 * c1)) / ((a1 * b2) - (a2 * b1));
            let y = ((a2 * c1) - (a1 * c2)) / ((a1 * b2) - (a2 * b1));
            return { x: x, y: y };
        }
        static GetClosestPointToLineOld(line, point) {
            let eq1 = DrawingUtils.GetEquationFromLine(line);
            let eq2 = DrawingUtils.GetPerpindicularEquationFromLineForPoint(line, point);
            let intersection = DrawingUtils.GetLineIntersection(eq1, eq2);
            if (DrawingUtils.IsPointOnLine(line, intersection)) {
                return intersection;
            }
            else {
                let dis1 = DrawingUtils.DistanceBetweenPoints(line.start, intersection);
                let dis2 = DrawingUtils.DistanceBetweenPoints(line.end, intersection);
                if (dis1 < dis2) {
                    return line.start;
                }
                else {
                    return line.end;
                }
            }
        }
        /**
         * Returns closest point on given line.
         * @param line
         * @param point
         * @returns
         */
        static GetClosestPointToLine(line, point) {
            return this.GetClosestPointToPolyline([line.start, line.end], point);
        }
        /**
         * Returns closest point on given polyline.
         * @Warning: Must provide at least 2 points.
         * @param linePoints
         * @param point
         */
        static GetClosestPointToPolyline(linePoints, point) {
            let minDist;
            let fTo;
            let x;
            let y;
            let i;
            let dist;
            if (linePoints.length > 1) {
                for (let n = 1; n < linePoints.length; n++) {
                    if (linePoints[n].x != linePoints[n - 1].x) {
                        let a = (linePoints[n].y - linePoints[n - 1].y) / (linePoints[n].x - linePoints[n - 1].x);
                        let b = linePoints[n].y - a * linePoints[n].x;
                        dist = Math.abs(a * point.x + b - point.y) / Math.sqrt(a * a + 1);
                    }
                    else {
                        dist = Math.abs(point.x - linePoints[n].x);
                    }
                    let rl2 = Math.pow(linePoints[n].y - linePoints[n - 1].y, 2) + Math.pow(linePoints[n].x - linePoints[n - 1].x, 2);
                    let ln2 = Math.pow(linePoints[n].y - point.y, 2) + Math.pow(linePoints[n].x - point.x, 2);
                    let lnm12 = Math.pow(linePoints[n - 1].y - point.y, 2) + Math.pow(linePoints[n - 1].x - point.x, 2);
                    let dist2 = Math.pow(dist, 2);
                    let calcrl2 = ln2 - dist2 + lnm12 - dist2;
                    if (calcrl2 > rl2) {
                        dist = Math.sqrt(Math.min(ln2, lnm12));
                    }
                    if ((minDist == null) || (minDist > dist)) {
                        if (calcrl2 > rl2) {
                            if (lnm12 < ln2) {
                                fTo = 0;
                            }
                            else {
                                fTo = 1;
                            }
                        }
                        else {
                            fTo = ((Math.sqrt(lnm12 - dist2)) / Math.sqrt(rl2));
                        }
                        minDist = dist;
                        i = n;
                    }
                }
                let dx = linePoints[i - 1].x - linePoints[i].x;
                let dy = linePoints[i - 1].y - linePoints[i].y;
                x = linePoints[i - 1].x - (dx * fTo);
                y = linePoints[i - 1].y - (dy * fTo);
            }
            return { x: x, y: y };
        }
        static GetLineBearingInDegrees(line) {
            let start = line.start;
            let end = line.end;
            let y = Math.sin(end.x - start.x) * Math.cos(end.y);
            let x = Math.cos(start.y) * Math.sin(end.y) - Math.sin(start.y) * Math.cos(end.y) * Math.cos(end.x - start.x);
            let brng = Math.atan2(y, x);
            let brngDgr = DrawingUtils.RadToDeg(brng);
            brngDgr = (brngDgr + 360) % 360;
            return brngDgr;
        }
        static RadToDeg(radians) {
            let pi = Math.PI;
            return radians * (180 / pi);
        }
        static DegToRad(degrees) {
            let pi = Math.PI;
            return degrees * (pi / 180);
        }
        static IsPointOnLine(line, point) {
            let bounds = DrawingUtils.GetLineBounds(line);
            if (point.x < bounds.minX || point.x > bounds.maxX) {
                return false;
            }
            else if (point.y < bounds.minY || point.y > bounds.maxY) {
                return false;
            }
            return true;
        }
        static GetLineBounds(line) {
            let bounds = {
                maxX: line.start.x,
                maxY: line.start.y,
                minX: line.start.x,
                minY: line.start.y
            };
            if (line.end.x > bounds.maxX) {
                bounds.maxX = line.end.x;
            }
            if (line.end.x < bounds.minX) {
                bounds.minX = line.end.x;
            }
            if (line.end.y > bounds.maxY) {
                bounds.maxY = line.end.y;
            }
            if (line.end.y < bounds.minY) {
                bounds.minY = line.end.y;
            }
            return bounds;
        }
        static DistanceBetweenPoints(point1, point2) {
            return Math.sqrt(Math.pow(point2.x - point1.x, 2) + Math.pow(point2.y - point1.y, 2));
        }
        static GetIfLinesIntersect(line1, line2) {
            let getDirection = (a, b, c) => {
                let val = (b.y - a.y) * (c.x - b.x) - (b.x - a.x) * (c.y - b.y);
                // Colinear.
                if (val == 0) {
                    return 0;
                }
                // Anti-clockwise.
                else if (val < 0) {
                    return 2;
                }
                // Clockwise.
                return 1;
            };
            let dir1 = getDirection(line1.start, line1.end, line2.start);
            let dir2 = getDirection(line1.start, line1.end, line2.end);
            let dir3 = getDirection(line2.start, line2.end, line1.start);
            let dir4 = getDirection(line2.start, line2.end, line1.end);
            // They are intersecting.
            if (dir1 != dir2 && dir3 != dir4) {
                return true;
            }
            // When end of line2 is on the line1.
            if (dir1 == 0 && DrawingUtils.IsPointOnLine(line1, line2.end)) {
                return true;
            }
            // When start of line2 is on the line1.
            if (dir2 == 0 && DrawingUtils.IsPointOnLine(line1, line2.start)) {
                return true;
            }
            // When end of line1 is on the line2.
            if (dir3 == 0 && DrawingUtils.IsPointOnLine(line2, line1.end)) {
                return true;
            }
            // When start of line1 is on the line2.
            if (dir4 == 0 && DrawingUtils.IsPointOnLine(line2, line1.start)) {
                return true;
            }
            return false;
        }
        /**
         * Uses Chaikin's algorithm to smooth a given line of points.
         * Running this smooth will double the total points.
         * Run multiple times to keep smoothing the line.
         *
         * @Warning: Must have at least 3 points to smooth.
         * @param points
         * @param isRing: if this is a ring rather than a line of points.
         */
        static ChaikinSmooth(points, isRing = false) {
            let isClosed = isRing ? cartesian2_1.Cartesian2.IsClosedRing(points) : false;
            if (isClosed) {
                points.pop();
            }
            let inputs = [];
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                inputs.push([point.x, point.y]);
            }
            let output = [];
            if (isRing) {
                for (let i = 0; i < inputs.length; i++) {
                    let p0 = inputs[i];
                    let p1 = inputs[i + 1];
                    if (p1 == null) {
                        p1 = inputs[0];
                    }
                    let p0x = p0[0];
                    let p0y = p0[1];
                    let p1x = p1[0];
                    let p1y = p1[1];
                    let Q = [0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y];
                    let R = [0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y];
                    output.push(Q);
                    output.push(R);
                }
            }
            else {
                if (inputs.length > 0) {
                    output.push([inputs[0][0], inputs[0][1]]);
                }
                for (let i = 0; i < inputs.length - 1; i++) {
                    let p0 = inputs[i];
                    let p1 = inputs[i + 1];
                    let p0x = p0[0];
                    let p0y = p0[1];
                    let p1x = p1[0];
                    let p1y = p1[1];
                    let Q = [0.75 * p0x + 0.25 * p1x, 0.75 * p0y + 0.25 * p1y];
                    let R = [0.25 * p0x + 0.75 * p1x, 0.25 * p0y + 0.75 * p1y];
                    output.push(Q);
                    output.push(R);
                }
                if (inputs.length > 1) {
                    output.push([inputs[inputs.length - 1][0], inputs[inputs.length - 1][1]]);
                }
            }
            let newPoints = [];
            for (let i = 0; i < output.length; i++) {
                let point = {
                    x: output[i][0],
                    y: output[i][1]
                };
                newPoints.push(point);
            }
            return newPoints;
        }
    }
    exports.DrawingUtils = DrawingUtils;
});
define("bruce-models/common/units", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EUnit = exports.EPosUnit = void 0;
    var EPosUnit;
    (function (EPosUnit) {
        EPosUnit["Degrees"] = "DEGREES";
        EPosUnit["Radians"] = "RADIANS";
    })(EPosUnit = exports.EPosUnit || (exports.EPosUnit = {}));
    var EUnit;
    (function (EUnit) {
        EUnit["Metric"] = "METRIC";
        EUnit["Imperial"] = "IMPERIAL";
    })(EUnit = exports.EUnit || (exports.EUnit = {}));
});
define("bruce-models/common/cartographic", ["require", "exports", "utils/drawing-utils", "bruce-models/common/units"], function (require, exports, drawing_utils_1, units_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Cartographic = void 0;
    class Cartographic {
        constructor(rawData) {
            this.units = units_1.EPosUnit.Degrees;
            this.altitude = 0;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                units: this.units,
                latitude: this.latitude,
                longitude: this.longitude,
                altitude: this.altitude
            };
            return data;
        }
        /**
         * (Override)
         * @returns cartographic as long,lat,alt string.
         */
        toString() {
            return `${this.longitude},${this.latitude},${this.altitude}`;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new Cartographic(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.units != null) {
                this.units = rawData.units;
            }
            if (rawData.longitude != null) {
                this.longitude = rawData.longitude;
            }
            if (rawData.latitude != null) {
                this.latitude = rawData.latitude;
            }
            if (rawData.altitude != null) {
                this.altitude = rawData.altitude;
            }
        }
        /**
         * Returns if a given position is equal to the current one.
         * @param pos
         */
        isEqual(pos) {
            return Cartographic.IsEqual(this, pos);
        }
        /**
         * Returns new instance of cartographic with converted units.
         * If given units are already the same then no conversion is done.
         * @param units
         */
        toUnit(units) {
            let clone = this.Clone();
            if (units != this.units) {
                if (units == units_1.EPosUnit.Radians) {
                    clone.longitude = drawing_utils_1.DrawingUtils.DegToRad(clone.longitude);
                    clone.latitude = drawing_utils_1.DrawingUtils.DegToRad(clone.latitude);
                }
                else if (units == units_1.EPosUnit.Degrees) {
                    clone.longitude = drawing_utils_1.DrawingUtils.RadToDeg(clone.longitude);
                    clone.latitude = drawing_utils_1.DrawingUtils.RadToDeg(clone.latitude);
                }
            }
            clone.units = units;
            return clone;
        }
        /**
         * Returns if the current position is valid.
         * @returns: true = valid, false = invalid.
         */
        isValid() {
            return Cartographic.Validate(this);
        }
        /**
         * Returns position as 2d dot.
         * Point is x,y as radian lon,lat.
         */
        getPoint() {
            let x;
            let y;
            if (this.units == units_1.EPosUnit.Degrees) {
                let clone = this.Clone();
                clone = clone.toUnit(units_1.EPosUnit.Radians);
                x = clone.longitude;
                y = clone.latitude;
            }
            else {
                x = this.longitude;
                y = this.latitude;
            }
            let dot = {
                x: x,
                y: y
            };
            return dot;
        }
        /**
         * Returns if two given cartographic positions are equal.
         * @param pos1
         * @param pos2
         */
        static IsEqual(pos1, pos2) {
            return pos1.altitude == pos2.altitude && pos1.latitude == pos2.latitude && pos1.longitude == pos2.longitude;
        }
        /**
         * @deprecated: please use ToUnit.
         */
        static toRadians(carto) {
            let tmp = {
                altitude: carto.altitude,
                latitude: drawing_utils_1.DrawingUtils.DegToRad(carto.latitude),
                longitude: drawing_utils_1.DrawingUtils.DegToRad(carto.longitude),
                units: units_1.EPosUnit.Radians
            };
            return tmp;
        }
        /**
         * @deprecated: please use ToUnit.
         */
        static toDegrees(carto) {
            let tmp = {
                altitude: carto.altitude,
                latitude: drawing_utils_1.DrawingUtils.RadToDeg(carto.latitude),
                longitude: drawing_utils_1.DrawingUtils.RadToDeg(carto.longitude),
                units: units_1.EPosUnit.Degrees
            };
            return tmp;
        }
        /**
         * Returns new instance of cartographic with converted units.
         * Warning: If given units are already the same then no conversion is done.
         * Warning: Null units in given carto assumes degrees.
         * @param units
         */
        static ToUnit(units, carto) {
            if (!carto.units) {
                carto.units = units_1.EPosUnit.Degrees;
            }
            let newCarto = {
                altitude: carto.altitude,
                latitude: carto.latitude,
                longitude: carto.longitude,
                units: carto.units
            };
            if (units != carto.units) {
                if (units == units_1.EPosUnit.Radians) {
                    newCarto.longitude = drawing_utils_1.DrawingUtils.DegToRad(newCarto.longitude);
                    newCarto.latitude = drawing_utils_1.DrawingUtils.DegToRad(newCarto.latitude);
                }
                else if (units == units_1.EPosUnit.Degrees) {
                    newCarto.longitude = drawing_utils_1.DrawingUtils.RadToDeg(newCarto.longitude);
                    newCarto.latitude = drawing_utils_1.DrawingUtils.RadToDeg(newCarto.latitude);
                }
            }
            newCarto.units = units;
            return newCarto;
        }
        /**
         * Converts given positions into a Desmos calculator polygon.
         * Warning: If position units are degrees they will be converted to radians.
         * @param cartos
         */
        static toDesmosPolygonString(cartos) {
            let text = "polygon(";
            for (let i = 0; i < cartos.length; i++) {
                let carto = cartos[i];
                if (carto.units != units_1.EPosUnit.Radians) {
                    carto = Cartographic.toRadians(carto);
                }
                text += `(${carto.longitude},${carto.latitude})`;
                if (i < cartos.length - 1) {
                    text += ",";
                }
            }
            text += ")";
            return text;
        }
        /**
         * Uses Chaikin's algorithm to smooth a given line of points.
         * Running this smooth will double the total points.
         * Run multiple times to keep smoothing the line.
         *
         * @Warning: Must have at least 3 points to smooth.
         * @Warning: Heights values will be lost.
         * @param cartos
         */
        static ChaikinSmooth(cartos) {
            let points = cartos.map(x => x.getPoint());
            points = drawing_utils_1.DrawingUtils.ChaikinSmooth(points);
            let newCartos = [];
            for (let i = 0; i < points.length; i++) {
                let point = points[i];
                let carto = new Cartographic({
                    altitude: 0,
                    latitude: point.y,
                    longitude: point.x,
                    units: units_1.EPosUnit.Radians
                });
                newCartos.push(carto);
            }
            return newCartos;
        }
        /**
         * Validates if a given position doesn't have null values.
         * No altitude is allowed.
         * @param carto
         * @returns: true = valid, false = invalid.
         */
        static Validate(carto) {
            if (!carto) {
                return false;
            }
            else if (!carto.longitude && carto.longitude != 0) {
                return false;
            }
            else if (!carto.latitude && carto.latitude != 0) {
                return false;
            }
            return true;
        }
        /**
         * Returns if given ring is closed.
         * @param positions
         */
        static IsClosedRing(positions) {
            if (positions.length < 2) {
                return true;
            }
            let p1 = positions[0];
            let p2 = positions[positions.length - 1];
            return p1.longitude == p2.longitude && p1.latitude == p2.latitude;
        }
    }
    exports.Cartographic = Cartographic;
});
define("utils/object-utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ObjectUtils = void 0;
    class ObjectUtils {
        /**
         * Generates a UID and returns it.
         */
        static UID() {
            return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
                let r = Math.random() * 16 | 0, v = c == "x" ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        /**
         * Generates a tagged UID and returns it.
         * @param tag The tag to prefix with.
         * @param limit The length of the UID (including tag length).
         */
        static TaggedUID(tag, limit = 50) {
            let tmp = "x".repeat(limit - tag.length - 1);
            tmp = tag + tmp.replace(/[xy]/g, function (c) {
                let r = Math.random() * 16 | 0;
                let v = c == "x" ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
            if (tmp.length > limit) {
                return tmp.slice(0, limit);
            }
            else {
                return tmp;
            }
        }
        /**
         * Generates a tagged UID and returns it.
         * @param tag The tag to prefix with.
         * @param limit The length of the UID (including tag length).
         * @deprecated Please use 'TaggedUID'.
         */
        static taggedUID(tag, limit = 50) {
            return ObjectUtils.TaggedUID(tag, limit);
        }
        /**
         * Returns if a given arbitrary object is "empty" or not.
         * @param object
         */
        static isEmpty(object) {
            if (object == null) {
                return true;
            }
            if (Array.isArray(object)) {
                return !object.length;
            }
            for (let key in object) {
                return false;
            }
            return true;
        }
        /**
         *
         * @param value
         * @param defaultValue
         */
        static nvl(value, defaultValue) {
            return value == null ? defaultValue : value;
        }
        /**
         * Evaluates given value and if it's empty then returns default, otherwise returns value.
         * @param value
         * @param defaultValue
         */
        static evl(value, defaultValue) {
            return ObjectUtils.isEmpty(value) ? defaultValue : value;
        }
        /**
         * Tries to parse given number or string into float.
         * @param value
         */
        static parseNum(value) {
            let result = parseFloat(value);
            return result == null || isNaN(result) ? null : result;
        }
        /**
         *
         * @param key
         * @param source
         */
        static getValue(key, source) {
            if (!key || !source) {
                return null;
            }
            let path = [key];
            let name = null;
            while (!name) {
                name = ObjectUtils.FindValue(source, path);
                if (!name) {
                    let curEnd = path.pop();
                    let index = curEnd.indexOf(".");
                    if (index > 0) {
                        let newEnd = curEnd.slice(index + 1);
                        let newPiece = curEnd.slice(0, index);
                        path.push(newPiece);
                        path.push(newEnd);
                    }
                    else {
                        break;
                    }
                }
            }
            return name;
        }
        /**
         * Locates value within obj using given path
         * Usecase example: ObjectUtils.FindValue(info, ["entity", "iBruceInfo", "Bruce", "CreatedTime"]);
         * @param obj
         * @param path
         * @param defaultValue What value to return when value doesn't exist
         */
        static FindValue(obj, orgPath, defaultValue = null) {
            if (!orgPath) {
                orgPath = [];
            }
            let path = JSON.parse(JSON.stringify(orgPath));
            let checkValue = (obj, path) => {
                if (obj != null && path.length > 0) {
                    let curPath = path[0];
                    // Remove quotations
                    if (curPath.startsWith("\"")) {
                        curPath = curPath.substr(1);
                    }
                    if (curPath.endsWith("\"")) {
                        curPath = curPath.substr(0, curPath.length - 1);
                    }
                    if (obj[curPath] != null) {
                        if (path.length > 1) {
                            obj = obj[curPath];
                            path.splice(0, 1);
                            return checkValue(obj, path);
                        }
                        else {
                            return obj[curPath];
                        }
                    }
                    else {
                        return null;
                    }
                }
                else {
                    return null;
                }
            };
            let value = checkValue(obj, path);
            if (value == null) {
                return defaultValue;
            }
            else {
                return value;
            }
        }
        /**
         * Updates a value in an object at a given path.
         * @param obj
         * @param orgPath
         * @param value
         */
        static UpdateValue(obj, orgPath, value) {
            if (!orgPath) {
                orgPath = [];
            }
            let path = JSON.parse(JSON.stringify(orgPath));
            let dig = (obj, path) => {
                if (obj != null && path.length > 0) {
                    let curPath = path[0];
                    // Remove quotations
                    if (curPath.startsWith("\"")) {
                        curPath = curPath.substr(1);
                    }
                    if (curPath.endsWith("\"")) {
                        curPath = curPath.substr(0, curPath.length - 1);
                    }
                    if (obj[curPath] == null) {
                        obj[curPath] = {};
                    }
                    if (path.length > 1) {
                        obj = obj[curPath];
                        path.splice(0, 1);
                        return dig(obj, path);
                    }
                    else {
                        obj[curPath] = value;
                    }
                }
                else {
                    return null;
                }
            };
            dig(obj, path);
        }
        /**
         * makes abc.deff into ${abc.def}
         * @param attribute
         */
        static WrapAtributePathInBashLikeVariable(attribute) {
            let retVal = "${" + attribute + "}";
            return retVal;
        }
        /**
         * makes  ${abc.def} into abc.deff
         * in case its just abc.deff it will keep it the same
         * @param attribute
         */
        static UnWrapAtributePathInBashLikeVariable(attribute) {
            const exp = /\${.*}/;
            let retVal = attribute;
            if (attribute.match(exp)) {
                let clean = attribute.match(exp)[0];
                retVal = clean.substr(2, clean.length - 3);
            }
            return retVal;
        }
        /**
         * Takes the string of points we recieve from the bruce JSON and turns it into cartographic positions.
         * TODO: actually make it disconnected rings and not connected ones.
         * @deprecated Please use methods inside of Geometry model.
         */
        static ParsePoints(source) {
            let result = [];
            // Clean string.
            source = source.replace(/(\r\n|\n|\r|\)|\()/g, "");
            let splitterCoordinates = " ";
            let splitterAxis = ",";
            let commaIndex = source.indexOf(",");
            let spaceIndex = source.indexOf(" ");
            if ((spaceIndex > -1 && commaIndex > spaceIndex) || commaIndex <= -1) {
                splitterCoordinates = ",";
                splitterAxis = " ";
            }
            let points = source.trim().split(splitterCoordinates);
            points = points.filter(a => a != "");
            for (let i = 0; i < points.length; i++) {
                let pointData = points[i];
                let coords = pointData.trim().split(splitterAxis);
                if (coords.length == 2 || coords.length == 3) {
                    let longitude = ObjectUtils.parseNum(coords[0]);
                    let latitude = ObjectUtils.parseNum(coords[1]);
                    let altitude = coords.length >= 3 ? ObjectUtils.parseNum(coords[2]) : 0;
                    if (longitude != null && latitude != null) {
                        result.push({
                            altitude: altitude,
                            latitude: latitude,
                            longitude: longitude
                        });
                    }
                    else {
                        // Bad points.
                    }
                }
                else if (result.length % 3 == 0) {
                    for (let i = 0; i < coords.length; i += 3) {
                        result.push({
                            altitude: parseFloat(coords[0]),
                            latitude: parseFloat(coords[1]),
                            longitude: parseFloat(coords[2])
                        });
                    }
                }
            }
            return result;
        }
        /**
         * Returns an array of positions without duplicate positions next to eachother.
         * Eg: [a, a, b, c] would return [a, b, c].
         * @deprecated Please use methods in Geomtry model.
         * @param positions
         */
        static CleanPolylinePoints(positions) {
            let filteredList = [];
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                let lastPos = filteredList.length > 0 ? filteredList[filteredList.length - 1] : null;
                if (!lastPos || (pos.x != lastPos.x || pos.y != lastPos.y || pos.z != lastPos.z)) {
                    filteredList.push(pos);
                }
            }
            return filteredList;
        }
        /**
         * Runs stringify -> parse on given data.
         * @param data
         * @param suppressCrash true to return original data on crash and not throw error.
         */
        static Dereference(data, suppressCrash = false) {
            try {
                return JSON.parse(JSON.stringify(data));
            }
            catch (e) {
                if (suppressCrash === true) {
                    return data;
                }
                else {
                    throw (e);
                }
            }
        }
        /**
         * Loops through keys of given object and checks if top level values are "bad".
         * Bad values are deleted from object.
         * Bad values are: undefined, empty string, null, NaN and any specified inclusions.
         * Inclusions take priority over exclusions.
         * Does not work on arrays. Will return array as is if an array is passed in as the data.
         * WARNING: Running this will affect original passed data. This does not deference first.
         * @param data
         * @param inclusions what things should count as bad data and be removed.
         * @param exclusions what things should not count as bad data to avoid being removed.
         * @returns
         */
        static CleanData(data, inclusions = [], exclusions = []) {
            if (Array.isArray(data)) {
                return data;
            }
            if (!exclusions) {
                exclusions = [];
            }
            if (!inclusions) {
                inclusions = [];
            }
            let keys = Object.keys(data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                let innerData = data[key];
                if (inclusions.includes(innerData)) {
                    delete data[key];
                }
                else if (!innerData && (typeof innerData == "string" || innerData != 0) && !exclusions.includes(innerData)) {
                    delete data[key];
                }
            }
            return data;
        }
        /**
         * Returns object keys for given data excluding keys matching provided regex exclusion.
         * Default exclusion is "^_|^raw$" which matches for keys starting with "_" or if the key is equal to "raw". Null this to not exclude anything.
         * @param data
         * @param regexExclusion what keys should be excluded when looping through data.
         */
        static GetDataKeys(data, regexExclusion = "^_|^raw$") {
            let keys = Object.keys(data);
            if (regexExclusion) {
                let filtered = [];
                for (let i = 0; i < keys.length; i++) {
                    let key = keys[i];
                    let match = key.match(regexExclusion);
                    if (!match || match.length <= 0) {
                        filtered.push(key);
                    }
                }
                return filtered;
            }
            return keys;
        }
        /**
         * Updates data using data in updater.
         * Default exclusion is "^_|^raw$" which matches for keys starting with "_" or if the key is equal to "raw". Null this to not exclude anything.
         * WARNING: this method will apply null values or other empty values. Run CleanData method first on updater if this is not what you want.
         * @param data
         * @param updater
         * @param regexExclusion what keys should be excluded when looping through updater.
         */
        static UpdateData(data, updater, regexExclusion = "^_|^raw$") {
            let keys;
            if (regexExclusion) {
                keys = ObjectUtils.GetDataKeys(data, regexExclusion);
            }
            else {
                keys = Object.keys(data);
            }
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                data[key] = updater[key];
            }
            return data;
        }
    }
    exports.ObjectUtils = ObjectUtils;
});
define("bruce-models/session/idm-session-access-permissions", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_8) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IDMSessionAccessPermissions = void 0;
    class IDMSessionAccessPermissions {
        constructor(rawData) {
            // List of enabled permissions.
            this.EnabledFeatures = [];
            // List of user groups associated with this permissions list.
            this.UserGroups = [];
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns raw data for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = Object.assign(Object.assign({}, this.raw), { EnabledFeatures: this.EnabledFeatures, UserGroups: this.UserGroups });
            data = object_utils_8.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new IDMSessionAccessPermissions(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.EnabledFeatures != null) {
                this.EnabledFeatures = rawData.EnabledFeatures;
            }
            if (rawData.UserGroups != null) {
                this.UserGroups = rawData.UserGroups;
            }
        }
        /**
         * Returns if given permission is enabled.
         * This is a case insensitive check.
         * @param perm
         */
        isEnabled(perm) {
            perm = perm ? perm.toLocaleUpperCase() : "";
            return this.EnabledFeatures.findIndex(x => x.toLocaleUpperCase() == perm) > -1;
        }
    }
    exports.IDMSessionAccessPermissions = IDMSessionAccessPermissions;
});
define("bruce-models/session/user-application-settings", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserApplicationSettings = void 0;
    class UserApplicationSettings {
        constructor(rawData) {
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = Object.assign(Object.assign({}, this.raw), { UserID: this.UserID, ClientAccountID: this.ClientAccountID, Application: this.Application, Settings: this.Settings });
            data = object_utils_9.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new UserApplicationSettings(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.UserID != null) {
                this.UserID = rawData.UserID;
            }
            if (rawData.ClientAccountID != null) {
                this.ClientAccountID = rawData.ClientAccountID;
            }
            if (rawData.Application != null) {
                this.Application = rawData.Application;
            }
            if (rawData.Settings != null) {
                this.Settings = rawData.Settings;
            }
        }
        /**
         * Updates or creates record.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.Application) {
                    throw ("Failed to save application settings. 'Application' is required.");
                }
                let data = yield api.POST(`user/${this.UserID}/application/${this.Application}/settings`, JSON.stringify(this.JSON));
                if (data) {
                    this.Update(data);
                }
                return this;
            });
        }
        /**
         * @param api
         * @param userId
         * @param application
         * @returns: application settings for user by application.
         */
        static GetByApplication(api, userId, application) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield api.GET(`user/${userId}/application/${application}/settings`);
                    if (data) {
                        return new UserApplicationSettings(data);
                    }
                }
                catch (e) {
                    console.log(`>>Error: Failed to get application settings by id: ${application} for user: ${userId}.`);
                    console.log(e);
                }
                return null;
            });
        }
    }
    exports.UserApplicationSettings = UserApplicationSettings;
});
define("bruce-models/session/idm-session", ["require", "exports", "bruce-models/common/utc", "bruce-models/session/idm-session-access-permissions", "bruce-models/session/user-application-settings"], function (require, exports, utc_5, idm_session_access_permissions_1, user_application_settings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IDMSession = void 0;
    class IDMSession {
        constructor(rawData) {
            this._raw = rawData;
            // Make empty defaults so permissions always can exist.
            this._accessPermissions = new idm_session_access_permissions_1.IDMSessionAccessPermissions(null);
            this._hypeportalAccessPermissions = new idm_session_access_permissions_1.IDMSessionAccessPermissions(null);
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        get AccessPermissions() {
            return this._accessPermissions;
        }
        get HypeportalAccessPermissions() {
            return this._hypeportalAccessPermissions;
        }
        /**
         * Updates instance of IDM Session using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.User != null) {
                this.User = rawData.User;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.IP != null) {
                this.IP = rawData.IP;
            }
            if (rawData.AccessPermissions != null) {
                this._accessPermissions = new idm_session_access_permissions_1.IDMSessionAccessPermissions(rawData.AccessPermissions);
            }
            if (rawData.HypeportalAccessPermisssions != null) {
                this._hypeportalAccessPermissions = new idm_session_access_permissions_1.IDMSessionAccessPermissions(rawData.HypeportalAccessPermisssions);
            }
            if (rawData["ClientAccount.ID"] != null) {
                this["ClientAccount.ID"] = rawData["ClientAccount.ID"];
            }
            if (rawData.LastAccessTime != null) {
                this.LastAccessTime = new utc_5.UTC(rawData.LastAccessTime);
            }
        }
        /**
         * Returns if the current session is anonymous.
         */
        isAnonymous() {
            var _a;
            return !this.ID || ((_a = this.User) === null || _a === void 0 ? void 0 : _a.ID) == "anonymous";
        }
        /**
         * Returns if given permission is enabled.
         * This is a case insensitive check.
         * @param perm
         */
        isPermissionEnabled(perm) {
            let isSuperAdmin = this.HypeportalAccessPermissions.isEnabled("admin");
            if (isSuperAdmin) {
                return true;
            }
            let isAccountAdmin = this.AccessPermissions.isEnabled("admin");
            if (isAccountAdmin) {
                return true;
            }
            return this.AccessPermissions.isEnabled(perm);
        }
        /**
         * Returns user application settings for a given application.
         * @param api
         * @param application
         */
        GetUserApplicationSettings(api, application) {
            return __awaiter(this, void 0, void 0, function* () {
                return user_application_settings_1.UserApplicationSettings.GetByApplication(api, this.ID, application);
            });
        }
        /**
         * Creates a session instance from a given session ID.
         * @param sessionID
         */
        static CreateUnknownSessionFromID(sessionID) {
            let session = new IDMSession(null);
            session.ID = sessionID;
            return session;
        }
        /**
         * Creates new session using given user details.
         * @param api
         * @param accountId, optional account id to get account specific permissions for.
         * @param username
         * @param password
         */
        static Login(api, accountId, username, password) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield api.POST("login", JSON.stringify({
                        account: accountId,
                        login: username,
                        password: password
                    }));
                    if (data) {
                        return new IDMSession(data === null || data === void 0 ? void 0 : data.Session);
                    }
                }
                catch (e) {
                    console.log(">>Error: Failed to create new user session for user: " + username);
                    console.log(e);
                }
                return null;
            });
        }
        /**
         * Logs out of current session user.
         * @param api
         */
        static Logout(api) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield api.POST("logout", null);
                }
                catch (e) {
                    console.log(">>Error: Failed to logout of session user.");
                    console.log(e);
                }
            });
        }
    }
    exports.IDMSession = IDMSession;
});
define("api/abstract-api", ["require", "exports", "bruce-models/session/idm-session"], function (require, exports, idm_session_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractAPI = void 0;
    class AbstractAPI {
        constructor(sessionHeader) {
            this.sessionHeader = sessionHeader;
        }
        static Encode(str) {
            return encodeURIComponent(str.replace(/\+/g, "%2B").replace(/\./g, "%2E"));
        }
        /**
         * Creates a GET request to a given url.
         * @param url
         * @param onError
         */
        get(url, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res) => {
                    var _a;
                    $.ajax({
                        headers: {
                            [this.sessionHeader]: (_a = AbstractAPI.Session) === null || _a === void 0 ? void 0 : _a.ID
                        },
                        type: "GET",
                        url: url,
                        success: (data) => {
                            res(data);
                        },
                        error: (err) => {
                            if (onError) {
                                onError(err);
                            }
                            else {
                                //console.log(err);
                            }
                            res(null);
                        },
                        dataType: "json"
                    });
                });
            });
        }
        /**
         * Creates a post request to a given url with given body.
         * @param url
         * @param data
         * @param onError
         */
        post(url, data, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res) => {
                    var _a;
                    $.ajax({
                        headers: {
                            [this.sessionHeader]: (_a = AbstractAPI.Session) === null || _a === void 0 ? void 0 : _a.ID,
                            "Content-Type": "application/json; charset=UTF-8"
                        },
                        type: "POST",
                        url: url,
                        success: (data) => {
                            res(data);
                        },
                        error: (err) => {
                            if (onError) {
                                onError(err);
                            }
                            else {
                                //console.log(err);
                            }
                            res(null);
                        },
                        dataType: "json",
                        data: data,
                        beforeSend: (request) => {
                        }
                    });
                });
            });
        }
        /**
         * Creates a put request to a given url with given body.
         * @param url
         * @param data
         * @param onError
         */
        put(url, data, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res) => {
                    var _a;
                    $.ajax({
                        headers: {
                            [this.sessionHeader]: (_a = AbstractAPI.Session) === null || _a === void 0 ? void 0 : _a.ID,
                            "Content-Type": "application/json; charset=UTF-8"
                        },
                        type: "PUT",
                        url: url,
                        success: (data) => {
                            res(data);
                        },
                        error: (err) => {
                            if (onError) {
                                onError(err);
                            }
                            else {
                                //console.log(err);
                            }
                            res(null);
                        },
                        dataType: "json",
                        data: data,
                        beforeSend: (request) => {
                        }
                    });
                });
            });
        }
        /**
         * Creates a delete request to a given url.
         * @param url
         * @param onError
         */
        delete(url, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res) => {
                    var _a;
                    $.ajax({
                        headers: {
                            [this.sessionHeader]: (_a = AbstractAPI.Session) === null || _a === void 0 ? void 0 : _a.ID
                        },
                        type: "DELETE",
                        url: url,
                        success: (data) => {
                            res(data);
                        },
                        error: (err) => {
                            if (onError) {
                                onError(err);
                            }
                            else {
                                //console.log(err);
                            }
                            res(null);
                        },
                        dataType: "json"
                    });
                });
            });
        }
        /**
         * Uploads given blob file to a given URL.
         * @param url
         * @param blob
         * @param progress
         * @param onError
         * @returns
         */
        upload(url, blob, progress = null, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res) => {
                    var _a;
                    let xhr = new XMLHttpRequest();
                    if (progress) {
                        if (xhr.upload) {
                            xhr.upload.onprogress = progress;
                        }
                        else {
                            xhr.addEventListener("progress", progress);
                        }
                    }
                    xhr.onreadystatechange = (e) => {
                        if (xhr.readyState == 4) {
                            if (xhr.status >= 400) {
                                if (onError) {
                                    let msg = null;
                                    try {
                                        let parsed = JSON.parse(xhr.responseText);
                                        if (parsed.ERROR) {
                                            msg =
                                                {
                                                    message: parsed.ERROR.Message,
                                                    code: parsed.ERROR.Code
                                                };
                                        }
                                        else {
                                            msg = parsed;
                                        }
                                    }
                                    catch (e) {
                                        msg = xhr.responseText;
                                    }
                                    onError(msg);
                                }
                                res(null);
                            }
                            let json;
                            try {
                                json = JSON.parse(xhr.responseText);
                                res(json);
                            }
                            catch (e) {
                                if (onError) {
                                    onError(e);
                                }
                                res(null);
                            }
                        }
                    };
                    xhr.open("POST", url, true);
                    let ssid = (_a = AbstractAPI.Session) === null || _a === void 0 ? void 0 : _a.ID;
                    if (ssid) {
                        xhr.setRequestHeader(this.sessionHeader, ssid);
                    }
                    let formData = new FormData();
                    formData.append("file", blob);
                    xhr.send(formData);
                });
            });
        }
        /**
         * Uploads given form data file to a given url.
         * @param url
         * @param formData
         * @param progress
         * @param onError
         */
        uploadFormData(url, formData, progress = null, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res) => {
                    var _a;
                    let xhr = new XMLHttpRequest();
                    if (progress) {
                        if (xhr.upload) {
                            xhr.upload.onprogress = progress;
                        }
                        else {
                            xhr.addEventListener("progress", progress);
                        }
                    }
                    xhr.onreadystatechange = (e) => {
                        if (xhr.readyState == 4) {
                            if (xhr.status >= 400) {
                                if (onError) {
                                    let msg = null;
                                    try {
                                        let parsed = JSON.parse(xhr.responseText);
                                        if (parsed.ERROR) {
                                            msg =
                                                {
                                                    message: parsed.ERROR.Message,
                                                    code: parsed.ERROR.Code
                                                };
                                        }
                                        else {
                                            msg = parsed;
                                        }
                                    }
                                    catch (e) {
                                        msg = xhr.responseText;
                                    }
                                    onError(msg);
                                }
                                res(null);
                            }
                            let json;
                            try {
                                json = JSON.parse(xhr.responseText);
                                res(json);
                            }
                            catch (e) {
                                if (onError) {
                                    onError(e);
                                }
                                res(null);
                            }
                        }
                    };
                    xhr.open("POST", url, true);
                    let ssid = (_a = AbstractAPI.Session) === null || _a === void 0 ? void 0 : _a.ID;
                    if (ssid) {
                        xhr.setRequestHeader(this.sessionHeader, ssid);
                    }
                    xhr.send(formData);
                });
            });
        }
        /**
         * Performs a get request with response type set to blob.
         * @param url
         * @param onError
         */
        getBlob(url, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res) => {
                    var _a;
                    let xhr = new XMLHttpRequest();
                    xhr.open("GET", url, true);
                    let ssid = (_a = AbstractAPI.Session) === null || _a === void 0 ? void 0 : _a.ID;
                    if (ssid) {
                        xhr.setRequestHeader(this.sessionHeader, ssid);
                    }
                    xhr.responseType = "blob";
                    xhr.onreadystatechange = (e) => {
                        if (xhr.status >= 400) {
                            if (onError) {
                                let err = null;
                                try {
                                    var parsed = JSON.parse(xhr.responseText);
                                    if (parsed.ERROR) {
                                        err =
                                            {
                                                message: parsed.ERROR.Message,
                                                code: parsed.ERROR.Code
                                            };
                                    }
                                    else {
                                        err = parsed;
                                    }
                                }
                                catch (e) {
                                    err = "Failed to make http-request";
                                }
                                onError(err);
                            }
                            res(null);
                        }
                        if (xhr.readyState == 4) {
                            res(xhr.response);
                        }
                    };
                    xhr.send();
                });
            });
        }
    }
    exports.AbstractAPI = AbstractAPI;
    // Reference to the current session;
    AbstractAPI.Session = new idm_session_1.IDMSession(null);
});
define("utils/cache-control", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CacheControl = void 0;
    /**
     * Generic caching helper.
     * Instantiate for a specific purpose for example entity cache.
     * Then Get by id, if null then request for it from db and Set it so next time Get will find it.
     */
    class CacheControl {
        constructor() {
            // Object containing key -> value cache records.
            this.cache = {};
            // Used to declare when all data has been fetched.
            this.fullyFetched = false;
        }
        /**
         * Caches given data.
         * @param id Id to retrieve the data back later.
         * @param data
         */
        Set(id, data) {
            this.cache[id] = data;
        }
        /**
         * Retrieves cached data by id.
         * @param id
         */
        Get(id) {
            return this.cache[id];
        }
        /**
         * Invalidates cached data by id.
         * @param id
         */
        Invalidate(id) {
            if (this.cache[id] != null) {
                delete this.cache[id];
            }
        }
        /**
         * Invalidates all cached data.
         */
        Clear() {
            delete this.cache;
            this.cache = {};
        }
        /**
         * Returns array of cached data ids.
         */
        getKeys() {
            return Object.keys(this.cache);
        }
    }
    exports.CacheControl = CacheControl;
});
define("bruce-models/common/color", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Color = exports.ColorBlendMode = void 0;
    var ColorBlendMode;
    (function (ColorBlendMode) {
        ColorBlendMode[ColorBlendMode["HIGHLIGHT"] = 0] = "HIGHLIGHT";
        ColorBlendMode[ColorBlendMode["REPLACE"] = 1] = "REPLACE";
        ColorBlendMode[ColorBlendMode["MIX"] = 2] = "MIX";
    })(ColorBlendMode = exports.ColorBlendMode || (exports.ColorBlendMode = {}));
    /**
     * Represents a generic colour in bruce.
     */
    class Color {
        constructor(r, g, b, alpha = 1) {
            // Max: 255, Min: 0, Red channel.
            this.red = 0;
            // Max: 255, Min: 0, Green channel.
            this.green = 0;
            // Max: 255, Min: 0, Blue channel.
            this.blue = 0;
            // Max: 1, Min: 0, Alpha channel.
            this.alpha = 1;
            this.red = r;
            this.green = g;
            this.blue = b;
            this.alpha = alpha;
        }
        /**
         * @returns CSS colour string from current values.
         */
        getCSS() {
            let css = `rgba(${this.red}, ${this.green}, ${this.blue}, ${this.alpha})`;
            return css;
        }
        /**
         * (Override)
         * @returns CSS colour string from current values.
         */
        toString() {
            return this.getCSS();
        }
        /**
         * Returns Color instance from given CSS colour string.
         * @param css
         * @returns
         */
        /* TODO
        public static fromCSS(css: string): Color
        {
            let color = new Color(0, 0, 0, 0);
            return color;
        }
        */
        /**
         * Returns Color instance from given rgb values.
         * @param r
         * @param g
         * @param b
         * @returns
         */
        static fromRGB(r, g, b) {
            let color = new Color(r, g, b);
            return color;
        }
        /**
         * Returns Color instance from given rgba values.
         * @param r
         * @param g
         * @param b
         * @param alpha
         * @returns
         */
        static fromRGBA(r, g, b, alpha) {
            let color = new Color(r, g, b, alpha);
            return color;
        }
    }
    exports.Color = Color;
});
define("entry-points/common/calculator", ["require", "exports", "bruce-models/common/color", "utils/object-utils"], function (require, exports, color_1, object_utils_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Calculator = exports.FieldPickerType = void 0;
    var FieldPickerType;
    (function (FieldPickerType) {
        FieldPickerType[FieldPickerType["Color"] = 0] = "Color";
        FieldPickerType[FieldPickerType["Input"] = 1] = "Input";
        FieldPickerType[FieldPickerType["Gradient"] = 2] = "Gradient";
        FieldPickerType[FieldPickerType["Mapping"] = 3] = "Mapping";
        FieldPickerType[FieldPickerType["TagColor"] = 4] = "TagColor";
        FieldPickerType[FieldPickerType["RandomColor"] = 5] = "RandomColor";
    })(FieldPickerType = exports.FieldPickerType || (exports.FieldPickerType = {}));
    const ROOT_NAME = "entity";
    class Calculator {
        constructor() {
            this._formulas = {};
            this._colors = {};
        }
        getColor(color) {
            if (color == null) {
                return null;
            }
            if (color && color instanceof color_1.Color) {
                return color;
            }
            let cache = this._colors[color];
            if (cache) {
                return cache;
            }
            if (!color || !color.length) {
                return null;
            }
            let r, g, b, a;
            let rgba = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*([^\)]+)\s*)?\)$/.exec(color);
            if (rgba) {
                r = parseInt(rgba[1]);
                g = parseInt(rgba[2]);
                b = parseInt(rgba[3]);
                a = rgba[4] != null ? parseFloat(rgba[4]) : 1;
                return this._colors[color] = new color_1.Color(r, g, b, a);
            }
            if (color.charAt(0) == "#") {
                color = color.substring(1);
            }
            if (color.length == 6) {
                // rgb
                let parsed = /^(.{2})(.{2})(.{2})/.exec(color);
                if (!parsed) {
                    return this._colors[color] = null;
                }
                r = parseInt(parsed[1], 16);
                g = parseInt(parsed[2], 16);
                b = parseInt(parsed[3], 16);
                a = 1;
            }
            else if (color.length == 8) {
                // rgba
                let parsed = /^(.{2})(.{2})(.{2})(.{2})/.exec(color);
                if (!parsed) {
                    return this._colors[color] = null;
                }
                r = parseInt(parsed[1], 16);
                g = parseInt(parsed[2], 16);
                b = parseInt(parsed[3], 16);
                a = parseInt(parsed[4], 16);
                if (a != 0) {
                    a = a / 255;
                }
            }
            else {
                return this._colors[color] = null;
            }
            if (a == null) {
                a = 1;
            }
            return this._colors[color] = new color_1.Color(r, g, b, a);
        }
        combineColors(color, opacity) {
            if (opacity == null) {
                return color;
            }
            let colorValue = this.getColor(color);
            return `rgb(${colorValue.red},${colorValue.green},${colorValue.blue},${opacity})`;
        }
        calcValues(entity, values, layers) {
            if (!values || !values.length) {
                return null;
            }
            if (!layers) {
                layers = [];
            }
            for (let i = 0; i < values.length; i++) {
                let value = null;
                let item = values[i];
                switch (item.type) {
                    case FieldPickerType.Color:
                        value = item.value;
                        break;
                    case FieldPickerType.Input:
                        value = this.calcFormula(entity, item.value);
                        break;
                    case FieldPickerType.Mapping:
                        value = this.calcMapping(entity, item.value);
                        break;
                    case FieldPickerType.Gradient:
                        value = this.calcGradient(entity, item.value);
                        break;
                    case FieldPickerType.TagColor:
                        for (let i = 0; i < layers.length; i++) {
                            let layer = layers[i];
                            if (layer.Color) {
                                value = layer.Color;
                            }
                        }
                        break;
                    case FieldPickerType.RandomColor:
                        value = this.getRandomColor();
                        break;
                }
                if (value != null) {
                    return value;
                }
            }
            return null;
        }
        getRandomColor() {
            // https://stackoverflow.com/a/7352887
            let brightness = 4;
            let rgb = [Math.random() * 256, Math.random() * 256, Math.random() * 256];
            let mix = [brightness * 51, brightness * 51, brightness * 51];
            let mixedrgb = [rgb[0] + mix[0], rgb[1] + mix[1], rgb[2] + mix[2]].map(function (x) {
                return Math.round(x / 2.0);
            });
            return "rgba(" + mixedrgb.join(",") + ",0.9" + ")";
        }
        calcGradient(entity, expression) {
            try {
                if (!expression || !expression.field || !expression.points || expression.points.length < 2) {
                    return undefined;
                }
                let value = object_utils_10.ObjectUtils.getValue(expression.field, entity);
                if (value == null) {
                    return undefined;
                }
                value = parseFloat(value);
                if (value == null || isNaN(value)) {
                    return undefined;
                }
                let min = object_utils_10.ObjectUtils.nvl(expression.min, 0);
                let max = object_utils_10.ObjectUtils.nvl(expression.max, 100);
                value = Math.min(Math.max(value, min), max);
                if (value < expression.points[0].position) {
                    return this.getColor(expression.points[0].color);
                }
                for (let i = 0; i < expression.points.length - 1; i++) {
                    let pointA = expression.points[i];
                    let pointB = expression.points[i + 1];
                    if (value >= pointA.position && value <= pointB.position) {
                        if (pointA.position == pointB.position) {
                            return this.getColor(pointA.color);
                        }
                        let distance = (value - pointA.position) / (pointB.position - pointA.position);
                        let colorA = this.getColor(pointA.color);
                        let colorB = this.getColor(pointB.color);
                        let result = new color_1.Color(colorA.red + (colorB.red - colorA.red) * distance, colorA.green + (colorB.green - colorA.green) * distance, colorA.blue + (colorB.blue - colorA.blue) * distance, colorA.alpha + (colorB.alpha - colorA.alpha) * distance);
                        return result;
                    }
                }
                return this.getColor(expression.points[expression.points.length - 1].color);
            }
            catch (e) {
                return undefined;
            }
        }
        calcMapping(entity, expression) {
            try {
                if (!expression || !expression.field || !expression.values || !expression.values.length) {
                    return undefined;
                }
                //let value = this.calcFormula(entity, expression.field);
                let value = object_utils_10.ObjectUtils.UnWrapAtributePathInBashLikeVariable(expression.field);
                value = object_utils_10.ObjectUtils.getValue(value, entity);
                for (let i = 0; i < expression.values.length; i++) {
                    if (this.isValueMatch(value, expression.values[i].fieldValue)) {
                        return expression.values[i].appliedValue;
                    }
                }
            }
            catch (e) {
                return undefined;
            }
        }
        /**
        * Checks whether the specified value matches to the specified criterion.
        * @param value The value of the Entity attribute to check against the criteria.
        * @param condition The expected value or the range (e.g. "1-20").
        */
        isValueMatch(value, condition) {
            if (value == condition) {
                return true;
            }
            let range = condition.split("-");
            if (range.length == 2) {
                return ((Number(value) >= Number(range[0].trim()) && value <= Number(range[1].trim())) ||
                    (Number(value) >= Number(range[1].trim()) && value <= Number(range[0].trim())));
            }
            return false;
        }
        calcFormula(entity, expression) {
            if (this.isAttributeEscape(expression)) {
                return this.calcFormulaNew(entity, expression);
            }
            return this.calcFormulaOld(entity, expression);
        }
        calcFormulaOld(entity, expression) {
            try {
                let formula = this.parseFormula(expression);
                let code = formula.mathCode;
                if (!code) {
                    return null;
                }
                let scope = Object.assign({ [ROOT_NAME]: entity || {} }, entity);
                // We need to find all reserved keywords in eval and then add UIDs to the end of them.
                // For now have only hit 'end'.
                scope["end"] = null;
                delete scope["end"];
                let result = code.eval(scope);
                return result;
            }
            catch (e) {
                // Failed to process as a formula.
                // Let's check if it isn't null and doesn't contain bruce variables and if so then return as is.
                if (expression && typeof expression == "string") {
                    let indexA = expression.indexOf("${");
                    let indexB = expression.indexOf("}");
                    if (indexA <= -1 || indexB <= -1) {
                        return expression;
                    }
                }
                console.log(e);
                return undefined;
            }
        }
        calcFormulaNew(entity, expression) {
            try {
                let math = window.math;
                let expressions = expression.match(/\${(.*?)\}/g);
                if (expressions) {
                    expressions.forEach(element => {
                        let name = element.slice(2, -1);
                        let newValue = this.getValue(name, entity);
                        if (newValue == undefined) {
                            throw new Error("No entity");
                        }
                        expression = expression.replace(element, newValue);
                    });
                    let result = math.eval(expression);
                    return result;
                }
            }
            catch (e) {
                return undefined;
            }
        }
        isAttributeEscape(expression) {
            if (typeof expression === "string") {
                let expressions = expression.match(/\${(.*?)\}/g);
                if (expressions) {
                    return true;
                }
            }
            return false;
        }
        /**
        * Retrieves the value of the Entity Attribute with the specified Path.
        * @param path
        * @param data
        */
        getValue(path, data) {
            let d = data;
            let keys = path.split("\"/\"");
            for (var i in keys) {
                var k = keys[i];
                if (k.startsWith("\"")) {
                    k = k.substring(1);
                }
                if (k.endsWith("\"")) {
                    k = k.substring(0, k.length - 1);
                }
                d = d[k];
                if (!d) {
                    break;
                }
            }
            if (d) {
                if (d instanceof String || typeof (d) === "string") {
                    d = "\"" + d.toString() + "\"";
                }
                else {
                    d = d.toString();
                }
            }
            return d;
        }
        static initialize() {
            let math = window.math;
            if (!math.rgba) {
                math.import({
                    rgba: function (r, g, b, a) {
                        return new color_1.Color(r, g, b, a);
                    }
                });
            }
            if (!math.rgb) {
                math.import({
                    rgb: function (r, g, b) {
                        return new color_1.Color(r, g, b);
                    }
                });
            }
        }
        parseFormula(expression) {
            let cache = this._formulas[expression];
            if (cache) {
                return cache;
            }
            let result = null;
            try {
                let math = window.math;
                let node = math.parse(expression);
                let code = node.compile();
                result =
                    {
                        mathCode: code,
                        expression: expression
                    };
            }
            catch (e) {
                result =
                    {
                        mathCode: null,
                        expression: expression
                    };
            }
            this._formulas[expression] = result;
            return result;
        }
    }
    exports.Calculator = Calculator;
    Calculator.initialize();
});
define("bruce-models/common/altitude-options", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EAltitudeOptionStr = exports.EAltitudeOption = void 0;
    var EAltitudeOption;
    (function (EAltitudeOption) {
        EAltitudeOption[EAltitudeOption["ClampToGround"] = 0] = "ClampToGround";
        EAltitudeOption[EAltitudeOption["Absolute"] = 1] = "Absolute";
        EAltitudeOption[EAltitudeOption["FromGround"] = 2] = "FromGround";
    })(EAltitudeOption = exports.EAltitudeOption || (exports.EAltitudeOption = {}));
    var EAltitudeOptionStr;
    (function (EAltitudeOptionStr) {
        EAltitudeOptionStr["ClampToGround"] = "clampToGround";
        EAltitudeOptionStr["Absolute"] = "absolute";
        EAltitudeOptionStr["FromGround"] = "relativeFromGround";
    })(EAltitudeOptionStr = exports.EAltitudeOptionStr || (exports.EAltitudeOptionStr = {}));
});
define("bruce-models/common/entity-style", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("bruce-models/common/relationship-style", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("bruce-models/common/style", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IStyleType = void 0;
    var IStyleType;
    (function (IStyleType) {
        IStyleType["Entity"] = "ENTITY";
        IStyleType["EntityRelationship"] = "ENTITY_RELATIONSHIP";
    })(IStyleType = exports.IStyleType || (exports.IStyleType = {}));
});
define("bruce-models/common/client-account", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ClientAccount = void 0;
    class ClientAccount {
        constructor(rawData) {
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns raw data for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = Object.assign(Object.assign({}, this.raw), { ID: this.ID, Name: this.Name, Type: this.Type, FullName: this.FullName });
            data = object_utils_11.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.Name != null) {
                this.Name = rawData.Name;
            }
            if (rawData.Type != null) {
                this.Type = rawData.Type;
            }
            if (rawData.FullName != null) {
                this.FullName = rawData.FullName;
            }
        }
    }
    exports.ClientAccount = ClientAccount;
});
define("bruce-models/common/environment", ["require", "exports", "api/bruce-api", "bruce-models/session/idm-session", "bruce-models/common/client-account"], function (require, exports, bruce_api_1, idm_session_2, client_account_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Environment = exports.EEnvironmentType = void 0;
    /**
     * Deployment goes DEV -> STAGING -> UAT -> PROD.
     *
     * DEV and STG share database.
     * UAT and PROD share database.
     */
    var EEnvironmentType;
    (function (EEnvironmentType) {
        EEnvironmentType["DEV"] = "DEV";
        EEnvironmentType["STAGING"] = "STG";
        EEnvironmentType["UAT"] = "UAT";
        EEnvironmentType["PROD"] = "PROD";
    })(EEnvironmentType = exports.EEnvironmentType || (exports.EEnvironmentType = {}));
    // What version should the class assume is localhost / debug.
    const UI_VERSION_DEBUG = -1;
    /**
     * This class describes data in $$.
     */
    class Environment {
        constructor(rawData) {
            this._raw = rawData;
            // Create default so it always has instance.
            this._session = new idm_session_2.IDMSession(null);
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        get Session() {
            return this._session;
        }
        set Session(value) {
            if (value) {
                this._session = value;
            }
            else {
                this._session = new idm_session_2.IDMSession(null);
            }
        }
        get apiInstance() {
            return bruce_api_1.BruceAPI.getInstance(this.Environment, this.ClientAccount.ID);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ClientAccount != null) {
                this.ClientAccount = new client_account_1.ClientAccount(rawData.ClientAccount);
            }
            if (rawData.PageControlLoaded != null) {
                this.PageControlLoaded = rawData.PageControlLoaded;
            }
            if (rawData.RQURI != null) {
                this.RQURI = rawData.RQURI;
            }
            if (rawData.RVSuffix != null) {
                this.RVSuffix = rawData.RVSuffix;
            }
            if (rawData.Resource != null) {
                this.Resource = rawData.Resource;
            }
            if (rawData.Root != null) {
                this.Root = rawData.Root;
            }
            if (rawData.Session != null) {
                this._session = new idm_session_2.IDMSession(rawData.Session);
            }
            if (rawData.Settings != null) {
                this.Settings = rawData.Settings;
            }
            if (rawData.Subdomain != null) {
                this.Subdomain = rawData.Subdomain;
            }
            if (rawData.UIVersion != null) {
                this.UIVersion = rawData.UIVersion;
            }
            if (rawData.UserInterface != null) {
                this.UserInterface = rawData.UserInterface;
            }
            if (rawData.Version != null) {
                this.Version = rawData.Version;
            }
            if (rawData.Environment != null) {
                this.Environment = rawData.Environment;
            }
            if (rawData.Debug != null) {
                this.Debug = rawData.Debug;
            }
        }
        /**
         * Returns if session is not an anonymous user.
         */
        getIsLoggedIn() {
            return !this.Session.isAnonymous();
        }
        /**
         * Returns if session is account admin.
         */
        getIsAdmin() {
            return this.Session.isPermissionEnabled("admin");
        }
        /**
         * Returns if session is hypeportal admin.
         */
        getIsSuperAdmin() {
            return this.Session.HypeportalAccessPermissions.isEnabled("admin");
        }
        /**
         * Returns if the environment was marked as debug mode.
         */
        getIsDebug() {
            let isDebug = this.Debug;
            return isDebug == null ? false : isDebug;
        }
        getVersion() {
            return this.ParseVersion(this.UIVersion);
        }
        ParseVersion(versionStr) {
            return this.getIsDebug() ? UI_VERSION_DEBUG : versionStr ? +versionStr : 1;
        }
        /**
         * @param version
         * @param debugState: if current version is localhost it will default to this state.
         * @returns: if given version is equal or after current UI version.
         */
        IsVersionEqualOrAfter(version, debugState = true) {
            let current = this.getVersion();
            return current == UI_VERSION_DEBUG ? debugState : version >= current;
        }
        /**
         * @param version
         * @param debugState: if current version is localhost it will default to this state.
         * @returns: if given version is equal to the current UI version.
         */
        IsVersionEqual(version, debugState = true) {
            let current = this.getVersion();
            return current == UI_VERSION_DEBUG ? debugState : version == current;
        }
        /**
         * @param version
         * @param debugState: if current version is localhost it will default to this state.
         * @returns: if given version is equal or before current UI version.
         */
        IsVersionEqualOrBefore(version, debugState = true) {
            let current = this.getVersion();
            return current == UI_VERSION_DEBUG ? debugState : version <= current;
        }
    }
    exports.Environment = Environment;
});
define("utils/storage-utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StorageUtils = exports.EStorageUnit = void 0;
    var EStorageUnit;
    (function (EStorageUnit) {
        EStorageUnit[EStorageUnit["MB"] = 1000000] = "MB";
        EStorageUnit[EStorageUnit["GB"] = 1000000000] = "GB";
        EStorageUnit[EStorageUnit["B"] = 1] = "B";
    })(EStorageUnit = exports.EStorageUnit || (exports.EStorageUnit = {}));
    class StorageUtils {
        /**
         * Converts given bytes to megabytes.
         * @param bytes
         */
        static BytesToMegabytes(bytes) {
            return bytes / 1e+6;
        }
        /**
         * Converts given megabytes to bytes.
         * @param megabytes
         */
        static MegabytesToBytes(megabytes) {
            return megabytes * 1e+6;
        }
        /**
         * Converts given gigabytes to bytes.
         * @param gigabytes
         */
        static GigabytesToBytes(gigabytes) {
            return gigabytes * 1e+9;
        }
        /**
         * Returns an object's size as a string in bytes.
         * If cannot be converted to string, it will return -1.
         * @param obj
         */
        static ObjectSizeAsText(obj) {
            if (!obj) {
                return 0;
            }
            try {
                let txt = JSON.stringify(obj);
                return new TextEncoder().encode(txt).length;
            }
            catch (_a) {
                return -1;
            }
        }
    }
    exports.StorageUtils = StorageUtils;
});
define("utils/limited-cache-control", ["require", "exports", "utils/storage-utils"], function (require, exports, storage_utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LimitedCacheControl = void 0;
    const CACHE_CLEANER_CHECK_BATCH_AMOUNT = 500;
    /**
     * Represents a single cached data record in the limited cache control.
     */
    class CachedData {
        constructor(data, duration) {
            this.duration = 0;
            this.data = data;
            duration = +duration;
            if (duration && duration > 0) {
                this.duration = duration;
            }
            if (this.duration > 0) {
                this.recorded = new Date().getTime();
            }
        }
        /**
         * Calculates if cache record has expired according to its duration.
         * @returns
         */
        isExpired() {
            if (this.duration <= 0) {
                return false;
            }
            let old = this.recorded;
            let curr = new Date().getTime();
            let seconds = (curr - old) / 1000;
            return seconds >= this.duration;
        }
    }
    class LimitedCacheControl {
        /**
         * @param allowedSizeInBytes: default value is 1GB.
         * @param unknownSizeDefault: default value is 1MB. This is for objects that fail to have their size calculated.
         */
        constructor(allowedSizeInBytes = 1e+9, unknownSizeDefault = 1e+6) {
            // Object containing key -> value cache records.
            this.cache = {};
            // Array of keys to keep order of cache items being set.
            this.cacheOrder = [];
            // Used to declare when all data has been fetched.
            this.fullyFetched = false;
            // Current occupied size.
            // If this size exceeds allowed size, the oldest added item will be removed on adding a new item.
            this.currentSize = 0;
            this.allowedSizeInBytes = allowedSizeInBytes;
            this.unknownSizeDefault = unknownSizeDefault;
        }
        /**
         * Caches given data.
         * @param id: Id to retrieve the data back later.
         * @param data:
         * @param duration: Duration in seconds for how long this cached data is valid for. Value smaller or equal to 0 wont expire.
         */
        Set(id, data, duration = 0) {
            if (this.cache[id]) {
                this.currentSize -= this.getByteSize(this.cache[id]);
                this.removeOrderRecord(id);
            }
            this.cache[id] = new CachedData(data, duration);
            this.cacheOrder.push(id);
            this.currentSize += this.getByteSize(data);
            if (this.currentSize > this.allowedSizeInBytes && this.cacheOrder.length > 1) {
                this.Invalidate(this.cacheOrder[0]);
            }
            if (duration > 0) {
                this.startExpireyCleaner();
            }
        }
        /**
         * Retrieves cached data by id.
         * @param id
         */
        Get(id) {
            let cachedData = this.cache[id];
            if (cachedData) {
                if (cachedData.isExpired()) {
                    this.Invalidate(id);
                    return;
                }
                return cachedData.data;
            }
            return null;
        }
        /**
         * Invalidates cached data by id.
         * @param id
         */
        Invalidate(id) {
            if (this.cache[id] != null) {
                this.currentSize -= this.getByteSize(this.cache[id]);
                delete this.cache[id];
                this.removeOrderRecord(id);
            }
        }
        /**
         * Invalidates all cached data.
         */
        Clear() {
            delete this.cache;
            this.cache = {};
        }
        /**
         * Returns array of cached data ids.
         * Warning: This will include data that may or may not be expired.
         */
        getKeys() {
            return Object.keys(this.cache);
        }
        /**
         * Returns index of set cache data by it's key.
         * @param key
         */
        locateOrderIndex(key) {
            return this.cacheOrder.findIndex(x => x == key);
        }
        /**
         * Removes record in cache order matching given key.
         * @param key
         */
        removeOrderRecord(key) {
            let index = this.locateOrderIndex(key);
            if (index > -1) {
                this.cacheOrder.splice(index, 1);
            }
        }
        /**
         * @param obj
         * @returns: given object's size in bytes.
         */
        getByteSize(obj) {
            let amount = storage_utils_1.StorageUtils.ObjectSizeAsText(obj);
            if (amount <= -1) {
                return this.unknownSizeDefault;
            }
            return amount;
        }
        /**
         * Disposes the cache control and stops cleaners.
         */
        Dispose() {
            delete this.cache;
            this.cache = {};
            this.cacheOrder = [];
            this.stopExpireyCleaner();
        }
        /**
         * Starts periodic checks on limited duration cache.
         */
        startExpireyCleaner() {
            if (this.expireyCleanerInterval == null) {
                this.expireyCleanerInterval = setInterval(() => {
                    this.doExpireyClean();
                }, 5000);
            }
        }
        /**
         * Stops the periodic cache checker.
         */
        stopExpireyCleaner() {
            clearInterval(this.expireyCleanerInterval);
            this.expireyCleanerInterval = null;
        }
        /**
         * Checks a few records for expirey and removes expired ones.
         * If no expired records are found then automatic cleaner is stopped.
         */
        doExpireyClean() {
            let cleaned = 0;
            let ids = this.getKeys();
            for (let i = 0; i < ids.length; i++) {
                let id = ids[i];
                let cachedData = this.cache[id];
                if (cachedData.isExpired()) {
                    cleaned += 1;
                    this.Invalidate(id);
                    if (cleaned >= CACHE_CLEANER_CHECK_BATCH_AMOUNT) {
                        break;
                    }
                }
            }
            if (cleaned == 0) {
                this.stopExpireyCleaner();
            }
        }
    }
    exports.LimitedCacheControl = LimitedCacheControl;
});
define("bruce-models/common/camera-position", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CameraPosition = void 0;
    class CameraPosition {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns raw JSON data using current instance data.
         */
        get JSON() {
            let data = {
                height: this.height == null ? null : this.height + "",
                latitude: this.latitude == null ? null : this.latitude + "",
                longitude: this.longitude == null ? null : this.longitude + ""
            };
            if (data.height == null) {
                delete data.height;
            }
            if (data.latitude == null) {
                delete data.latitude;
            }
            if (data.longitude == null) {
                delete data.longitude;
            }
            return object_utils_12.ObjectUtils.Dereference(data, true);
        }
        /**
         * Returns cloned copy of instance.
         */
        clone() {
            let raw = this.JSON;
            let copy = new CameraPosition(raw);
            return copy;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.height != null) {
                this.height = parseFloat(rawData.height);
            }
            if (rawData.latitude != null) {
                this.latitude = parseFloat(rawData.latitude);
            }
            if (rawData.longitude != null) {
                this.longitude = parseFloat(rawData.longitude);
            }
        }
    }
    exports.CameraPosition = CameraPosition;
});
define("bruce-models/common/camera", ["require", "exports", "utils/object-utils", "bruce-models/common/camera-position"], function (require, exports, object_utils_13, camera_position_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Camera = void 0;
    class Camera {
        constructor(rawData) {
            // Heading in degrees.
            this.heading = 0;
            // Pitch in degrees.
            this.pitch = 0;
            // Roll in degrees.
            this.roll = 0;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a;
            let data = {
                position: (_a = this.position) === null || _a === void 0 ? void 0 : _a.JSON,
                heading: this.heading,
                pitch: this.pitch,
                roll: this.roll
            };
            data = object_utils_13.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.heading != null) {
                this.heading = rawData.heading;
            }
            if (rawData.pitch != null) {
                this.pitch = rawData.pitch;
            }
            if (rawData.position != null) {
                this.position = new camera_position_1.CameraPosition(rawData.position);
            }
            if (rawData.roll != null) {
                this.roll = rawData.roll;
            }
        }
    }
    exports.Camera = Camera;
});
define("bruce-models/common/camera-frustum", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ECameraFrustum = void 0;
    var ECameraFrustum;
    (function (ECameraFrustum) {
        ECameraFrustum[ECameraFrustum["Perspective"] = 0] = "Perspective";
        ECameraFrustum[ECameraFrustum["Orthographic"] = 1] = "Orthographic";
    })(ECameraFrustum = exports.ECameraFrustum || (exports.ECameraFrustum = {}));
});
define("bruce-models/project-view/project-view-bookmark-settings", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectViewBookmarkSettings = void 0;
    class ProjectViewBookmarkSettings {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                ambientOcclusion: this.ambientOcclusion,
                cameraFrustum: this.cameraFrustum,
                displayTimeline: this.displayTimeline,
                drawnRelationEntityIDs: this.drawnRelationEntityIDs,
                globeColor: this.globeColor,
                groundOcclusion: this.groundOcclusion,
                hidden: this.hidden,
                imagery: this.imagery,
                terrain: this.terrain,
                markup: this.markup,
                selectedItemIds: this.selectedItemIds,
                shadows: this.shadows,
                timelinePointer: this.timelinePointer,
                timelineSettings: this.timelineSettings,
                selectedItems: this.selectedItems,
                selectedStrictItemIds: this.selectedStrictItemIds
            };
            data = object_utils_14.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ambientOcclusion != null) {
                this.ambientOcclusion = rawData.ambientOcclusion;
            }
            if (rawData.cameraFrustum != null) {
                this.cameraFrustum = rawData.cameraFrustum;
            }
            if (rawData.displayTimeline != null) {
                this.displayTimeline = rawData.displayTimeline;
            }
            if (rawData.drawnRelationEntityIDs != null) {
                this.drawnRelationEntityIDs = rawData.drawnRelationEntityIDs;
            }
            if (rawData.globeColor != null) {
                this.globeColor = rawData.globeColor;
            }
            if (rawData.groundOcclusion != null) {
                this.groundOcclusion = rawData.groundOcclusion;
            }
            if (rawData.hidden != null) {
                this.hidden = rawData.hidden;
            }
            if (rawData.imagery != null) {
                if (typeof rawData.imagery == "string") {
                    this.imagery = [rawData.imagery];
                }
                else {
                    this.imagery = rawData.imagery;
                }
            }
            if (rawData.terrain != null) {
                this.terrain = rawData.terrain;
            }
            if (rawData.markup != null) {
                this.markup = rawData.markup;
            }
            if (rawData.selectedItemIds != null) {
                this.selectedItemIds = rawData.selectedItemIds;
            }
            if (rawData.shadows != null) {
                this.shadows = rawData.shadows;
            }
            if (rawData.timelinePointer != null) {
                this.timelinePointer = rawData.timelinePointer;
            }
            if (rawData.timelineSettings != null) {
                this.timelineSettings = rawData.timelineSettings;
            }
            if (rawData.selectedItems != null) {
                this.selectedItems = rawData.selectedItems;
            }
            if (rawData.selectedStrictItemIds != null) {
                this.selectedStrictItemIds = rawData.selectedStrictItemIds;
            }
        }
    }
    exports.ProjectViewBookmarkSettings = ProjectViewBookmarkSettings;
});
define("bruce-models/project-view/project-view-bookmark", ["require", "exports", "bruce-models/common/utc", "bruce-models/common/camera", "bruce-models/project-view/project-view-bookmark-settings", "bruce-models/common/client-file", "utils/object-utils"], function (require, exports, utc_6, camera_1, project_view_bookmark_settings_1, client_file_1, object_utils_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectViewBookmark = void 0;
    class ProjectViewBookmark {
        constructor(rawData) {
            // Bookmark settings.
            this.Settings = new project_view_bookmark_settings_1.ProjectViewBookmarkSettings(null);
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a, _b;
            let data = {
                Camera: (_a = this.Camera) === null || _a === void 0 ? void 0 : _a.JSON,
                "Created.ByUser.ID": this["Created.ByUser.ID"],
                "Created.Date": this["Created.Date"],
                DisplayOrder: this.DisplayOrder,
                ID: this.ID,
                "Screenshot.ClientFile.ID": this["Screenshot.ClientFile.ID"],
                Settings: (_b = this.Settings) === null || _b === void 0 ? void 0 : _b.JSON,
                Title: this.Title,
                "UI.View.ID": this["UI.View.ID"],
                "UI.SlideGroup.ID": this["UI.SlideGroup.ID"],
                Location: this.Location
            };
            data = object_utils_15.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * @param api
         * @returns: URL to the client file associated with the bookmark screenshot.
         */
        getScreenshotURL(api) {
            return client_file_1.ClientFile.getClientFileURL(api, this["Screenshot.ClientFile.ID"]);
        }
        /**
         * Updates instance of this Project View using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.Camera != null) {
                this.Camera = new camera_1.Camera(rawData.Camera);
            }
            if (rawData["Created.ByUser.ID"] != null) {
                this["Created.ByUser.ID"] = rawData["Created.ByUser.ID"];
            }
            if (rawData["Created.Date"] != null) {
                this["Created.Date"] = new utc_6.UTC(rawData["Created.Date"]);
            }
            if (rawData.DisplayOrder != null) {
                this.DisplayOrder = rawData.DisplayOrder;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData["Screenshot.ClientFile.ID"] != null) {
                this["Screenshot.ClientFile.ID"] = rawData["Screenshot.ClientFile.ID"];
            }
            if (rawData.Settings != null) {
                this.Settings.Update(rawData.Settings);
            }
            if (rawData.Title != null) {
                this.Title = rawData.Title;
            }
            if (rawData["UI.View.ID"] != null) {
                this["UI.View.ID"] = rawData["UI.View.ID"];
            }
            if (rawData["UI.SlideGroup.ID"] != null) {
                this["UI.SlideGroup.ID"] = rawData["UI.SlideGroup.ID"];
            }
            if (rawData.Location != null) {
                this.Location = rawData.Location;
            }
        }
        /**
         * Saves or creates record for current instance.
         * Warning: If no ID is set then a random one will be generated.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = this.JSON;
                let ID = !this.ID ? "" : this.ID;
                let res = yield api.POST(`ui.view/${this["UI.View.ID"]}/slide/${ID}`, JSON.stringify(data));
                if (res) {
                    this.Update(res);
                    return this;
                }
                return null;
            });
        }
        /**
         * Deletes bookmark record corresponding to current bookmark id.
         * @param api
         */
        DeleteRecord(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return ProjectViewBookmark.DeleteRecordByID(api, this["UI.View.ID"], this.ID);
            });
        }
        /**
         * Sets the current bookmark as the project view default.
         * @param api
         */
        SetAsDefault(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return ProjectViewBookmark.SetDefaultBookmark(api, this["UI.View.ID"], this.ID);
            });
        }
        /**
         * Returns all bookmarks for a project view.
         * @param api
         * @param viewId
         */
        static GetBookmarksForProjectView(api, viewId) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET(`ui.view/${viewId}/slides`);
                if (data && data.Items) {
                    let bookmarks = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        let bookmark = new ProjectViewBookmark(data.Items[i]);
                        bookmarks.push(bookmark);
                    }
                    return bookmarks;
                }
                return [];
            });
        }
        /**
         * Updates the bookmarks order for a project view.
         * @param api
         * @param viewId
         * @param bookmarkIds: bookmark ids in the new order.
         */
        static SetBookmarksOrder(api, viewId, bookmarkIds) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = {
                    "UISlide.ID": bookmarkIds,
                    "DisplayOrder.Start": 0
                };
                return api.POST(`ui.view/${viewId}/slides/setOrder`, JSON.stringify(data));
            });
        }
        /**
         * Updates what bookmark is marked as default for a project view.
         * @param api
         * @param viewId
         * @param bookmarkId
         */
        static SetDefaultBookmark(api, viewId, bookmarkId) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.PUT(`ui.view/${viewId}/slide/${bookmarkId}/setAsDefault`, null);
            });
        }
        /**
         * Deletes bookmark record corresponding to given view and bookmark ids.
         * @param api
         * @param viewId
         * @param bookmarkId
         */
        static DeleteRecordByID(api, viewId, bookmarkId) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.DELETE(`ui.view/${viewId}/slide/${bookmarkId}`);
            });
        }
    }
    exports.ProjectViewBookmark = ProjectViewBookmark;
});
define("bruce-models/common/bruce-tileset-style-mapping", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceTilesetStyleMapping = void 0;
    class BruceTilesetStyleMapping {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                EntityTypeID: this.EntityTypeID,
                StyleID: this.StyleID,
                Style: this.Style
            };
            data = object_utils_16.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.EntityTypeID != null) {
                this.EntityTypeID = rawData.EntityTypeID;
            }
            if (rawData.StyleID != null) {
                this.StyleID = rawData.StyleID;
            }
        }
        /**
         * Returns an array of style mapping from a given raw json.
         * @param rawData
         */
        static StyleMappingArrayFromRaw(rawData) {
            if (rawData.length != null) {
                let parsed = [];
                for (let i = 0; i < rawData.length; i++) {
                    let rawRow = rawData[i];
                    let parsedRow = new BruceTilesetStyleMapping(rawRow);
                    parsed.push(parsedRow);
                }
                return parsed;
            }
            return [];
        }
    }
    exports.BruceTilesetStyleMapping = BruceTilesetStyleMapping;
});
define("bruce-models/common/camera-zoom-control", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CameraZoomControl = exports.ECameraZoomControlDisplayType = void 0;
    /**
     * Options of how an Entity can be rendered based on Camera Zoom.
     */
    var ECameraZoomControlDisplayType;
    (function (ECameraZoomControlDisplayType) {
        ECameraZoomControlDisplayType["Hidden"] = "hidden";
        ECameraZoomControlDisplayType["Point"] = "point";
        ECameraZoomControlDisplayType["Geometry"] = "geometry";
        ECameraZoomControlDisplayType["Model3D"] = "3d";
        ECameraZoomControlDisplayType["Polygon"] = "forcepolygon";
        // Backward compatibility support.
        ECameraZoomControlDisplayType["GeometryOld"] = "polygon";
    })(ECameraZoomControlDisplayType = exports.ECameraZoomControlDisplayType || (exports.ECameraZoomControlDisplayType = {}));
    /**
     * Describes a single row of camera zoom control.
     * Typically a saved object of zoom control is an array of camera zoom controls.
     */
    class CameraZoomControl {
        constructor(rawData) {
            // What lod category to pull models from if we are trying to display 3d.
            this.LODCategoryID = "GLB";
            // What lod level we are using.
            this.LODLevel = 0;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                MinZoom: this.MinZoom,
                MaxZoom: this.MaxZoom,
                DisplayType: this.DisplayType,
                StyleID: this.StyleID,
                Style: this.Style,
                LODCategoryID: this.LODCategoryID,
                LODLevel: this.LODLevel
            };
            data = object_utils_17.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.DisplayType != null) {
                this.DisplayType = rawData.DisplayType;
            }
            if (rawData.LODCategoryID != null) {
                this.LODCategoryID = rawData.LODCategoryID;
            }
            if (rawData.LODLevel != null) {
                if (typeof rawData.LODLevel == "string") {
                    this.LODLevel = parseInt(rawData.LODLevel);
                }
                else {
                    this.LODLevel = rawData.LODLevel;
                }
            }
            if (rawData.MaxZoom != null) {
                this.MaxZoom = rawData.MaxZoom;
            }
            if (rawData.MinZoom != null) {
                this.MinZoom = rawData.MinZoom;
            }
            if (rawData.StyleID != null) {
                this.StyleID = rawData.StyleID;
            }
            if (rawData.Style != null) {
                this.Style = rawData.Style;
            }
        }
        /**
         * Returns an array of zoom control rows from a given raw json.
         * @param rawData
         */
        static ZoomControlRowsFromRaw(rawData) {
            if (rawData.length != null) {
                let parsed = [];
                for (let i = 0; i < rawData.length; i++) {
                    let rawRow = rawData[i];
                    let parsedRow = new CameraZoomControl(rawRow);
                    parsed.push(parsedRow);
                }
                return parsed;
            }
            return [];
        }
    }
    exports.CameraZoomControl = CameraZoomControl;
});
define("bruce-models/menu-item/menu-item-legend", ["require", "exports", "entry-points/common/calculator", "utils/object-utils", "bruce-models/common/entity-type"], function (require, exports, calculator_1, object_utils_18, entity_type_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemLegend = void 0;
    /**
     * Describes what kind of legends should be visible for a menu item.
     */
    class MenuItemLegend {
        constructor(rawData) {
            this.model3d = false;
            this.modelColor = "rgb(0, 0, 0)";
            this.point = false;
            this.pointSize = 0;
            this.pointColor = "rgb(0, 0, 0)";
            this.polygon = false;
            this.polygonFill = "rgb(0, 0, 0)";
            this.polygonStroke = "rgb(0, 0, 0)";
            this.polygonStrokeWidth = 0;
            this.polylines = false;
            this.polylineColor = "rgb(0, 0, 0)";
            this.polylineWidth = 0;
            this.tileset3d = false;
            this.tilesetColor = "rgb(0, 0, 0)";
            this.Update(rawData);
        }
        /**
         * Returns if any legend type is enabled.
         */
        get Enabled() {
            return this.point || this.polygon || this.polylines || this.tileset3d || this.model3d;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                model3d: this.model3d,
                point: this.point,
                polygon: this.polygon,
                polylines: this.polylines,
                tileset3d: this.tileset3d
            };
            data = object_utils_18.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.model3d != null) {
                this.model3d = rawData.model3d;
            }
            if (rawData.point != null) {
                this.point = rawData.point;
            }
            if (rawData.polygon != null) {
                this.polygon = rawData.polygon;
            }
            if (rawData.polylines != null) {
                this.polylines = rawData.polylines;
            }
            if (rawData.tileset3d != null) {
                this.tileset3d = rawData.tileset3d;
            }
        }
        /**
         * Applies zoom control to legend values.
         * Warning: Only applies values to enabled legend types.
         * @param api
         * @param zoomControl
         * @param entityTypeId Used to get default style.
         */
        LoadValuesFromZoomControl(api, zoomControl, entityTypeId) {
            return __awaiter(this, void 0, void 0, function* () {
                let zc = zoomControl;
                if (!zc || zc.length <= 0) {
                    return;
                }
                let triedDefault = false;
                for (let i = 0; i < zc.length; i++) {
                    let row = zc[i];
                    if (!row.Style) {
                        if (row.StyleID != null) {
                            try {
                                let viewSettings = yield api.getViewSettings(row.StyleID);
                                if (viewSettings.Settings) {
                                    row.Style = viewSettings.Settings;
                                }
                            }
                            catch (_a) {
                            }
                        }
                        else if (entityTypeId && !triedDefault) {
                            try {
                                let ET = yield entity_type_2.EntityType.GetByID(api, entityTypeId);
                                let styleID = ET["DisplaySetting.ID"];
                                if (styleID) {
                                    let viewSettings = yield api.getViewSettings(row.StyleID);
                                    if (viewSettings.Settings) {
                                        row.Style = viewSettings.Settings;
                                    }
                                }
                            }
                            catch (_b) {
                            }
                            triedDefault = true;
                        }
                    }
                    if (row.Style) {
                        this.LoadValuesFromStyle(row.Style);
                        return;
                    }
                }
            });
        }
        /**
         * Applies tileset mapping to legend values.
         * Warning: Only applies values to enabled legend types.
         * @param api
         * @param mapping
         * @param fallback Menu item fallback style
         */
        LoadValuesFromMapping(api, mapping, fallback) {
            return __awaiter(this, void 0, void 0, function* () {
                let m = mapping;
                if ((!m || m.length <= 0) && !fallback) {
                    return;
                }
                for (let i = 0; i < mapping.length; i++) {
                    let row = mapping[i];
                    if (!row.Style) {
                        if (row.StyleID) {
                            try {
                                let viewSettings = yield api.getViewSettings(row.StyleID);
                                if (viewSettings.Settings) {
                                    row.Style = viewSettings.Settings;
                                }
                            }
                            catch (_a) {
                            }
                        }
                        else if (row.EntityTypeID) {
                            try {
                                let ET = yield entity_type_2.EntityType.GetByID(api, row.EntityTypeID);
                                let styleID = ET["DisplaySetting.ID"];
                                if (styleID) {
                                    let viewSettings = yield api.getViewSettings(row.StyleID);
                                    if (viewSettings.Settings) {
                                        row.Style = viewSettings.Settings;
                                    }
                                }
                            }
                            catch (_b) {
                            }
                        }
                    }
                    if (row.Style) {
                        this.LoadValuesFromStyle(row.Style);
                        return;
                    }
                }
                if (fallback) {
                    this.LoadValuesFromStyle(fallback);
                }
            });
        }
        /**
         * Applies style to legend values.
         * Warning: Only applies values to enabled legend types.
         * @param style
         */
        LoadValuesFromStyle(style) {
            if (this.point) {
                let pointStyle = style.pointStyle;
                if (pointStyle) {
                    if (typeof pointStyle.color == "string") {
                        this.pointColor = pointStyle.color;
                    }
                    else {
                        let color = pointStyle.color.find(x => x.type == calculator_1.FieldPickerType.Color);
                        if (color && color.value) {
                            this.pointColor = color.value;
                        }
                    }
                    if (pointStyle.size) {
                        let size = pointStyle.size.find(x => x.type == calculator_1.FieldPickerType.Input);
                        if (size && size.value) {
                            this.pointSize = object_utils_18.ObjectUtils.parseNum(size.value);
                        }
                    }
                }
            }
            if (this.model3d) {
                let modelStyle = style.modelStyle;
                if (modelStyle) {
                    if (typeof modelStyle.fillColor == "string") {
                        this.modelColor = modelStyle.fillColor;
                    }
                    else {
                        let color = modelStyle.fillColor.find(x => x.type == calculator_1.FieldPickerType.Color);
                        if (color && color.value) {
                            this.modelColor = color.value;
                        }
                    }
                }
            }
            if (this.polygon) {
                let polygonStyle = style.polygonStyle;
                if (polygonStyle) {
                    let fillColor = polygonStyle.fillColor.find(x => x.type == calculator_1.FieldPickerType.Color);
                    if (fillColor && fillColor.value) {
                        this.polygonFill = fillColor.value;
                    }
                    let lineColor = polygonStyle.lineColor.find(x => x.type == calculator_1.FieldPickerType.Color);
                    if (lineColor && lineColor.value) {
                        this.polygonStroke = lineColor.value;
                    }
                    let lineWidth = polygonStyle.lineWidth.find(x => x.type == calculator_1.FieldPickerType.Input);
                    if (lineWidth && lineWidth.value) {
                        this.polygonStrokeWidth = object_utils_18.ObjectUtils.parseNum(lineWidth.value);
                    }
                }
            }
            if (this.polylines) {
                let polylineStyle = style.polylineStyle;
                if (polylineStyle) {
                    let color = polylineStyle.lineColor.find(x => x.type == calculator_1.FieldPickerType.Color);
                    if (color && color.value) {
                        this.polylineColor = color.value;
                    }
                    let lineWidth = polylineStyle.lineWidth.find(x => x.type == calculator_1.FieldPickerType.Input);
                    if (lineWidth && lineWidth.value) {
                        this.polylineWidth = object_utils_18.ObjectUtils.parseNum(lineWidth.value);
                    }
                }
            }
            if (this.tileset3d) {
                /* Deprecated, we use model styling.
                let tilesetStyle = style.tilesetStyle;
                if (tilesetStyle)
                {
                    if (typeof tilesetStyle.fillColor == "string")
                    {
                        this.tilesetColor = tilesetStyle.fillColor;
                    }
                    else
                    {
                        let color = tilesetStyle.fillColor.find(x => x.type == FieldPickerType.Color);
                        if (color && color.value)
                        {
                            this.tilesetColor = color.value as string;
                        }
                    }
                }
                */
                let modelStyle = style.modelStyle;
                if (modelStyle) {
                    if (typeof modelStyle.fillColor == "string") {
                        this.tilesetColor = modelStyle.fillColor;
                    }
                    else {
                        let color = modelStyle.fillColor.find(x => x.type == calculator_1.FieldPickerType.Color);
                        if (color && color.value) {
                            this.tilesetColor = color.value;
                        }
                    }
                }
            }
        }
    }
    exports.MenuItemLegend = MenuItemLegend;
});
define("bruce-models/menu-item/menu-item-base", ["require", "exports", "bruce-models/menu-item/menu-item-utils", "bruce-models/menu-item/menu-item-legend", "utils/object-utils"], function (require, exports, menu_item_utils_1, menu_item_legend_1, object_utils_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemBase = exports.RenderPriority = exports.MenuItemType = void 0;
    /**
     * The types of menu items that are available.
     */
    var MenuItemType;
    (function (MenuItemType) {
        MenuItemType["Cesium3DTileset"] = "Cesium3DTileset";
        MenuItemType["BruceEntity"] = "BruceEntity";
        MenuItemType["LoadedBruceEntity"] = "LoadedBruceEntity";
        MenuItemType["SingleEntity"] = "SingleEntity";
        MenuItemType["GeometricBruceEntity"] = "GeometricBruceEntity";
        MenuItemType["ArbitraryTileset"] = "ArbitraryTileset";
        MenuItemType["OSMBuildingsTileset"] = "OSMBuildingsTileset";
        MenuItemType["Custom"] = "Custom";
        MenuItemType["ModelTileset"] = "ModelTileset";
    })(MenuItemType = exports.MenuItemType || (exports.MenuItemType = {}));
    var RenderPriority;
    (function (RenderPriority) {
        RenderPriority[RenderPriority["Low"] = 0] = "Low";
        RenderPriority[RenderPriority["Medium"] = 1] = "Medium";
        RenderPriority[RenderPriority["High"] = 2] = "High";
    })(RenderPriority = exports.RenderPriority || (exports.RenderPriority = {}));
    class MenuItemBase {
        constructor(rawData) {
            // Child menu items for this menu item.
            this.Children = [];
            // If the menu item is currently enabled or not.
            // This is just an indicator, this does not have any functionality.
            this.enabled = false;
            /**
             * What priority does this menu item have compared to other menu items that draw the same entities.
             * The highest priority menu item will be used to for display an entity's visual.
             */
            this.renderPriority = RenderPriority.Low;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a;
            let data = {
                id: this.id,
                Caption: this.Caption,
                Children: this.Children ? this.Children.map(x => x.JSON) : null,
                Type: this.Type,
                hideChildren: this.hideChildren,
                legend: (_a = this.legend) === null || _a === void 0 ? void 0 : _a.JSON,
                authoringEnabled: this.authoringEnabled,
                LabelColor: this.LabelColor,
                enabled: this.enabled,
                renderPriority: this.renderPriority
            };
            data = object_utils_19.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.id != null) {
                this.id = rawData.id;
            }
            if (rawData.Caption != null) {
                this.Caption = rawData.Caption;
            }
            if (rawData.Children != null) {
                this.Children = menu_item_utils_1.MenuItemUtils.MenuItemsFromRaw(rawData.Children);
            }
            if (rawData.Type != null) {
                this.Type = rawData.Type;
            }
            if (rawData.hideChildren != null) {
                this.hideChildren = rawData.hideChildren;
            }
            if (rawData.showLegends != null) {
                this.legend = new menu_item_legend_1.MenuItemLegend(rawData.showLegends);
            }
            if (rawData.authoringEnabled != null) {
                this.authoringEnabled = rawData.authoringEnabled;
            }
            if (rawData.LabelColor != null) {
                this.LabelColor = rawData.LabelColor;
            }
        }
        /**
         * Enables or disables this menu item and it's children.
         * @param state
         */
        SetEnabled(state) {
            this.enabled = state;
            let children = this.Children;
            if (children) {
                for (let i = 0; i < children.length; i++) {
                    let child = children[i];
                    child.SetEnabled(state);
                }
            }
        }
    }
    exports.MenuItemBase = MenuItemBase;
});
define("bruce-models/menu-item/menu-item-bruce-entity", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemBruceEntity = void 0;
    /**
     * Describes settings related to entity information for a menu item.
     */
    class MenuItemBruceEntity {
        constructor(rawData) {
            // Preloaded entity data to display.
            this.Entities = [];
            // If associated tags should be shown as seperate child menu items.
            this.ExpandLayers = false;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                "EntityType.ID": this["EntityType.ID"],
                EntityId: this.EntityId,
                Entities: this.Entities ? this.Entities.map(x => x.JSON) : null,
                ExpandLayers: this.ExpandLayers
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData["EntityType.ID"] != null) {
                this["EntityType.ID"] = rawData["EntityType.ID"];
            }
            if (rawData.ExpandLayers != null) {
                this.ExpandLayers = rawData.ExpandLayers;
            }
            if (rawData.EntityId != null) {
                this.EntityId = rawData.EntityId;
            }
            if (rawData.Entities != null) {
                this.Entities = rawData.Entities;
            }
        }
    }
    exports.MenuItemBruceEntity = MenuItemBruceEntity;
});
define("bruce-models/menu-item/menu-item-bruce-entities", ["require", "exports", "bruce-models/menu-item/menu-item-base", "bruce-models/menu-item/menu-item-bruce-entity", "bruce-models/common/camera-zoom-control", "utils/object-utils"], function (require, exports, menu_item_base_1, menu_item_bruce_entity_1, camera_zoom_control_1, object_utils_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemBruceEntities = void 0;
    class MenuItemBruceEntities extends menu_item_base_1.MenuItemBase {
        constructor(rawData) {
            super(rawData);
            /**
             * If polygons should have fix method automatically run on them before rendering.
             */
            this.fixPolygons = false;
        }
        /**
         * Returns the entity type id for this menu item.
         */
        get entityTypeId() {
            var _a;
            return (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a["EntityType.ID"];
        }
        /**
         * Returns the lod category id for this menu item.
         */
        get lodCategoryId() {
            var _a;
            return (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a["LODCategory.ID"];
        }
        /**
         * Returns zoom control for this menu item.
         */
        get zoomControl() {
            return this.CameraZoomSettings;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a;
            let baseData = super.JSON;
            let data = Object.assign(Object.assign({}, baseData), { BruceEntity: (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a.JSON, CameraZoomSettings: this.CameraZoomSettings ? this.CameraZoomSettings.map(x => x.JSON) : null, showAllLayers: this.showAllLayers, showAllLayersExcludeBelow: this.showAllLayersExcludeBelow, tagIds: this.tagIds, styleId: this.styleId });
            data = object_utils_20.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            super.Update(rawData);
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.BruceEntity != null) {
                this.BruceEntity = new menu_item_bruce_entity_1.MenuItemBruceEntity(rawData.BruceEntity);
            }
            if (rawData.CameraZoomSettings != null) {
                this.CameraZoomSettings = camera_zoom_control_1.CameraZoomControl.ZoomControlRowsFromRaw(rawData.CameraZoomSettings);
            }
            if (rawData.showAllLayers != null) {
                this.showAllLayers = rawData.showAllLayers;
            }
            if (rawData.showAllLayersExcludeBelow != null) {
                this.showAllLayersExcludeBelow = rawData.showAllLayersExcludeBelow;
            }
            if (rawData.layers != null) {
                this.tagIds = rawData.layers;
            }
        }
        /**
         * Uses zoom control to load values for the menu item legends.
         */
        LoadLegendValues(api) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                let zc = this.zoomControl;
                if (zc) {
                    yield this.legend.LoadValuesFromZoomControl(api, zc, (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a["EntityType.ID"]);
                }
                else if (this.styleId) {
                    try {
                        let viewSettings = yield api.getViewSettings(this.styleId);
                        if (viewSettings.Settings) {
                            this.legend.LoadValuesFromStyle(viewSettings.Settings);
                        }
                    }
                    catch (_b) {
                    }
                }
            });
        }
    }
    exports.MenuItemBruceEntities = MenuItemBruceEntities;
});
define("bruce-models/common/bruce-tileset", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceTileset = void 0;
    class BruceTileset {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                ClientAccountID: this.ClientAccountID,
                TilesetID: this.TilesetID,
                TilesetName: this.TilesetName,
                TilesetURL: this.TilesetURL
            };
            data = object_utils_21.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ClientAccountID != null) {
                this.ClientAccountID = rawData.ClientAccountID;
            }
            if (rawData.TilesetID != null) {
                this.TilesetID = rawData.TilesetID;
            }
            if (rawData.TilesetName != null) {
                this.TilesetName = rawData.TilesetName;
            }
            if (rawData.TilesetURL != null) {
                this.TilesetURL = rawData.TilesetURL;
            }
        }
    }
    exports.BruceTileset = BruceTileset;
});
define("bruce-models/menu-item/menu-item-arbitrary-tileset", ["require", "exports", "bruce-models/menu-item/menu-item-base", "bruce-models/menu-item/menu-item-bruce-entity", "bruce-models/common/bruce-tileset", "bruce-models/common/bruce-tileset-style-mapping", "utils/object-utils"], function (require, exports, menu_item_base_2, menu_item_bruce_entity_2, bruce_tileset_1, bruce_tileset_style_mapping_1, object_utils_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemArbitraryTileset = void 0;
    class MenuItemArbitraryTileset extends menu_item_base_2.MenuItemBase {
        constructor(rawData) {
            super(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a, _b;
            let baseData = super.JSON;
            let data = Object.assign(Object.assign({}, baseData), { FlyTo: this.FlyTo, BruceEntity: (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a.JSON, tileset: (_b = this.tileset) === null || _b === void 0 ? void 0 : _b.JSON, StyleMapping: this.StyleMapping ? this.StyleMapping.map(x => x.JSON) : null, styleId: this.styleId, style: this.style, tilesetURL: this.tilesetURL });
            data = object_utils_22.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            super.Update(rawData);
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.FlyTo != null) {
                this.FlyTo = rawData.FlyTo;
            }
            if (rawData.BruceEntity != null) {
                this.BruceEntity = new menu_item_bruce_entity_2.MenuItemBruceEntity(rawData.BruceEntity);
            }
            if (rawData.tileset != null) {
                this.tileset = new bruce_tileset_1.BruceTileset(rawData.tileset);
            }
            if (rawData.StyleMapping != null) {
                this.StyleMapping = bruce_tileset_style_mapping_1.BruceTilesetStyleMapping.StyleMappingArrayFromRaw(rawData.StyleMapping);
            }
            if (rawData.styleId != null) {
                this.styleId = rawData.styleId;
            }
            if (rawData.style != null) {
                this.style = rawData.style;
            }
            if (rawData.tilesetURL != null) {
                this.tilesetURL = rawData.tilesetURL;
            }
        }
        /**
         * Uses zoom control to load values for the menu item legends.
         */
        LoadLegendValues(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let fallback;
                if (this.styleId) {
                    try {
                        let viewSettings = yield api.getViewSettings(this.styleId);
                        if (viewSettings.Settings) {
                            fallback = viewSettings.Settings;
                        }
                    }
                    catch (_a) {
                    }
                }
                let mapping = this.StyleMapping;
                if (mapping) {
                    yield this.legend.LoadValuesFromMapping(api, mapping, fallback);
                }
            });
        }
    }
    exports.MenuItemArbitraryTileset = MenuItemArbitraryTileset;
});
define("bruce-models/menu-item/menu-item-loaded-entities", ["require", "exports", "utils/object-utils", "bruce-models/menu-item/menu-item-base", "bruce-models/menu-item/menu-item-bruce-entity"], function (require, exports, object_utils_23, menu_item_base_3, menu_item_bruce_entity_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemLoadedEntities = void 0;
    class MenuItemLoadedEntities extends menu_item_base_3.MenuItemBase {
        constructor(rawData) {
            super(rawData);
            /**
             * If polygons should have fix method automatically run on them before rendering.
             */
            this.fixPolygons = false;
        }
        /**
         * Returns the entity type id for this menu item.
         */
        get entityTypeId() {
            var _a;
            return (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a["EntityType.ID"];
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a;
            let baseData = super.JSON;
            let data = Object.assign(Object.assign({}, baseData), { BruceEntity: (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a.JSON, StyleID: this.StyleID, Style: this.Style, DisplayType: this.DisplayType, LODCategoryID: this.LODCategoryID, LODLevel: this.LODLevel });
            data = object_utils_23.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            super.Update(rawData);
            if (!rawData) {
                return;
            }
            if (rawData.BruceEntity != null) {
                this.BruceEntity = new menu_item_bruce_entity_3.MenuItemBruceEntity(rawData.BruceEntity);
            }
            if (rawData.StyleID != null) {
                this.StyleID = rawData.StyleID;
            }
            if (rawData.Style != null) {
                this.Style = rawData.Style;
            }
            if (rawData.DisplayType != null) {
                this.DisplayType = rawData.DisplayType;
            }
            if (rawData.LODCategoryID != null) {
                this.LODCategoryID = rawData.LODCategoryID;
            }
            if (rawData.LODLevel != null) {
                this.LODLevel = rawData.LODLevel;
            }
        }
    }
    exports.MenuItemLoadedEntities = MenuItemLoadedEntities;
});
define("bruce-models/menu-item/menu-item-model-tileset", ["require", "exports", "bruce-models/menu-item/menu-item-base", "bruce-models/menu-item/menu-item-bruce-entity", "bruce-models/common/bruce-tileset", "bruce-models/common/bruce-tileset-style-mapping", "utils/object-utils"], function (require, exports, menu_item_base_4, menu_item_bruce_entity_4, bruce_tileset_2, bruce_tileset_style_mapping_2, object_utils_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemModelTileset = void 0;
    class MenuItemModelTileset extends menu_item_base_4.MenuItemBase {
        constructor(rawData) {
            super(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a, _b;
            let baseData = super.JSON;
            let data = Object.assign(Object.assign({}, baseData), { FlyTo: this.FlyTo, BruceEntity: (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a.JSON, tileset: (_b = this.tileset) === null || _b === void 0 ? void 0 : _b.JSON, StyleMapping: this.StyleMapping ? this.StyleMapping.map(x => x.JSON) : null, styleId: this.styleId, StyleBlending: this.StyleBlending });
            data = object_utils_24.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            super.Update(rawData);
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.FlyTo != null) {
                this.FlyTo = rawData.FlyTo;
            }
            if (rawData.BruceEntity != null) {
                this.BruceEntity = new menu_item_bruce_entity_4.MenuItemBruceEntity(rawData.BruceEntity);
            }
            if (rawData.tileset != null) {
                this.tileset = new bruce_tileset_2.BruceTileset(rawData.tileset);
            }
            if (rawData.StyleMapping != null) {
                this.StyleMapping = bruce_tileset_style_mapping_2.BruceTilesetStyleMapping.StyleMappingArrayFromRaw(rawData.StyleMapping);
            }
            if (rawData.styleId != null) {
                this.styleId = rawData.styleId;
            }
            if (rawData.StyleBlending != null) {
                this.StyleBlending = rawData.StyleBlending;
            }
            if (rawData.Style != null) {
                this.Style = rawData.Style;
            }
        }
        /**
         * Uses zoom control to load values for the menu item legends.
         */
        LoadLegendValues(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let fallback;
                if (this.styleId) {
                    try {
                        let viewSettings = yield api.getViewSettings(this.styleId);
                        if (viewSettings.Settings) {
                            fallback = viewSettings.Settings;
                        }
                    }
                    catch (e) {
                        console.log(e);
                    }
                }
                const mapping = this.StyleMapping;
                if (mapping) {
                    yield this.legend.LoadValuesFromMapping(api, mapping, fallback);
                }
            });
        }
    }
    exports.MenuItemModelTileset = MenuItemModelTileset;
});
define("bruce-models/menu-item/menu-item-single-entity", ["require", "exports", "utils/object-utils", "bruce-models/common/camera-zoom-control", "bruce-models/menu-item/menu-item-base", "bruce-models/menu-item/menu-item-bruce-entity"], function (require, exports, object_utils_25, camera_zoom_control_2, menu_item_base_5, menu_item_bruce_entity_5) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemSingleEntity = void 0;
    class MenuItemSingleEntity extends menu_item_base_5.MenuItemBase {
        constructor(rawData) {
            super(rawData);
        }
        /**
         * Returns the entity type id for this menu item.
         */
        get entityTypeId() {
            var _a;
            return (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a["EntityType.ID"];
        }
        /**
         * Returns the lod category id for this menu item.
         */
        get lodCategoryId() {
            var _a;
            return (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a["LODCategory.ID"];
        }
        /**
         * Returns zoom control for this menu item.
         */
        get zoomControl() {
            return this.CameraZoomSettings;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a;
            let baseData = super.JSON;
            let data = Object.assign(Object.assign({}, baseData), { BruceEntity: (_a = this.BruceEntity) === null || _a === void 0 ? void 0 : _a.JSON, CameraZoomSettings: this.CameraZoomSettings ? this.CameraZoomSettings.map(x => x.JSON) : null });
            data = object_utils_25.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            super.Update(rawData);
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.BruceEntity != null) {
                this.BruceEntity = new menu_item_bruce_entity_5.MenuItemBruceEntity(rawData.BruceEntity);
            }
            if (rawData.CameraZoomSettings != null) {
                this.CameraZoomSettings = camera_zoom_control_2.CameraZoomControl.ZoomControlRowsFromRaw(rawData.CameraZoomSettings);
            }
        }
    }
    exports.MenuItemSingleEntity = MenuItemSingleEntity;
});
define("bruce-models/menu-item/menu-item", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("bruce-models/menu-item/menu-item-utils", ["require", "exports", "bruce-models/menu-item/menu-item-base", "bruce-models/menu-item/menu-item-bruce-entities", "bruce-models/menu-item/menu-item-arbitrary-tileset", "bruce-models/menu-item/menu-item-single-entity", "bruce-models/menu-item/menu-item-model-tileset"], function (require, exports, menu_item_base_6, menu_item_bruce_entities_1, menu_item_arbitrary_tileset_1, menu_item_single_entity_1, menu_item_model_tileset_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MenuItemUtils = void 0;
    class MenuItemUtils {
        /**
         * Returns menu item corresponding to provided item's type.
         * @param item
         */
        static MenuItemFromRaw(item) {
            switch (item === null || item === void 0 ? void 0 : item.Type) {
                case menu_item_base_6.MenuItemType.BruceEntity:
                    return new menu_item_bruce_entities_1.MenuItemBruceEntities(item);
                case menu_item_base_6.MenuItemType.ArbitraryTileset:
                    return new menu_item_arbitrary_tileset_1.MenuItemArbitraryTileset(item);
                case menu_item_base_6.MenuItemType.SingleEntity:
                    return new menu_item_single_entity_1.MenuItemSingleEntity(item);
                case menu_item_base_6.MenuItemType.ModelTileset:
                    return new menu_item_model_tileset_1.MenuItemModelTileset(item);
                default:
                    return new menu_item_base_6.MenuItemBase(item);
            }
        }
        /**
         * Returns array of menu items corresponding to their types.
         * @param items
         */
        static MenuItemsFromRaw(items) {
            let parsedItems = [];
            for (let i = 0; i < items.length; i++) {
                let rawItem = items[i];
                let parsedItem = MenuItemUtils.MenuItemFromRaw(rawItem);
                parsedItems.push(parsedItem);
            }
            return parsedItems;
        }
    }
    exports.MenuItemUtils = MenuItemUtils;
});
define("bruce-models/common/shadow-settings", ["require", "exports", "bruce-maps-widget"], function (require, exports, bruce_maps_widget_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ShadowSettings = void 0;
    class ShadowSettings {
        constructor(rawData) {
            this.IsShadowEnabled = true;
            this.IsShadowSoft = false;
            this.ShadowSampleSize = 1024;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                IsShadowEnabled: this.IsShadowEnabled,
                IsShadowSoft: this.IsShadowSoft,
                ShadowSampleSize: this.ShadowSampleSize
            };
            data = bruce_maps_widget_3.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.IsShadowEnabled != null) {
                this.IsShadowEnabled = rawData.IsShadowEnabled;
            }
            if (rawData.IsShadowSoft != null) {
                this.IsShadowSoft = rawData.IsShadowSoft;
            }
            if (rawData.ShadowSampleSize != null) {
                this.ShadowSampleSize = +rawData.ShadowSampleSize;
            }
        }
    }
    exports.ShadowSettings = ShadowSettings;
});
define("bruce-models/project-view/project-view-settings-shadows", ["require", "exports", "bruce-maps-widget", "bruce-models/common/shadow-settings"], function (require, exports, bruce_maps_widget_4, shadow_settings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectViewSettingsShadows = void 0;
    /**
     * Settings describing the quality of shadows for when camera is moving and static.
     */
    class ProjectViewSettingsShadows {
        constructor(rawData) {
            this.MovingCamera = new shadow_settings_1.ShadowSettings(null);
            this.Update(rawData);
            if (!this.StaticCamera) {
                this.StaticCamera = new shadow_settings_1.ShadowSettings(null);
                this.StaticCamera.ShadowSampleSize = 4096;
                this.StaticCamera.IsShadowSoft = false;
            }
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a, _b;
            let data = {
                StaticCamera: (_a = this.StaticCamera) === null || _a === void 0 ? void 0 : _a.JSON,
                MovingCamera: (_b = this.MovingCamera) === null || _b === void 0 ? void 0 : _b.JSON
            };
            if (!data.StaticCamera) {
                delete data.StaticCamera;
            }
            if (!data.MovingCamera) {
                delete data.MovingCamera;
            }
            data = bruce_maps_widget_4.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new ProjectViewSettingsShadows(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.StaticCamera) {
                this.StaticCamera = new shadow_settings_1.ShadowSettings(rawData.StaticCamera);
            }
            if (rawData.MovingCamera) {
                this.MovingCamera = new shadow_settings_1.ShadowSettings(rawData.MovingCamera);
            }
        }
    }
    exports.ProjectViewSettingsShadows = ProjectViewSettingsShadows;
});
define("bruce-models/project-view/project-view-settings-ambient-occlusion", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectViewSettingsAmbientOcclusion = void 0;
    class ProjectViewSettingsAmbientOcclusion {
        constructor(rawData) {
            this.Enabled = false;
            this.Intensity = 3;
            this.Bias = 0.1;
            this.LengthCap = 0.03;
            this.StepSize = 1;
            this.BlurStep = 0.86;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                oa_enabled: this.Enabled,
                oa_intensity: this.Intensity,
                oa_bias: this.Bias,
                oa_lengthCap: this.LengthCap,
                oa_stepSize: this.StepSize,
                oa_blurStep: this.BlurStep
            };
            data = object_utils_26.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new ProjectViewSettingsAmbientOcclusion(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.oa_enabled != null) {
                this.Enabled = rawData.oa_enabled;
            }
            if (rawData.oa_intensity != null) {
                this.Intensity = +rawData.oa_intensity;
            }
            if (rawData.oa_bias != null) {
                this.Bias = +rawData.oa_bias;
            }
            if (rawData.oa_lengthCap != null) {
                this.LengthCap = +rawData.oa_lengthCap;
            }
            if (rawData.oa_stepSize != null) {
                this.StepSize = +rawData.oa_stepSize;
            }
            if (rawData.oa_blurStep != null) {
                this.BlurStep = +rawData.oa_blurStep;
            }
        }
    }
    exports.ProjectViewSettingsAmbientOcclusion = ProjectViewSettingsAmbientOcclusion;
});
define("bruce-models/tileset/tileset-entities-map-settings", ["require", "exports", "utils/object-utils", "bruce-models/common/boundaries"], function (require, exports, object_utils_27, boundaries_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetEntitiesMapSettings = exports.ETilesetEntitiesMapImageSize = void 0;
    var ETilesetEntitiesMapImageSize;
    (function (ETilesetEntitiesMapImageSize) {
        ETilesetEntitiesMapImageSize[ETilesetEntitiesMapImageSize["IMG_256"] = 256] = "IMG_256";
        ETilesetEntitiesMapImageSize[ETilesetEntitiesMapImageSize["IMG_512"] = 512] = "IMG_512";
        ETilesetEntitiesMapImageSize[ETilesetEntitiesMapImageSize["IMG_1024"] = 1024] = "IMG_1024";
        ETilesetEntitiesMapImageSize[ETilesetEntitiesMapImageSize["IMG_2048"] = 2048] = "IMG_2048";
    })(ETilesetEntitiesMapImageSize = exports.ETilesetEntitiesMapImageSize || (exports.ETilesetEntitiesMapImageSize = {}));
    class TilesetEntitiesMapSettings {
        constructor(rawData) {
            this.imageSize = ETilesetEntitiesMapImageSize.IMG_256;
            this.levelMin = 10;
            this.levelMax = 12;
            this.styleId = 0;
            this.filter = {};
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a;
            let data = {
                imageSize: this.imageSize,
                levelMin: this.levelMin,
                levelMax: this.levelMax,
                filter: this.filter,
                styleId: this.styleId,
                entityTypeId: this.entityTypeId,
                boundaries: (_a = this.boundaries) === null || _a === void 0 ? void 0 : _a.JSON
            };
            data = object_utils_27.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new TilesetEntitiesMapSettings(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.imageSize != null) {
                this.imageSize = rawData.imageSize;
            }
            if (rawData.levelMin != null) {
                this.levelMin = rawData.levelMin;
            }
            if (rawData.levelMax != null) {
                this.levelMax = rawData.levelMax;
            }
            if (rawData.filter != null) {
                this.filter = rawData.filter;
            }
            if (rawData.styleId != null) {
                this.styleId = rawData.styleId;
            }
            if (rawData.entityTypeId != null) {
                this.entityTypeId = rawData.entityTypeId;
            }
            if (rawData.boundaries != null) {
                this.boundaries = new boundaries_3.Boundaries(rawData.boundaries);
            }
        }
    }
    exports.TilesetEntitiesMapSettings = TilesetEntitiesMapSettings;
});
define("bruce-models/tileset/tileset-entity-lod", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("bruce-models/tileset/tileset-entities-set-settings", ["require", "exports", "utils/object-utils", "bruce-models/common/altitude-options", "bruce-models/common/boundaries"], function (require, exports, object_utils_28, altitude_options_1, boundaries_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetEntitiesSetSettings = void 0;
    class TilesetEntitiesSetSettings {
        constructor(rawData) {
            // Total must equal 100%.
            // This dictates what LOD the graphic should use.
            // TODO: Why is this needed? Shouldn't this just be array of lod keys without percents?
            this.zoomControl = [{ lodKey: "GLB/0", percent: 100 }];
            // How to interpret entity altitude values.
            this.altitudeRefType = altitude_options_1.EAltitudeOptionStr.ClampToGround;
            // If double sided rendering should be enabled for produced models.
            this.doubleSided = false;
            // Style to override entity type default style with.
            this.styleId = 0;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a;
            let data = {
                zoomControl: this.zoomControl,
                altitudeRefType: this.altitudeRefType,
                boundaries: (_a = this.boundaries) === null || _a === void 0 ? void 0 : _a.JSON,
                doubleSided: this.doubleSided,
                entityTypeId: this.entityTypeId,
                filter: this.filter,
                styleId: this.styleId,
                terrainSource: this.terrainSource,
                terrainUri: this.terrainUri
            };
            data = object_utils_28.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new TilesetEntitiesSetSettings(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.altitudeRefType != null) {
                this.altitudeRefType = rawData.altitudeRefType;
            }
            if (rawData.boundaries != null) {
                this.boundaries = new boundaries_4.Boundaries(rawData.boundaries);
            }
            if (rawData.doubleSided != null) {
                this.doubleSided = rawData.doubleSided;
            }
            if (rawData.entityTypeId != null) {
                this.entityTypeId = rawData.entityTypeId;
            }
            if (rawData.filter != null) {
                this.filter = rawData.filter;
            }
            if (rawData.styleId != null) {
                this.styleId = rawData.styleId;
            }
            if (rawData.terrainSource != null) {
                this.terrainSource = rawData.terrainSource;
            }
            if (rawData.terrainUri != null) {
                this.terrainUri = rawData.terrainUri;
            }
            if (rawData.zoomControl != null) {
                this.zoomControl = rawData.zoomControl;
            }
        }
    }
    exports.TilesetEntitiesSetSettings = TilesetEntitiesSetSettings;
});
define("bruce-models/tileset/tileset-external-geo-map-settings", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_29) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetExternalGeoMapSettings = exports.ETilesetExternalMapType = void 0;
    var ETilesetExternalMapType;
    (function (ETilesetExternalMapType) {
        ETilesetExternalMapType["TileMapImagery"] = "TileMapImagery";
        ETilesetExternalMapType["OpenStreetMapImagery"] = "OpenStreetMapImagery";
        ETilesetExternalMapType["MapBoxImagery"] = "MapBoxImagery";
        ETilesetExternalMapType["CesiumIon"] = "CesiumIon";
    })(ETilesetExternalMapType = exports.ETilesetExternalMapType || (exports.ETilesetExternalMapType = {}));
    class TilesetExternalGeoMapSettings {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                url: this.url,
                ionId: this.ionId,
                mapBoxAccount: this.mapBoxAccount,
                mapBoxKey: this.mapBoxKey,
                mapBoxStyleId: this.mapBoxStyleId,
                mapType: this.mapType,
                sourceExt: this.sourceExt
            };
            data = object_utils_29.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new TilesetExternalGeoMapSettings(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.url != null) {
                this.url = rawData.url;
            }
            if (rawData.ionId != null) {
                this.ionId = rawData.ionId;
            }
            if (rawData.mapBoxAccount != null) {
                this.mapBoxAccount = rawData.mapBoxAccount;
            }
            if (rawData.mapBoxKey != null) {
                this.mapBoxKey = rawData.mapBoxKey;
            }
            if (rawData.mapBoxStyleId != null) {
                this.mapBoxStyleId = rawData.mapBoxStyleId;
            }
            if (rawData.mapType != null) {
                this.mapType = rawData.mapType;
            }
            if (rawData.sourceExt != null) {
                this.sourceExt = rawData.sourceExt;
            }
        }
    }
    exports.TilesetExternalGeoMapSettings = TilesetExternalGeoMapSettings;
});
define("bruce-models/tileset/tileset-external-geo-terrain-settings", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_30) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetExternalGeoTerrainSettings = void 0;
    class TilesetExternalGeoTerrainSettings {
        constructor(rawData) {
            // If additional lighting information should be requested when loading tileset.
            this.requestVertexNormals = false;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                requestVertexNormals: this.requestVertexNormals,
                url: this.url
            };
            data = object_utils_30.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new TilesetExternalGeoTerrainSettings(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.requestVertexNormals != null) {
                this.requestVertexNormals = rawData.requestVertexNormals;
            }
            if (rawData.url != null) {
                this.url = rawData.url;
            }
        }
    }
    exports.TilesetExternalGeoTerrainSettings = TilesetExternalGeoTerrainSettings;
});
define("bruce-models/tileset/tileset-geo-map-settings", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_31) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetGeoMapSettings = void 0;
    class TilesetGeoMapSettings {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                sourceFileId: this.sourceFileId,
                imageSize: this.imageSize,
                levelMin: this.levelMin,
                levelMax: this.levelMax
            };
            data = object_utils_31.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new TilesetGeoMapSettings(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.sourceFileId != null) {
                this.sourceFileId = rawData.sourceFileId;
            }
            if (rawData.imageSize != null) {
                this.imageSize = rawData.imageSize;
            }
            if (rawData.levelMin != null) {
                this.levelMin = rawData.levelMin;
            }
            if (rawData.levelMax != null) {
                this.levelMax = rawData.levelMax;
            }
        }
    }
    exports.TilesetGeoMapSettings = TilesetGeoMapSettings;
});
define("bruce-models/tileset/tileset-geo-terrain-settings", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_32) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetGeoTerrainSettings = void 0;
    class TilesetGeoTerrainSettings {
        constructor(rawData) {
            this.startLevel = 19;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                sourceFileId: this.sourceFileId,
                startLevel: this.startLevel
            };
            data = object_utils_32.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new TilesetGeoTerrainSettings(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.sourceFileId != null) {
                this.sourceFileId = rawData.sourceFileId;
            }
            if (rawData.startLevel != null) {
                this.startLevel = rawData.startLevel;
            }
        }
    }
    exports.TilesetGeoTerrainSettings = TilesetGeoTerrainSettings;
});
define("bruce-models/tileset/tileset-transform", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_33) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetTransform = void 0;
    class TilesetTransform {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                heading: this.heading,
                pitch: this.pitch,
                roll: this.roll,
                scale: this.scale
            };
            data = object_utils_33.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new TilesetTransform(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.heading != null) {
                this.heading = rawData.heading;
            }
            if (rawData.pitch != null) {
                this.pitch = rawData.pitch;
            }
            if (rawData.roll != null) {
                this.roll = rawData.roll;
            }
            if (rawData.scale != null) {
                this.scale = rawData.scale;
            }
        }
    }
    exports.TilesetTransform = TilesetTransform;
});
define("bruce-models/tileset/tileset-model-settings", ["require", "exports", "utils/object-utils", "bruce-models/common/cartographic", "bruce-models/tileset/tileset", "bruce-models/tileset/tileset-transform"], function (require, exports, object_utils_34, cartographic_4, tileset_1, tileset_transform_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetModelSettings = void 0;
    class TilesetModelSettings {
        constructor(rawData) {
            // What style to use in generation. 0 = default entity type style.
            this.styleId = 0;
            // lodKey is <LOD_TYPE>/<LOD_LEVEL> eg: GLB/0.
            this.lodKey = "GLB/0";
            // Where to move the pivot point. This will be center of tileset.
            this.movePivot = tileset_1.ETilesetPivot.None;
            // Record id for UCS used when pivot is set to UCS.
            this.ucsId = 0;
            // Currently unused. Possibly deprecated.
            this.epsg = 0;
            // Apply double sided rendering.
            this.doubleSided = true;
            // Size in bytes of b3dm files to generate. Default is 3mb.
            this.b3dmFileSize = 3072 * 1024;
            // The maximum screen space error used to drive level of detail refinement.
            this.maximumScreenSpaceError = 4.52;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                rootEntityId: this.rootEntityId,
                lodKey: this.lodKey,
                movePivot: this.movePivot,
                thumbFileId: this.thumbFileId,
                location: this.location,
                transform: this.transform,
                doubleSided: this.doubleSided,
                entityTypeId: this.entityTypeId,
                styleId: this.styleId,
                b3dmFileSize: this.b3dmFileSize,
                epsg: this.epsg,
                maximumScreenSpaceError: this.maximumScreenSpaceError,
                ucsId: this.ucsId,
                offset: this.offset
            };
            data = object_utils_34.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new TilesetModelSettings(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.rootEntityId != null) {
                this.rootEntityId = rawData.rootEntityId;
            }
            if (rawData.lodKey != null) {
                this.lodKey = rawData.lodKey;
            }
            if (rawData.movePivot != null) {
                this.movePivot = rawData.movePivot;
            }
            if (rawData.thumbFileId != null) {
                this.thumbFileId = rawData.thumbFileId;
            }
            if (rawData.location != null) {
                this.location = new cartographic_4.Cartographic(rawData.location);
            }
            if (rawData.transform != null) {
                this.transform = new tileset_transform_1.TilesetTransform(rawData.transform);
            }
            if (rawData.doubleSided != null) {
                this.doubleSided = rawData.doubleSided;
            }
            if (rawData.entityTypeId != null) {
                this.entityTypeId = rawData.entityTypeId;
            }
            if (rawData.styleId != null) {
                this.styleId = rawData.styleId;
            }
            if (rawData.b3dmFileSize != null) {
                this.b3dmFileSize = rawData.b3dmFileSize;
            }
            if (rawData.epsg != null) {
                this.epsg = rawData.epsg;
            }
            if (rawData.maximumScreenSpaceError != null) {
                this.maximumScreenSpaceError = rawData.maximumScreenSpaceError;
            }
            if (rawData.ucsId != null) {
                this.ucsId = rawData.ucsId;
            }
            if (rawData.offset != null) {
                this.offset = rawData.offset;
            }
        }
    }
    exports.TilesetModelSettings = TilesetModelSettings;
});
define("bruce-models/tileset/tileset-pointcloud-settings", ["require", "exports", "utils/object-utils", "bruce-models/common/cartographic", "bruce-models/tileset/tileset", "bruce-models/tileset/tileset-transform"], function (require, exports, object_utils_35, cartographic_5, tileset_2, tileset_transform_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetPointCloudSettings = void 0;
    class TilesetPointCloudSettings {
        constructor(rawData) {
            // How generated graphics are positioned.
            this.movePivot = tileset_2.ETilesetPivot.None;
            // Rendering setting for enabling attenuation.
            this.attenuation = false;
            // Rendering setting for scaling size of attenuation.
            this.attenuationMax = 4;
            // The maximum screen space error used to drive level of detail refinement.
            this.maximumScreenSpaceError = 4.52;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a, _b;
            let data = {
                sourceFileIds: this.sourceFileIds,
                location: (_a = this.location) === null || _a === void 0 ? void 0 : _a.JSON,
                transform: (_b = this.transform) === null || _b === void 0 ? void 0 : _b.JSON,
                pntFileSize: this.pntFileSize,
                epsg: this.epsg,
                attenuation: this.attenuation,
                attenuationMax: this.attenuationMax,
                movePivot: this.movePivot,
                maximumScreenSpaceError: this.maximumScreenSpaceError
            };
            data = object_utils_35.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new TilesetPointCloudSettings(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.sourceFileIds != null) {
                this.sourceFileIds = rawData.sourceFileIds;
            }
            if (rawData.location != null) {
                this.location = new cartographic_5.Cartographic(rawData.location);
            }
            if (rawData.transform != null) {
                this.transform = new tileset_transform_2.TilesetTransform(rawData.transform);
            }
            if (rawData.pntFileSize != null) {
                this.pntFileSize = rawData.pntFileSize;
            }
            if (rawData.epsg != null) {
                this.epsg = rawData.epsg;
            }
            if (rawData.attenuation != null) {
                this.attenuation = rawData.attenuation;
            }
            if (rawData.attenuationMax != null) {
                this.attenuationMax = rawData.attenuationMax;
            }
            if (rawData.movePivot != null) {
                this.movePivot = rawData.movePivot;
            }
            if (rawData.maximumScreenSpaceError != null) {
                this.maximumScreenSpaceError = rawData.maximumScreenSpaceError;
            }
        }
    }
    exports.TilesetPointCloudSettings = TilesetPointCloudSettings;
});
define("bruce-models/tileset/tileset", ["require", "exports", "bruce-maps-widget", "utils/object-utils", "bruce-models/common/utc", "bruce-models/tileset/tileset-entities-map-settings", "bruce-models/tileset/tileset-entities-set-settings", "bruce-models/tileset/tileset-external-geo-map-settings", "bruce-models/tileset/tileset-external-geo-terrain-settings", "bruce-models/tileset/tileset-geo-map-settings", "bruce-models/tileset/tileset-geo-terrain-settings", "bruce-models/tileset/tileset-model-settings", "bruce-models/tileset/tileset-pointcloud-settings"], function (require, exports, bruce_maps_widget_5, object_utils_36, utc_7, tileset_entities_map_settings_1, tileset_entities_set_settings_1, tileset_external_geo_map_settings_1, tileset_external_geo_terrain_settings_1, tileset_geo_map_settings_1, tileset_geo_terrain_settings_1, tileset_model_settings_1, tileset_pointcloud_settings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tileset = exports.ETilesetFilePrefix = exports.ETilesetType = exports.ETilesetPivot = void 0;
    var ETilesetPivot;
    (function (ETilesetPivot) {
        // Does not move the pivot (stays at 0,0,0 of tileset).
        ETilesetPivot["None"] = "none";
        // Moves the pivot to the center of bounding box.
        ETilesetPivot["Box"] = "box";
        // Moves the pivot to graphical weight.
        ETilesetPivot["Weight"] = "weight";
        // Moves the pivot by specified UCS offset (ucs property is used to load UCS record).
        ETilesetPivot["UCS"] = "ucs";
    })(ETilesetPivot = exports.ETilesetPivot || (exports.ETilesetPivot = {}));
    var ETilesetType;
    (function (ETilesetType) {
        ETilesetType["PointCloud"] = "POINT_CLOUD";
        ETilesetType["GeoMap"] = "GEO_MAP";
        ETilesetType["EntitiesMap"] = "ENTITIES_MAP";
        ETilesetType["EntitiesSet"] = "ENTITIES_SET";
        ETilesetType["Model"] = "MODEL";
        ETilesetType["Terrain"] = "GEO_TERR";
        ETilesetType["ExternalTerrain"] = "EXTERNAL_TERR";
        ETilesetType["ExternalGeoMap"] = "EXTERNAL_MAP";
    })(ETilesetType = exports.ETilesetType || (exports.ETilesetType = {}));
    /**
     * Common file prefixes for uploading and requesting files for various purposes.
     */
    var ETilesetFilePrefix;
    (function (ETilesetFilePrefix) {
        ETilesetFilePrefix["Import"] = "src";
        ETilesetFilePrefix["GET"] = "files";
        ETilesetFilePrefix["GET_OLD"] = "res";
    })(ETilesetFilePrefix = exports.ETilesetFilePrefix || (exports.ETilesetFilePrefix = {}));
    class Tileset {
        constructor(rawData) {
            // For tilesets that can be generated/regenerated this is indicator of version.
            this.generateVersion = 0;
            // If deletion of this tileset is locked.
            this.isDeleteDisabled = false;
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns raw data for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a, _b, _c;
            let data = Object.assign(Object.assign({}, this.raw), { id: this.id, name: this.name, type: this.type, rootFileName: this.rootFileName, settings: (_a = this.settings) === null || _a === void 0 ? void 0 : _a.JSON, fileIds: this.fileIds, creationTime: (_b = this.creationTime) === null || _b === void 0 ? void 0 : _b.JSON, modificationTime: (_c = this.modificationTime) === null || _c === void 0 ? void 0 : _c.JSON, generateVersion: this.generateVersion, isDeleteDisabled: this.isDeleteDisabled });
            data = object_utils_36.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new Tileset(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.id != null) {
                this.id = rawData.id;
            }
            if (rawData.name != null) {
                this.name = rawData.name;
            }
            if (rawData.rootFileName != null) {
                this.rootFileName = rawData.rootFileName;
            }
            if (rawData.type != null) {
                this.type = rawData.type;
            }
            if (rawData.fileIds != null) {
                this.fileIds = rawData.fileIds;
            }
            if (rawData.creationTime != null) {
                if (rawData.creationTime instanceof utc_7.UTC) {
                    this.creationTime = rawData.creationTime;
                }
                else {
                    this.creationTime = new utc_7.UTC(rawData.creationTime);
                }
            }
            if (rawData.modificationTime != null) {
                if (rawData.modificationTime instanceof utc_7.UTC) {
                    this.modificationTime = rawData.modificationTime;
                }
                else {
                    this.modificationTime = new utc_7.UTC(rawData.modificationTime);
                }
            }
            if (rawData.generateVersion != null) {
                this.generateVersion = rawData.generateVersion;
            }
            if (rawData.isDeleteDisabled != null) {
                this.isDeleteDisabled = rawData.isDeleteDisabled;
            }
            if (rawData.settings != null) {
                if (this.settings) {
                    this.settings.Update(rawData.settings);
                }
                else {
                    switch (this.type) {
                        case ETilesetType.PointCloud:
                            this.settings = new tileset_pointcloud_settings_1.TilesetPointCloudSettings(rawData.settings);
                            break;
                        case ETilesetType.GeoMap:
                            this.settings = new tileset_geo_map_settings_1.TilesetGeoMapSettings(rawData.settings);
                            break;
                        case ETilesetType.EntitiesMap:
                            this.settings = new tileset_entities_map_settings_1.TilesetEntitiesMapSettings(rawData.settings);
                            break;
                        case ETilesetType.Model:
                            this.settings = new tileset_model_settings_1.TilesetModelSettings(rawData.settings);
                            break;
                        case ETilesetType.Terrain:
                            this.settings = new tileset_geo_terrain_settings_1.TilesetGeoTerrainSettings(rawData.settings);
                            break;
                        case ETilesetType.ExternalGeoMap:
                            this.settings = new tileset_external_geo_map_settings_1.TilesetExternalGeoMapSettings(rawData.settings);
                            break;
                        case ETilesetType.ExternalTerrain:
                            this.settings = new tileset_external_geo_terrain_settings_1.TilesetExternalGeoTerrainSettings(rawData.settings);
                            break;
                        case ETilesetType.EntitiesSet:
                            this.settings = new tileset_entities_set_settings_1.TilesetEntitiesSetSettings(rawData.settings);
                            break;
                    }
                }
            }
        }
        /**
         * Saves current instance to DB or creates new instance using current settings.
         * In the case of a new tileset record being made, the ID will be generated.
         * @param isNew pass NULL if unsure. This will cause a check for you.
         */
        SaveUpdate(api, isNew) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isNew == null) {
                    try {
                        let tileset = yield Tileset.GetByID(api, this.id);
                        isNew = !tileset;
                    }
                    catch (_a) {
                        isNew = true;
                    }
                }
                if (isNew) {
                    yield this.createRecord(api);
                }
                yield this.saveRecord(api);
                return this;
            });
        }
        /**
         * Creates new tileset record and returns updated version of current instance.
         * @param api
         */
        createRecord(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let encodedName = bruce_maps_widget_5.AbstractAPI.Encode(this.name);
                let data = yield api.GET(`tileset/new?type=${this.type}&name=${encodedName}`);
                if (data) {
                    this.id = data.id;
                }
            });
        }
        /**
         * Saves current instance to DB.
         * @param api
         */
        saveRecord(api) {
            return __awaiter(this, void 0, void 0, function* () {
                yield api.POST("tileset/update/" + this.id, JSON.stringify(this.JSON));
            });
        }
        /**
         * Deletes the DB record corresponding to current instance.
         * @param api
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                yield api.DELETE("tileset/delete/" + this.id);
            });
        }
        /**
         * Uploads given file data to tileset.
         * @param api
         * @param blob
         * @param progress
         * @param onError
         */
        UploadFile(api, blob, progress = null, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.UPLOAD("tileset/uploadFile/" + this.id + "/" + ETilesetFilePrefix.GET, blob, progress, onError);
            });
        }
        /**
         * Uploads a given file to use for import process on this tileset.
         * @param api
         * @param blob
         * @param progress
         * @param onError
         */
        UploadFileForImport(api, blob, progress = null, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.UPLOAD("tileset/uploadFile/" + this.id + "/" + ETilesetFilePrefix.Import, blob, progress, onError);
            });
        }
        /**
         * Deletes file by id from tileset.
         * @param api
         * @param fileId
         * @returns
         */
        DeleteFile(api, fileId) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.DELETE("tileset/deleteFile/" + this.id + `/${ETilesetFilePrefix.GET}/` + fileId);
            });
        }
        /**
         * Starts tileset generation.
         * Warning: Not every tileset type supports generation.
         * @returns: pending action ID to monitor.
         */
        StartGeneration(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let response = yield api.GET("tileset/generate/" + this.id);
                return response === null || response === void 0 ? void 0 : response.ID;
            });
        }
        /**
         * Deletes file being used in tileset import by id.
         * @param api
         * @param fileId
         * @returns
         */
        DeleteFileFromImport(api, fileId) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.DELETE("tileset/deleteFile/" + this.id + `/${ETilesetFilePrefix.Import}/` + fileId);
            });
        }
        /**
         * Returns file URL by id.
         * @param api
         * @param fileId
         */
        getFileURL(api, fileId) {
            return this.getFileBaseURL(api) + fileId;
        }
        /**
         * Returns base URL for getting files (with session requirement).
         * @param api
         */
        getFileBaseURL(api) {
            return api.BRUCE_URL + "tileset/getFile/" + this.id + `/${ETilesetFilePrefix.GET}/`;
        }
        /**
         * Returns file URL for tileset import file by id.
         * @param api
         * @param fileId
         */
        getFileForImportURL(api, fileId) {
            return api.BRUCE_URL + "tileset/getFile/" + this.id + `/${ETilesetFilePrefix.Import}/` + fileId;
        }
        /**
         * Returns file URL, similar to getFileURL method but without session requirements.
         * @param api
         * @param filePath
         */
        getPublicFileURL(api, filePath) {
            return this.getPublicBaseURL(api) + filePath;
        }
        /**
         * Returns base URL to public file request.
         * @param api
         */
        getPublicBaseURL(api) {
            return api.BRUCE_URL + "tileset/file/" + this.id + "/";
        }
        /**
         * Returns list of basic information about all tilesets available.
         * @param api
         */
        static GetList(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET("tileset/getList");
                if (data) {
                    return data;
                }
                return [];
            });
        }
        /**
         * @param api
         * @param id
         * @param noFiles
         * @returns: tileset record corresponding to given id.
         */
        static GetByID(api, id, noFiles = false) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET("tileset/get/" + id + "?noFiles=" + (noFiles ? 1 : 0));
                if (data) {
                    return new Tileset(data);
                }
                return null;
            });
        }
    }
    exports.Tileset = Tileset;
});
define("bruce-models/project-view/project-view-settings", ["require", "exports", "bruce-models/common/camera-position", "bruce-models/menu-item/menu-item-utils", "utils/object-utils", "bruce-models/project-view/project-view-settings-shadows", "bruce-models/project-view/project-view-settings-ambient-occlusion"], function (require, exports, camera_position_2, menu_item_utils_2, object_utils_37, project_view_settings_shadows_1, project_view_settings_ambient_occlusion_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectViewSettings = void 0;
    class ProjectViewSettings {
        constructor(rawData) {
            // The default globe colour to apply for this view.
            this.GlobeColor = "rgb(24, 42, 58)";
            // Array of available menu items.
            this.MenuItems = [];
            // Panels that are enabled for the left central panel.
            this.LeftPanelComponents = [];
            // Panels that are enabled for the top central panel.
            this.TopPanelComponents = [];
            // Ambient occlusion settings for this view.
            this.OASettings = new project_view_settings_ambient_occlusion_1.ProjectViewSettingsAmbientOcclusion(null);
            // Shadow settings for this view.
            this.Shadow = new project_view_settings_shadows_1.ProjectViewSettingsShadows(null);
            // If fast approximate anti-aliasing is enabled.
            this.PostProcessFXAA = true;
            this.Update(rawData);
        }
        /**
         * Returns raw JSON data using current instance data.
         */
        get JSON() {
            var _a, _b, _c;
            let data = {
                Camera: (_a = this.Camera) === null || _a === void 0 ? void 0 : _a.JSON,
                DefaultMapTiles: this.DefaultMapTiles,
                DefaultTerrain: this.DefaultTerrain,
                IsLoginRequired: this.IsLoginRequired,
                IsRestricted: this.IsRestricted,
                IsEntityTypeDataPreload: this.IsEntityTypeDataPreload,
                LogoImage: this.LogoImage,
                LegendImage: this.LegendImage,
                GroundOcclusion: this.GroundOcclusion,
                DisplayTimeline: this.DisplayTimeline,
                LayersMenu: this.MenuItems ? this.MenuItems.map(x => x.JSON) : null,
                OASettings: (_b = this.OASettings) === null || _b === void 0 ? void 0 : _b.JSON,
                GlobeColor: this.GlobeColor,
                SelectionHighlightColor: this.SelectionHighlightColor,
                ControlsSettings: this.ControlsSettings,
                AuthoringsEnabled: this.AuthoringsEnabled,
                CesiumMapSources: this.CesiumMapSources,
                CesiumTerrainSources: this.CesiumTerrainSources,
                Shadows: this.Shadows,
                CameraFrustum: this.CameraFrustum,
                BookmarkTransitionSpeed: this.BookmarkTransitionSpeed,
                CustomFormSettings: this.CustomFormSettings,
                Shadow: (_c = this.Shadow) === null || _c === void 0 ? void 0 : _c.JSON,
                TilesetBackfaceCulling: this.TilesetBackfaceCulling,
                TopPanelComponents: this.TopPanelComponents,
                LeftPanelComponents: this.LeftPanelComponents,
                Extensions: this.Extensions,
                PostProcessFXAA: this.PostProcessFXAA,
                Imagery: this.Imagery,
                Terrain: this.Terrain
            };
            data = object_utils_37.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.AuthoringsEnabled != null) {
                this.AuthoringsEnabled = rawData.AuthoringsEnabled;
            }
            if (rawData.BookmarkTransitionSpeed != null) {
                this.BookmarkTransitionSpeed = rawData.BookmarkTransitionSpeed;
            }
            if (rawData.Camera != null) {
                this.Camera = new camera_position_2.CameraPosition(rawData.Camera);
            }
            if (rawData.CameraFrustum != null) {
                this.CameraFrustum = rawData.CameraFrustum;
            }
            if (rawData.CesiumMapSources != null) {
                this.CesiumMapSources = rawData.CesiumMapSources;
            }
            if (rawData.CesiumTerrainSources != null) {
                this.CesiumTerrainSources = rawData.CesiumTerrainSources;
            }
            if (rawData.ControlsSettings != null) {
                this.ControlsSettings = rawData.ControlsSettings;
            }
            if (rawData.CustomFormSettings != null) {
                this.CustomFormSettings = rawData.CustomFormSettings;
            }
            if (rawData.DefaultMapTiles != null) {
                this.DefaultMapTiles = rawData.DefaultMapTiles;
            }
            if (rawData.DefaultTerrain != null) {
                this.DefaultTerrain = rawData.DefaultTerrain;
            }
            if (rawData.DisplayTimeline != null) {
                this.DisplayTimeline = rawData.DisplayTimeline;
            }
            if (rawData.Extensions != null) {
                this.Extensions = rawData.Extensions;
            }
            if (rawData.GlobeColor != null) {
                this.GlobeColor = rawData.GlobeColor;
            }
            if (rawData.IsEntityTypeDataPreload != null) {
                this.IsEntityTypeDataPreload = rawData.IsEntityTypeDataPreload;
            }
            if (rawData.IsLoginRequired != null) {
                this.IsLoginRequired = rawData.IsLoginRequired;
            }
            if (rawData.IsRestricted != null) {
                this.IsRestricted = rawData.IsRestricted;
            }
            if (rawData.LayersMenu != null) {
                this.MenuItems = menu_item_utils_2.MenuItemUtils.MenuItemsFromRaw(rawData.LayersMenu);
            }
            if (rawData.LeftPanelComponents != null) {
                this.LeftPanelComponents = rawData.LeftPanelComponents;
            }
            if (rawData.TopPanelComponents != null) {
                this.TopPanelComponents = rawData.TopPanelComponents;
            }
            if (rawData.LegendImage != null) {
                this.LegendImage = rawData.LegendImage;
            }
            if (rawData.LogoImage != null) {
                this.LogoImage = rawData.LogoImage;
            }
            if (rawData.OASettings != null) {
                this.OASettings = new project_view_settings_ambient_occlusion_1.ProjectViewSettingsAmbientOcclusion(rawData.OASettings);
            }
            if (rawData.SelectionHighlightColor != null) {
                this.SelectionHighlightColor = rawData.SelectionHighlightColor;
            }
            if (rawData.Shadow != null) {
                this.Shadow = new project_view_settings_shadows_1.ProjectViewSettingsShadows(rawData.Shadow);
            }
            if (rawData.TilesetBackfaceCulling != null) {
                this.TilesetBackfaceCulling = rawData.TilesetBackfaceCulling;
            }
            if (rawData.PostProcessFXAA != null) {
                this.PostProcessFXAA = rawData.PostProcessFXAA;
            }
            if (rawData.Imagery != null) {
                this.Imagery = rawData.Imagery;
            }
            if (rawData.Terrain != null) {
                this.Terrain = rawData.Terrain;
            }
        }
    }
    exports.ProjectViewSettings = ProjectViewSettings;
});
define("bruce-models/project-view/project-view", ["require", "exports", "utils/object-utils", "bruce-models/common/utc", "bruce-models/project-view/project-view-bookmark", "bruce-models/project-view/project-view-settings"], function (require, exports, object_utils_38, utc_8, project_view_bookmark_1, project_view_settings_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectView = void 0;
    class ProjectView {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a, _b;
            let data = {
                ID: this.ID,
                Name: this.Name,
                Description: this.Description,
                CreatedByUIVersion: this.CreatedByUIVersion,
                "CreatedByUser.ID": this["CreatedByUser.ID"],
                CreatedTime: (_a = this.CreatedTime) === null || _a === void 0 ? void 0 : _a.JSON,
                DefaultUISlideID: this.DefaultUISlideID,
                Settings: (_b = this.Settings) === null || _b === void 0 ? void 0 : _b.JSON,
                Feature: this.Feature
            };
            data = object_utils_38.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a clone of the current instance.
         */
        Clone() {
            let raw = this.JSON;
            let newData = new ProjectView(raw);
            return newData;
        }
        /**
         * Updates instance of this Project View using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.CreatedByUIVersion != null) {
                this.CreatedByUIVersion = rawData.CreatedByUIVersion;
            }
            if (rawData["CreatedByUser.ID"] != null) {
                this["CreatedByUser.ID"] = rawData["CreatedByUser.ID"];
            }
            if (rawData.CreatedTime != null) {
                this.CreatedTime = new utc_8.UTC(rawData.CreatedTime);
            }
            if (rawData["Default.UISlide"] != null) {
                this["Default.UISlide"] = new project_view_bookmark_1.ProjectViewBookmark(rawData["Default.UISlide"]);
            }
            if (rawData.Description != null) {
                this.Description = rawData.Description;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.Name != null) {
                this.Name = rawData.Name;
            }
            if (rawData.Settings != null) {
                this.Settings = new project_view_settings_1.ProjectViewSettings(rawData.Settings);
            }
            if (rawData.DefaultUISlideID != null) {
                this.DefaultUISlideID = rawData.DefaultUISlideID;
            }
            if (rawData.Feature != null) {
                this.Feature = rawData.Feature;
            }
        }
        /**
         * Returns all bookmarks associated with project view instance.
         * @param api
         */
        GetBookmarks(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return project_view_bookmark_1.ProjectViewBookmark.GetBookmarksForProjectView(api, this.ID);
            });
        }
        /**
         * Saves current instance to DB.
         * @param isNew pass NULL if unsure. This will cause a check for you.
         */
        SaveUpdate(api, isNew) {
            return __awaiter(this, void 0, void 0, function* () {
                if (isNew == null) {
                    let rec = ProjectView.GetByID(api, this.ID);
                    isNew = !rec;
                }
                let data = JSON.stringify(this.JSON);
                if (isNew) {
                    let res = yield api.post(api.BRUCE_URL + `ui.view/${this.ID}`, data);
                    this.Update(res);
                }
                else {
                    let res = yield api.put(api.BRUCE_URL + `ui.view/${this.ID}`, data);
                    this.Update(res);
                }
                return this;
            });
        }
        /**
         * Returns project view corresponding to given view id.
         * @param api
         * @param viewId
         */
        static GetByID(api, viewId) {
            return __awaiter(this, void 0, void 0, function* () {
                let rawData = yield api.get(api.BRUCE_URL + `ui.view/${viewId}`);
                if (rawData) {
                    return new ProjectView(rawData);
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Returns project views for a given api environment.
         * Project views will include only basic information describing them.
         * @param api
         */
        static GetList(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let views = [];
                let raw = yield api.get(api.BRUCE_URL + "ui.view/list");
                let rawItems = raw === null || raw === void 0 ? void 0 : raw.Items;
                if (rawItems) {
                    for (let i = 0; i < rawItems.length; i++) {
                        let rawItem = rawItems[i];
                        views.push(new ProjectView(rawItem));
                    }
                }
                return views;
            });
        }
    }
    exports.ProjectView = ProjectView;
});
define("api/bruce-api", ["require", "exports", "api/abstract-api", "utils/cache-control", "bruce-models/common/environment", "utils/limited-cache-control", "bruce-models/project-view/project-view"], function (require, exports, abstract_api_3, cache_control_1, environment_1, limited_cache_control_1, project_view_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceAPI = void 0;
    class BruceAPI extends abstract_api_3.AbstractAPI {
        constructor(environment, clientAccountId) {
            super("X-SessionID");
            this.environment = environment;
            this.clientAccountId = clientAccountId;
            // The limit is currently 1GB and for unknown cases 1MB.
            // Later we should have this be a setting determined from specs.
            this.entityCache = new limited_cache_control_1.LimitedCacheControl(1e+9, 1e+6);
            // The limit is 30MB. Unknown cases are 300 bytes.
            this.instanceIdCache = new limited_cache_control_1.LimitedCacheControl(1e+6 * 30, 300);
            this.bruceEntitySourceIdCache = new cache_control_1.CacheControl();
            // The limit is currently 1GB and for unknown cases 1MB.
            this.entityTypeCache = new limited_cache_control_1.LimitedCacheControl(1e+9, 1e+6);
            // The limit is 30MB and for unknown cases 1MB.
            this.styleCache = new limited_cache_control_1.LimitedCacheControl(1e+6 * 30, 1e+6);
            this.init();
        }
        /**
         * Returns bruce api instance corresponding to provided parameters.
         * @param environment
         * @param clientAccountId
         */
        static getInstance(environment, clientAccountId) {
            if (environment == null || clientAccountId == null) {
                throw ("Cannot create instance of bruce api without environment and clientAccountId");
            }
            let instances = BruceAPI._instances;
            let instance = instances.find(x => x.environment == environment && x.clientAccountId == clientAccountId);
            if (instance) {
                return instance;
            }
            else {
                let newInstance = new BruceAPI(environment, clientAccountId);
                BruceAPI._instances.push(newInstance);
                return newInstance;
            }
        }
        /**
         * Returns bruce api instance for production template account.
         */
        static getTemplateInstance() {
            return BruceAPI.getInstance(environment_1.EEnvironmentType.PROD, "template");
        }
        /**
         * Initializes the bruce api link.
         */
        init() {
            let base = "";
            switch (this.environment) {
                case environment_1.EEnvironmentType.DEV:
                    base = "https://${ClientAccount}.api.nextspace-dev.net/";
                    break;
                case environment_1.EEnvironmentType.STAGING:
                    base = "https://${ClientAccount}.api.nextspace-stg.net/";
                    break;
                case environment_1.EEnvironmentType.UAT:
                    base = "https://${ClientAccount}.api.nextspace-uat.net/";
                    break;
                case environment_1.EEnvironmentType.PROD:
                    base = "https://${ClientAccount}.api.nextspace.host/";
                    break;
                default:
                    base = "https://${ClientAccount}.api.nextspace-dev.net/";
                    break;
            }
            base = base.replace("${ClientAccount}", this.clientAccountId);
            this.BRUCE_URL = base;
        }
        /**
         * Clears all cached information.
         */
        ClearCache() {
            this.entityCache.Clear();
            this.instanceIdCache.Clear();
            this.bruceEntitySourceIdCache.Clear();
            this.styleCache.Clear();
        }
        /**
         * Performs GET request with BruceAPI instance prefix.
         * @param url
         * @param onError
         */
        GET(url, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.get(this.BRUCE_URL + url, onError);
            });
        }
        /**
         * Performs POST request with BruceAPI instance prefix.
         * @param url
         * @param data
         * @param onError
         */
        POST(url, data, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.post(this.BRUCE_URL + url, data, onError);
            });
        }
        /**
         * Performs PUT request with BruceAPI instance prefix.
         * @param url
         * @param data
         * @param onError
         */
        PUT(url, data, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.put(this.BRUCE_URL + url, data, onError);
            });
        }
        /**
         * Performs DELETE request with BruceAPI instance prefix.
         * @param url
         * @param onError
         */
        DELETE(url, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.delete(this.BRUCE_URL + url, onError);
            });
        }
        /**
         * Performs POST UPLOAD request with BruceAPI instance prefix.
         * @param url
         * @param blob
         * @param progress
         * @param onError
         */
        UPLOAD(url, blob, progress = null, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.upload(this.BRUCE_URL + url, blob, progress, onError);
            });
        }
        /**
         * Performs POST UPLOAD FORM DATA request with BruceAPI instance prefix.
         * @param url
         * @param formData
         * @param progress
         * @param onError
         * @returns
         */
        UPLOAD_FORM_DATA(url, formData, progress = null, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.uploadFormData(this.BRUCE_URL + url, formData, progress, onError);
            });
        }
        /// Requests that need to be moved to models ///
        /**
         * Returns view settings correponding to a given id.
         * (These are now styles).
         * @param id
         */
        getViewSettings(id) {
            return __awaiter(this, void 0, void 0, function* () {
                const cacheData = this.styleCache.Get(id + "");
                if (cacheData) {
                    return cacheData;
                }
                const req = this.get(this.BRUCE_URL + `ui.entityDisplaySetting/${id}`);
                this.styleCache.Set(id + "", req);
                return req;
            });
        }
        /**
         * Returns the default view settings.
         * (Default style)
         */
        getDefaultViewSettings() {
            return __awaiter(this, void 0, void 0, function* () {
                return BruceAPI.getTemplateInstance().GET("ui.entityDisplaySetting/1");
            });
        }
        /**
         * Terrible method that fixes typescript compilation.
         * I hate compilers.
         */
        circularFix() {
            new project_view_1.ProjectView(null);
        }
    }
    exports.BruceAPI = BruceAPI;
    // Array of all unique instances.
    BruceAPI._instances = [];
});
define("bruce-models/common/mouse-event", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("entry-points/cesium/common/cesium-mouse-events", ["require", "exports", "cesium", "utils/bruce-event"], function (require, exports, Cesium, bruce_event_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumMouseEvents = void 0;
    Cesium = __importStar(Cesium);
    /**
     * Used to listen to cesium mouse events.
     */
    class CesiumMouseEvents {
        constructor(viewer) {
            // Event to subscribe to to receieve notifications about clicks in the 3d view.
            this.ClickEvent = new bruce_event_1.BruceEvent();
            // Event to subscribe to to receive notifications about middle-clicks in the 3d view.
            this.MiddleClickEvent = new bruce_event_1.BruceEvent();
            // Event to subscribe to to receive notifications about right-clicks in the 3d view.
            this.RightClickEvent = new bruce_event_1.BruceEvent();
            // Event to subscribe to to receive notifications about left-mouse-downs in the 3d view.
            this.LeftDownEvent = new bruce_event_1.BruceEvent();
            // Event to subscribe to to receive notifications about left-mouse-ups in the 3d view.
            this.LeftUpEvent = new bruce_event_1.BruceEvent();
            // Event to subscribe to to receive notifications about mouse-movement in the 3d view.
            this.MoveEvent = new bruce_event_1.BruceEvent();
            // Cesium event screen handler.
            this.cesiumEventHandler = null;
            this.viewer = viewer;
        }
        /**
         * Enables cesium event listeners.
         */
        EnableEventHandling() {
            if (!this.cesiumEventHandler) {
                let viewer = this.viewer;
                let canvas = viewer.canvas;
                if (!canvas) {
                    throw ("Viewer has no canvas reference. Has it been initialized?");
                }
                this.cesiumEventHandler = new Cesium.ScreenSpaceEventHandler(canvas);
                this.cesiumEventHandler.setInputAction((e) => {
                    this.ClickEvent.Trigger(e);
                }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
                this.cesiumEventHandler.setInputAction((e) => {
                    this.RightClickEvent.Trigger(e);
                }, Cesium.ScreenSpaceEventType.RIGHT_CLICK);
                this.cesiumEventHandler.setInputAction((e) => {
                    this.LeftDownEvent.Trigger(e);
                }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
                this.cesiumEventHandler.setInputAction((e) => {
                    this.LeftUpEvent.Trigger(e);
                }, Cesium.ScreenSpaceEventType.LEFT_UP);
                this.cesiumEventHandler.setInputAction((e) => {
                    this.MoveEvent.Trigger(e);
                }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                this.cesiumEventHandler.setInputAction((e) => {
                    this.MiddleClickEvent.Trigger(e);
                }, Cesium.ScreenSpaceEventType.MIDDLE_CLICK);
            }
        }
        /**
         * Removes cesium event listeners.
         */
        DisableEventHandling() {
            if (this.cesiumEventHandler) {
                this.cesiumEventHandler.destroy();
                this.cesiumEventHandler = null;
            }
        }
        /**
         * Disposes the mouse events.
         * @deprecated: Please use Dispose method.
         */
        dispose() {
            this.DisableEventHandling();
        }
        /**
         * Disposes the mouse event handler.
         */
        Dispose() {
            this.DisableEventHandling();
        }
    }
    exports.CesiumMouseEvents = CesiumMouseEvents;
});
define("entry-points/cesium/viewer/cesium-view-monitor", ["require", "exports", "cesium", "entry-points/common/view-monitor-ifs", "utils/bruce-event"], function (require, exports, Cesium, view_monitor_ifs_1, bruce_event_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumViewMonitor = void 0;
    Cesium = __importStar(Cesium);
    const TIME_LAG = 300;
    const POSITION_CHECK_TIMER = 950;
    const DEFAULT_GROUNDED_HEIGHT = 300;
    const MINUMUM_VIEW_AREA_SIZE_DEGREES = 0.01;
    const NET_STEP_PERCENT = 5;
    const BORDER_STEPS = 3;
    var SearchStatus;
    (function (SearchStatus) {
        SearchStatus[SearchStatus["LocationFound"] = 1] = "LocationFound";
        SearchStatus[SearchStatus["LocationChanged"] = 2] = "LocationChanged";
        SearchStatus[SearchStatus["LocationMissing"] = 3] = "LocationMissing";
    })(SearchStatus || (SearchStatus = {}));
    /**
     * This class monitors the view .
     */
    class CesiumViewMonitor {
        /**
         * The view monitor object.
         * @param viewer the cesium viewer
         */
        constructor(viewer) {
            this.disposed = false;
            // The emmited events.
            this._onPositionReady = new bruce_event_2.BruceEvent();
            this._viewer = viewer;
            this._positionElapsedTime = null;
            this._currentPOI = null;
            this._currentView = null;
            this._viewer.camera.percentageChanged = 0.5;
            this._positionTestTimer = setInterval(() => {
                this.Update();
            }, POSITION_CHECK_TIMER);
        }
        /**
         * Dispose.
         */
        Dispose() {
            this.disposed = true;
            clearInterval(this._positionTestTimer);
        }
        /**
         * New view center is ready
         * We now need to filter out movments in progress and take only the final position
         */
        NewPositionPending(lag) {
            if (this._positionElapsedTime) {
                clearTimeout(this._positionElapsedTime);
            }
            this._positionElapsedTime = setTimeout(() => {
                if (!this.disposed) {
                    this.NewPositionReady();
                }
            }, lag);
        }
        /**
         * Calculates the coordinates of intersection between:
         * - a ray comming from the camera and passing the screen cordinates.
         * - Terrain at the approximated height.
         */
        GetAdjustedGroundIntersectionOfCameraRay(screenCoordinates) {
            let camera = this._viewer.camera;
            let ray = camera.getPickRay(screenCoordinates);
            let intersection = this._viewer.scene.globe.pick(ray, this._viewer.scene);
            if (intersection) {
                return intersection;
            }
            return null;
        }
        /**
         * We scan  net of coordinates on our view to find the borders
         */
        NetScanViewForBoundaries() {
            let maxLong = -2 * Math.PI;
            let minLong = 2 * Math.PI;
            let maxLat = -2 * Math.PI;
            let minLat = 2 * Math.PI;
            let found = 0;
            let updateMinMaxForPoint = (stepX, stepY) => {
                let x = Math.round(0 + (this._viewer.container.clientWidth / 100) * (stepX * NET_STEP_PERCENT));
                let y = Math.round(0 + (this._viewer.container.clientHeight / 100) * (stepY * NET_STEP_PERCENT));
                let windowPosition = new Cesium.Cartesian2(x, y);
                try {
                    let intersection = this.GetAdjustedGroundIntersectionOfCameraRay(windowPosition);
                    if (intersection) {
                        let point = Cesium.Cartographic.fromCartesian(intersection, this._viewer.scene.globe.ellipsoid);
                        maxLong = Math.max(maxLong, point.longitude);
                        maxLat = Math.max(maxLat, point.latitude);
                        minLong = Math.min(minLong, point.longitude);
                        minLat = Math.min(minLat, point.latitude);
                        found++;
                    }
                }
                catch (_a) {
                }
            };
            // Outer circle.
            updateMinMaxForPoint(BORDER_STEPS, BORDER_STEPS);
            updateMinMaxForPoint((100 / NET_STEP_PERCENT) - BORDER_STEPS, BORDER_STEPS);
            updateMinMaxForPoint(BORDER_STEPS, (100 / NET_STEP_PERCENT) - BORDER_STEPS);
            updateMinMaxForPoint((100 / NET_STEP_PERCENT) - BORDER_STEPS, (100 / NET_STEP_PERCENT) - BORDER_STEPS);
            // Inner circle.
            updateMinMaxForPoint(BORDER_STEPS * 2, BORDER_STEPS * 2);
            updateMinMaxForPoint((100 / NET_STEP_PERCENT) - BORDER_STEPS * 2, BORDER_STEPS * 2);
            updateMinMaxForPoint(BORDER_STEPS * 2, (100 / NET_STEP_PERCENT) - BORDER_STEPS * 2);
            updateMinMaxForPoint((100 / NET_STEP_PERCENT) - BORDER_STEPS * 2, (100 / NET_STEP_PERCENT) - BORDER_STEPS * 2);
            if (found > 0) {
                let viewRect = new view_monitor_ifs_1.CBoundsRadians();
                viewRect.east = maxLong;
                viewRect.west = minLong;
                viewRect.north = maxLat;
                viewRect.south = minLat;
                return viewRect;
            }
            return null;
        }
        /**
         * Updates the current view and poi
         * returns: if the view amd POI was changed
         */
        UpdateCurrentViewAndPoi() {
            let viewRect = null;
            let center = null;
            let camera = this._viewer.camera;
            let terrainHeight = this._viewer.scene.globe.getHeight(camera.positionCartographic);
            let cameraPosition = this._viewer.camera.positionCartographic;
            /* we are almost at the ground, screw horizon, just load arround */
            if (terrainHeight && ((cameraPosition.height - terrainHeight) < DEFAULT_GROUNDED_HEIGHT)) {
                // View area calculation.
                viewRect = new view_monitor_ifs_1.CBoundsDegrees();
                let viewRectRad = this.NetScanViewForBoundaries();
                if (viewRectRad &&
                    viewRectRad.east &&
                    viewRectRad.west &&
                    viewRectRad.north &&
                    viewRectRad.south) {
                    viewRect.east = Cesium.Math.toDegrees(Math.max(viewRectRad.east, cameraPosition.longitude));
                    viewRect.west = Cesium.Math.toDegrees(Math.min(viewRectRad.west, cameraPosition.longitude));
                    viewRect.south = Cesium.Math.toDegrees(Math.min(viewRectRad.south, cameraPosition.latitude));
                    viewRect.north = Cesium.Math.toDegrees(Math.max(viewRectRad.north, cameraPosition.latitude));
                }
                else {
                    viewRect.east = cameraPosition.longitude;
                    viewRect.west = cameraPosition.longitude;
                    viewRect.south = cameraPosition.latitude;
                    viewRect.north = cameraPosition.latitude;
                }
                center = new view_monitor_ifs_1.CPointDegrees();
                center.latitude = Cesium.Math.toDegrees(camera.positionCartographic.latitude);
                center.longitude = Cesium.Math.toDegrees(camera.positionCartographic.longitude);
            }
            else {
                // View area calculation.
                let windowPosition = new Cesium.Cartesian2(this._viewer.container.clientWidth / 2, this._viewer.container.clientHeight / 2);
                let intersection = this.GetAdjustedGroundIntersectionOfCameraRay(windowPosition);
                let point = null;
                if (intersection) {
                    point = Cesium.Cartographic.fromCartesian(intersection, this._viewer.scene.globe.ellipsoid);
                }
                if (point) {
                    center = new view_monitor_ifs_1.CPointDegrees();
                    center.latitude = Cesium.Math.toDegrees(point.latitude);
                    center.longitude = Cesium.Math.toDegrees(point.longitude);
                    let viewRectRad = this.NetScanViewForBoundaries();
                    if (viewRectRad) {
                        viewRect = new view_monitor_ifs_1.CBoundsDegrees();
                        viewRect.east = Cesium.Math.toDegrees(viewRectRad.east);
                        viewRect.west = Cesium.Math.toDegrees(viewRectRad.west);
                        viewRect.south = Cesium.Math.toDegrees(viewRectRad.south);
                        viewRect.north = Cesium.Math.toDegrees(viewRectRad.north);
                    }
                }
            }
            // Minimal field of view.
            if (viewRect) {
                let centerLong = (viewRect.east + viewRect.west) / 2;
                let centerLat = (viewRect.north + viewRect.south) / 2;
                viewRect.east = Math.max(viewRect.east, centerLong + (MINUMUM_VIEW_AREA_SIZE_DEGREES / 2));
                viewRect.west = Math.min(viewRect.west, centerLong - (MINUMUM_VIEW_AREA_SIZE_DEGREES / 2));
                viewRect.south = Math.min(viewRect.south, centerLat - (MINUMUM_VIEW_AREA_SIZE_DEGREES / 2));
                viewRect.north = Math.max(viewRect.north, centerLat + (MINUMUM_VIEW_AREA_SIZE_DEGREES / 2));
            }
            if (center && viewRect) {
                if ((((this._currentPOI) && !(this._currentPOI.IsEqual(center)) || (this._currentPOI == null)))
                    || (((this._currentView) && !(this._currentView.IsEqual(viewRect))) || (this._currentView == null))) {
                    this._currentPOI = center;
                    this._currentView = viewRect;
                    return SearchStatus.LocationChanged;
                }
                return SearchStatus.LocationFound;
            }
            return SearchStatus.LocationMissing;
        }
        /**
         * We now have new position,
         * we need to create view area and point of intrest.
         */
        NewPositionReady() {
            let searchResult = this.UpdateCurrentViewAndPoi();
            if (searchResult == SearchStatus.LocationChanged) {
                let interest = {
                    area: this._currentView,
                    poi: this._currentPOI
                };
                this._onPositionReady.Trigger(interest);
            }
            else if (searchResult == SearchStatus.LocationMissing) {
                this.Update();
            }
        }
        /**
         * The postion events updated.
         */
        ViewAreaUpdated() {
            return this._onPositionReady;
        }
        /**
         * Getting the current view area.
         */
        GetViewAreaInDegrees() {
            if (this._currentView == null) {
                this.UpdateCurrentViewAndPoi();
            }
            return this._currentView;
        }
        /**
         * Get the center of the view.
         */
        GetTargetPointInDegrees() {
            if (this._currentPOI == null) {
                this.UpdateCurrentViewAndPoi();
            }
            return this._currentPOI;
        }
        Update() {
            this.NewPositionPending(TIME_LAG);
        }
    }
    exports.CesiumViewMonitor = CesiumViewMonitor;
});
define("entry-points/cesium/viewer/cesium-load-manager", ["require", "exports", "utils/bruce-event"], function (require, exports, bruce_event_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumLoadManager = exports.MAX_POINTS = void 0;
    const WATCH_PERIOD = 300;
    exports.MAX_POINTS = 500;
    /**
     * Provides guidance on amount of loaded enteties in the frame.
     */
    class CesiumLoadManager {
        constructor(viewer) {
            this.onReadyToDraw = new bruce_event_3.BruceEvent();
            this.tickedframes = 0;
            this.paused = false;
            this.viewer = viewer;
            this._points = 0;
            this._maxPointsNextFrame = 1;
            this.intervalHandler = setInterval(() => {
                let dds = this.viewer.dataSourceDisplay;
                if ((dds.ready) && (this.paused == false)) {
                    if ((this.tickedframes <= 1000 / WATCH_PERIOD) && (this._points <= this._maxPointsNextFrame)) {
                        this._maxPointsNextFrame += (exports.MAX_POINTS / 10);
                    }
                    else {
                        this._maxPointsNextFrame = this._maxPointsNextFrame / this.tickedframes;
                    }
                    if (this._maxPointsNextFrame > exports.MAX_POINTS) {
                        this._maxPointsNextFrame = exports.MAX_POINTS;
                    }
                    if (this._maxPointsNextFrame < (exports.MAX_POINTS / 10)) {
                        this._maxPointsNextFrame = (exports.MAX_POINTS / 10);
                    }
                    this._maxPointsNextFrame = Math.round(this._maxPointsNextFrame);
                    this.tickedframes = 0;
                    this._points = 0;
                    this.onReadyToDraw.Trigger(true);
                    this.onReadyToDraw.Clear();
                }
                else {
                    this.tickedframes = this.tickedframes + 1;
                }
            }, WATCH_PERIOD);
        }
        Pause(state) {
            this.paused = state;
        }
        isPaused() {
            return this.paused;
        }
        /**
         * Adds item to load.
         * @param loadFn The function to be called to load the entity.
         * @param points the amount of points we evaluate the tasks.
         */
        RequestToAddLoad(points) {
            return __awaiter(this, void 0, void 0, function* () {
                this._points = this._points + points;
                if (this._points >= this._maxPointsNextFrame) {
                    return new Promise(resolve => {
                        this.onReadyToDraw.Subscribe(() => {
                            resolve(null);
                        });
                    });
                }
                return Promise.resolve();
            });
        }
        Dispose() {
            clearInterval(this.intervalHandler);
        }
    }
    exports.CesiumLoadManager = CesiumLoadManager;
});
define("entry-points/cesium/common/cesium-utils", ["require", "exports", "cesium", "utils/object-utils", "entry-points/cesium/visuals/cesium-bruce-entity"], function (require, exports, Cesium, object_utils_39, cesium_bruce_entity_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumUtils = void 0;
    Cesium = __importStar(Cesium);
    const INNER_ENTITY = {};
    const INNER_ENTITY_NAME = "INNER_ENTITY";
    /**
     * Utilities relating to Cesium that aren't to do with entities.
     */
    class CesiumUtils {
        /**
         * Returns "real" entity from given cesium entity.
         * This checks for parent entities to try locate original entity.
         * @param entity
         */
        static GetRealEntity(entity) {
            if (entity && entity instanceof Cesium.Entity && CesiumUtils.isInnerEntity(entity)) {
                let realEntity = CesiumUtils.getParentEntity(entity);
                if (realEntity && realEntity !== entity) {
                    entity = realEntity;
                }
            }
            let dnEntity = cesium_bruce_entity_1.CesiumBruceEntity.FromCesiumEntity(entity);
            return dnEntity;
        }
        /**
         * Transforms radian cartographic to degrees.
         * @param point
         */
        static toDegrees(point) {
            let carto = new Cesium.Cartographic(Cesium.Math.toDegrees(point.longitude), Cesium.Math.toDegrees(point.latitude), point.height);
            return carto;
        }
        /**
         * Transforms degree cartographic to radians.
         * @param point
         */
        static toRadians(point) {
            let carto = new Cesium.Cartographic(Cesium.Math.toRadians(point.longitude), Cesium.Math.toRadians(point.latitude), point.height);
            return carto;
        }
        /**
         * Returns radians cartographic position from given cartesian position.
         * @param pos
         */
        static toRadiansCartographic(pos) {
            return Cesium.Cartographic.fromCartesian(pos);
        }
        /**
         * Returns radians cartographic array from given cartesian positions.
         * @param posses
         */
        static toRadiansCartographicArray(posses) {
            let cartos = [];
            for (let i = 0; i < posses.length; i++) {
                let pos = posses[i];
                cartos.push(Cesium.Cartographic.fromCartesian(pos));
            }
            return cartos;
        }
        /**
         * Returns degrees cartographic position from given cartesian position.
         * @param pos
         */
        static toCartographic(pos) {
            let carto = Cesium.Cartographic.fromCartesian(pos);
            carto = CesiumUtils.toDegrees(carto);
            return carto;
        }
        /**
         * Returns degrees cartographic positions from cartesian positions.
         * @param pos
         */
        static toCartographicArray(posses) {
            let cartos = [];
            for (let i = 0; i < posses.length; i++) {
                let pos = posses[i];
                let carto = Cesium.Cartographic.fromCartesian(pos);
                carto = CesiumUtils.toDegrees(carto);
                cartos.push(carto);
            }
            return cartos;
        }
        /**
         * Returns distance in meters between two given points.
         * @param start in degrees
         * @param end in degrees
         */
        static distanceBetweenPoints(start, end) {
            let value = Math.sqrt(Math.pow(CesiumUtils.distanceBetweenPointsOnSurface(start, end), 2) +
                Math.pow(end.height - start.height, 2));
            return value;
        }
        /**
         * Returns distance in meters between two points on the surface.
         * @param start
         * @param end
         */
        static distanceBetweenPointsOnSurface(start, end) {
            let startCartesian3Point = Cesium.Cartesian3.fromDegrees(start.longitude, start.latitude);
            let endCartesian3Point = Cesium.Cartesian3.fromDegrees(end.longitude, end.latitude);
            let startCartographicPoint = Cesium.Cartographic.fromCartesian(startCartesian3Point);
            let endCartographicPoint = Cesium.Cartographic.fromCartesian(endCartesian3Point);
            let ellipsoidGeodesic = new Cesium.EllipsoidGeodesic(startCartographicPoint, endCartographicPoint);
            let distance = ellipsoidGeodesic.surfaceDistance;
            return distance;
        }
        /**
         * Marks a given entity as an inner entity of a parent.
         * @deprecated Moved to CesiumEntityUtils.
         * @param entity
         */
        static markAsInner(entity) {
            entity[INNER_ENTITY_NAME] = INNER_ENTITY;
            return entity;
        }
        /**
         * Returns top-most parent entity for a given entity.
         * @deprecated Moved to CesiumEntityUtils.
         * @param entity
         */
        static getParentEntity(entity) {
            if (!entity) {
                return null;
            }
            let parent = entity.parent;
            while (parent) {
                if (!CesiumUtils.isInnerEntity(parent)) {
                    return parent;
                }
                parent = parent.parent;
            }
        }
        /**
         * Returns if a given entity is an inner entity or not.
         * This means it has a parent 'container' entity.
         * @deprecated Moved to CesiumEntityUtils.
         * @param entity
         */
        static isInnerEntity(entity) {
            return entity && entity[INNER_ENTITY_NAME] === INNER_ENTITY;
        }
        /**
         * Returns associated entities with a given visual.
         * This includes the given visual itself too.
         * @deprecated Moved to CesiumEntityUtils.
         * @param entity
         * @param result
         */
        static allEntities(entity, result) {
            result = result || [entity];
            let children = entity._children;
            if (children && children.length) {
                children.forEach(x => {
                    result.push(x);
                    CesiumUtils.allEntities(x, result);
                });
            }
            if (entity._model) {
                result.push(entity._model);
                CesiumUtils.allEntities(entity._model, result);
            }
            if (entity.model) {
                result.push(entity.model);
                CesiumUtils.allEntities(entity.model, result);
            }
            return result;
        }
        /**
         * Removes an entity and it's associated visuals from the view.
         * @param entity
         * @deprecated Moved to CesiumEntityUtils.
         */
        static removeEntity(viewer, entity) {
            if (entity) {
                let entities = CesiumUtils.allEntities(entity);
                if (entities) {
                    entities.forEach(x => {
                        let e = cesium_bruce_entity_1.CesiumBruceEntity.FromCesiumEntity(x);
                        if (e) {
                            e.dispose();
                        }
                        viewer.entities.remove(x);
                    });
                }
            }
            return null;
        }
        /**
         * Returns cesium color from given bruce color.
         * @param color
         */
        static ColorToCesiumColor(color) {
            return new Cesium.Color(color.red ? color.red / 255 : 0, color.green ? color.green / 255 : 0, color.blue ? color.blue / 255 : 0, color.alpha);
        }
        /**
         * Returns cesium cartesian 2 from given bruce cartesian 2 interface.
         * @param position
         * @returns
         */
        static ICartesian2ToCartesian2(position) {
            return new Cesium.Cartesian2(position.x, position.y);
        }
        /**
         * Returns cesium cartesian 3 array from given bruce cartesian 3 interfaces.
         * @param positions
         */
        static ICartesian3ToCartesian3(positions) {
            let newPosses = [];
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                let newPos = new Cesium.Cartesian3(pos.x, pos.y, pos.z);
                newPosses.push(newPos);
            }
            return newPosses;
        }
        /**
         * Returns cesium cartographic positions from given bruce cartographic interfaces.
         * @param positions
         */
        static ICartographicToCartographic(positions) {
            let newPosses = [];
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                let newPos = Cesium.Cartographic.fromDegrees(pos.longitude, pos.latitude, pos.altitude);
                newPosses.push(newPos);
            }
            return newPosses;
        }
        /**
         * @param position
         * @returns Cartesian3 from given ICartographic degrees position.
         */
        static ICartographicToCartesian3(position) {
            return Cesium.Cartesian3.fromDegrees(position.longitude, position.latitude, position.altitude);
        }
        /**
         * @param positions
         * @returns Cartesian3 array from given ICartographic degrees array.
         */
        static ICartographicArrayToCartesian3(positions) {
            let newPosses = [];
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                let newPos = CesiumUtils.ICartographicToCartesian3(pos);
                newPosses.push(newPos);
            }
            return newPosses;
        }
        /**
         * Takes the string of points we recieve from the bruce JSON and turns it into cartesian positions.
         * TODO: actually make it disconnected rings and not connected ones.
         */
        static ParsePoints(source) {
            let result = [];
            // Clean string
            source = source.replace(/(\r\n|\n|\r|\)|\()/g, "");
            let splitterCoordinates = " ";
            let splitterAxis = ",";
            let commaIndex = source.indexOf(",");
            let spaceIndex = source.indexOf(" ");
            if ((spaceIndex > -1 && commaIndex > spaceIndex) || commaIndex <= -1) {
                splitterCoordinates = ",";
                splitterAxis = " ";
            }
            // Break up into array
            let points = source.trim().split(splitterCoordinates);
            points = points.filter(a => a != "");
            // Parse pieces into cartesian values
            for (let i = 0; i < points.length; i++) {
                let pointData = points[i];
                let coords = pointData.trim().split(splitterAxis);
                if (coords.length == 2 || coords.length == 3) {
                    let longitude = object_utils_39.ObjectUtils.parseNum(coords[0]);
                    let latitude = object_utils_39.ObjectUtils.parseNum(coords[1]);
                    let altitude = coords.length >= 3 ? object_utils_39.ObjectUtils.parseNum(coords[2]) : 0;
                    if (longitude != null && latitude != null) {
                        result.push(longitude);
                        result.push(latitude);
                        result.push(altitude);
                    }
                    else {
                        //console.log(">>ParsePoints: Bad point: " + source);
                    }
                }
                else if (result.length % 3 == 0) {
                    result.push(...coords.map(x => parseFloat(x)));
                }
            }
            return Cesium.Cartesian3.fromDegreesArrayHeights(result);
        }
        /**
         * Validates a given position to make sure it wont crash under cesium rendering.
         * @param position
         * @returns if position is valid.
         */
        static ValidatePosition(position) {
            return !!position && !!position.x && !!position.y && !!position.z;
        }
        /**
         * Validates an array of positions to make sure they wont crash under cesium rendering.
         * @param positions
         * @returns if all positions are valid.
         */
        static ValidatePositions(positions) {
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                let valid = CesiumUtils.ValidatePosition(pos);
                if (!valid) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Validates a given screen position.
         * @param position
         */
        static Validate2DPosition(position) {
            return !!position && !!position.x && !!position.y;
        }
        /**
         * Validates a given array of screen positions.
         * @param positions
         */
        static Validate2DPositions(positions) {
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                let valid = CesiumUtils.Validate2DPosition(pos);
                if (!valid) {
                    return false;
                }
            }
            return true;
        }
        /**
         * Returns value from cesium property.
         * @param property
         */
        static getCesiumValue(viewer, property) {
            if (property) {
                return property.getValue ? property.getValue(viewer.scene.lastRenderTime) : property;
            }
            return null;
        }
        /**
         * Returns if a given point is inside a given polygon.
         * @param polygon
         * @param point
         * @returns
         */
        static getIsPointInPolygon(polygon, point) {
            if (!point || !polygon || polygon.length <= 0) {
                return false;
            }
            let minX = polygon[0].longitude;
            let maxX = polygon[0].longitude;
            let minY = polygon[0].latitude;
            let maxY = polygon[0].latitude;
            for (let i = 1; i < polygon.length; i++) {
                let q = polygon[i];
                minX = Math.min(q.longitude, minX);
                maxX = Math.max(q.longitude, maxX);
                minY = Math.min(q.latitude, minY);
                maxY = Math.max(q.latitude, maxY);
            }
            if (point.longitude < minX || point.longitude > maxX || point.latitude < minY || point.latitude > maxY) {
                return false;
            }
            // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
            let inside = false;
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                if ((polygon[i].latitude > point.latitude) != (polygon[j].latitude > point.latitude) &&
                    point.longitude < (polygon[j].longitude - polygon[i].longitude) * (point.latitude - polygon[i].latitude) / (polygon[j].latitude - polygon[i].latitude) + polygon[i].longitude) {
                    inside = !inside;
                }
            }
            return inside;
        }
        /**
         * Request a cesium render.
         * @param viewer
         * @param callback Callback for when render has finished.
         */
        static Render(viewer, onRender) {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res, rej) => {
                    let scene = viewer.scene;
                    let removeCallback;
                    removeCallback = scene.postRender.addEventListener(() => {
                        if (removeCallback) {
                            removeCallback();
                            removeCallback = null;
                        }
                        if (onRender) {
                            onRender();
                        }
                        res();
                    });
                    scene.requestRender();
                });
            });
        }
    }
    exports.CesiumUtils = CesiumUtils;
});
define("entry-points/cesium/common/cesium-drawing-utils", ["require", "exports", "cesium", "bruce-models/common/polygon", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, polygon_2, cesium_utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumDrawingUtils = void 0;
    Cesium = __importStar(Cesium);
    /**
     * Utilities related to Cesium visuals that may or may not be Bruce entities.
     */
    class CesiumDrawingUtils {
        /**
         * Returns position across given position array at a given distance
         * @param positions
         * @param distance
         */
        static PointAcrossPolyline(viewer, positions, distance) {
            if (positions.length > 1) {
                let currentDistance = 0;
                for (let i = 0; i < positions.length - 1; i++) {
                    let length = Cesium.Cartesian3.distance(positions[i], positions[i + 1]);
                    if (length + currentDistance >= distance) {
                        let carto1 = Cesium.Cartographic.fromCartesian(positions[i]);
                        let carto2 = Cesium.Cartographic.fromCartesian(positions[i + 1]);
                        let geodesic = new Cesium.EllipsoidGeodesic(carto1, carto2, viewer.scene.globe.ellipsoid);
                        let position = geodesic.interpolateUsingSurfaceDistance(distance - currentDistance);
                        let height = (carto1.height + carto2.height) / 2;
                        return Cesium.Cartesian3.fromRadians(position.longitude, position.latitude, height);
                    }
                    else {
                        currentDistance += length;
                    }
                }
            }
            else if (positions.length > 0) {
                return positions[0];
            }
            else {
                return null;
            }
            return positions[positions.length - 1];
        }
        /**
         * Returns center position from a given array of cartesian 3 positions.
         * @param positions
         */
        static CalculateCenterPosition(viewer, positions) {
            let maxLat;
            let maxLon;
            let minLat;
            let minLon;
            let maxHeight;
            let minHeight;
            let checkBounds = (posCarto) => {
                if (posCarto != null) {
                    if (posCarto.latitude < minLat || minLat == null) {
                        minLat = posCarto.latitude;
                    }
                    if (posCarto.latitude > maxLat || maxLat == null) {
                        maxLat = posCarto.latitude;
                    }
                    if (posCarto.longitude < minLon || minLon == null) {
                        minLon = posCarto.longitude;
                    }
                    if (posCarto.longitude > maxLon || maxLon == null) {
                        maxLon = posCarto.longitude;
                    }
                    if (posCarto.height > maxHeight || maxHeight == null) {
                        maxHeight = posCarto.height;
                    }
                    if (posCarto.height < minHeight || minHeight == null) {
                        minHeight = posCarto.height;
                    }
                }
            };
            for (let i = 0; i < positions.length; i++) {
                let posCarto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(positions[i]);
                checkBounds(posCarto);
            }
            return Cesium.Cartesian3.fromRadians((maxLon + minLon) / 2, (maxLat + minLat) / 2, (maxHeight + minHeight) / 2, viewer.scene.globe.ellipsoid);
        }
        /**
         * Returns difference between given position and offset position after applying NESW + altitude offsets
         * @param pos
         * @param n
         * @param e
         * @param alt
         */
        static GetOffset(pos, n, e, alt) {
            if (n == 0 && e == 0 && alt == 0) {
                return new Cesium.Cartesian3(0, 0, 0);
            }
            let carto = Cesium.Cartographic.fromCartesian(pos);
            carto.latitude = Cesium.Math.toDegrees(carto.latitude);
            carto.longitude = Cesium.Math.toDegrees(carto.longitude);
            // North
            if (n != 0) {
                carto = CesiumDrawingUtils.OffsetPoint(carto, Number(n), 0);
            }
            // East
            if (e != 0) {
                carto = CesiumDrawingUtils.OffsetPoint(carto, Number(e), 90);
            }
            // Altitude
            carto.height += Number(alt);
            let finalOffset = Cesium.Cartesian3.fromDegrees(carto.longitude, carto.latitude, carto.height);
            finalOffset.x -= pos.x;
            finalOffset.y -= pos.y;
            finalOffset.z -= pos.z;
            return finalOffset;
        }
        /**
         * Moves a given point by a given amount and bearing.
         * Given point object isnt affect. A new cartograhic instance is returned.
         *
         * @param pos Cartographic initial position in degrees
         * @param distance Distance in meters to move from position
         * @param bearing Bearing determining the direction of movement in degrees
         * @param radius
         */
        static OffsetPoint(pos, distance, bearing) {
            // radius of earth
            let radius = 6371e3;
            let δ = distance / radius;
            let θ = Cesium.Math.toRadians(bearing);
            let φ1 = Cesium.Math.toRadians(pos.latitude);
            let λ1 = Cesium.Math.toRadians(pos.longitude);
            let sinφ2 = Math.sin(φ1) * Math.cos(δ) + Math.cos(φ1) * Math.sin(δ) * Math.cos(θ);
            let φ2 = Math.asin(sinφ2);
            let y = Math.sin(θ) * Math.sin(δ) * Math.cos(φ1);
            let x = Math.cos(δ) - Math.sin(φ1) * sinφ2;
            let λ2 = λ1 + Math.atan2(y, x);
            let finalPos = new Cesium.Cartographic(λ2, φ2, pos.height);
            finalPos.latitude = Cesium.Math.toDegrees(finalPos.latitude);
            finalPos.longitude = Cesium.Math.toDegrees(finalPos.longitude);
            return finalPos;
        }
        /**
         * Returns default entity selection material.
         * @deprecated Moved to cesium entity utils.
         */
        static GetSelectionMaterial() {
            return Cesium.Color.fromCssColorString("#000080").withAlpha(0.9);
        }
        /**
         * Returns default entity selection color.
         * @deprecated Moved to cesium entity utils.
         */
        static GetSelectionColor() {
            return "rgb(0, 0, 128, 0.9)";
        }
        /**
         * Returns a bruce info geometry object for a given cartesian3 position array
         * @param posses
         * @deprecated Moved to CesiumBruceInfoUtils
         */
        static PolygonGeometryFromCartesianArray(posses) {
            if (posses.length < 3) {
                return [];
            }
            let carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(posses[0]);
            let latitude = Cesium.Math.toDegrees(carto.latitude);
            let longitude = Cesium.Math.toDegrees(carto.longitude);
            let ringString = longitude + "," + latitude + "," + carto.height;
            for (let i = 1; i < posses.length; i++) {
                carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(posses[i]);
                latitude = Cesium.Math.toDegrees(carto.latitude);
                longitude = Cesium.Math.toDegrees(carto.longitude);
                ringString += " " + longitude + "," + latitude + "," + carto.height;
            }
            let geometry = [
                new polygon_2.Polygon({
                    Facing: polygon_2.PolygonFacing.out,
                    LinearRing: ringString
                })
            ];
            return geometry;
        }
        /**
         * Returns a bruce info geometry object for a given cartesian 3 position array.
         * @param posses
         * @deprecated Moved to CesiumBruceInfoUtils
         */
        static PolylineGeometryFromCartesianArray(posses) {
            if (posses.length < 2) {
                return "";
            }
            let carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(posses[0]);
            let latitude = Cesium.Math.toDegrees(carto.latitude);
            let longitude = Cesium.Math.toDegrees(carto.longitude);
            let lineString = longitude + "," + latitude + "," + carto.height;
            for (let i = 1; i < posses.length; i++) {
                carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(posses[i]);
                latitude = Cesium.Math.toDegrees(carto.latitude);
                longitude = Cesium.Math.toDegrees(carto.longitude);
                lineString += " " + longitude + "," + latitude + "," + carto.height;
            }
            return lineString;
        }
        /**
         * Closes a polygon shape (makes sure first and last points are the same).
         * @param posses
         */
        static ClosePolygon(posses) {
            if (posses.length < 2) {
                return posses;
            }
            else {
                // So we dont affect the referenced object.
                let tmp = [].concat(posses);
                // If the first and last points do not match, add first point to end.
                if (tmp.length > 2 && !Cesium.Cartesian3.equals(tmp[0], tmp[tmp.length - 1])) {
                    tmp.push(tmp[0]);
                }
                return tmp;
            }
        }
        /**
         * Returns an un-closed shape (If first and last position match then it will remove last position).
         * @param posses
         */
        static Unclose(posses) {
            if (posses.length < 2) {
                return posses;
            }
            else {
                // So we dont affect the referenced object.
                let tmp = [].concat(posses);
                // If the first and last points match, remove last position.
                if (tmp.length > 2 && Cesium.Cartesian3.equals(tmp[0], tmp[tmp.length - 1])) {
                    tmp.splice(tmp.length - 1, 1);
                }
                return tmp;
            }
        }
        /**
         * Returns cartesian 3 position for provided screen position.
         * @param viewer
         * @param position
         * @returns
         */
        static GetCartesian3FromMouse(viewer, position) {
            let scene = viewer.scene;
            // Enable ground occlusion and force render if it's not on
            let tmpGO = scene.globe.depthTestAgainstTerrain;
            // @ts-ignore
            if (!tmpGO && scene.render) {
                scene.globe.depthTestAgainstTerrain = true;
                // @ts-ignore
                scene.render();
            }
            // Pick position
            let pos = scene.pickPosition(new Cesium.Cartesian2(position.x, position.y));
            // Return ground occlusion to original state
            scene.globe.depthTestAgainstTerrain = tmpGO;
            return pos;
        }
        /**
         * Returns terrain cartesian 3 position at provided screen position.
         * @param viewer
         * @param position
         * @returns
         */
        static GetCartesian3TerrainFromMouse(viewer, position) {
            let scene = viewer.scene;
            let camera = viewer.camera;
            // Enable ground occlusion and force render if it's not on
            let tmpGO = scene.globe.depthTestAgainstTerrain;
            // @ts-ignore
            if (!tmpGO && scene.render) {
                scene.globe.depthTestAgainstTerrain = true;
                // @ts-ignore
                scene.render();
            }
            // Pick ground position
            let pos2d = cesium_utils_1.CesiumUtils.ICartesian2ToCartesian2(position);
            let ray = camera.getPickRay(pos2d);
            let intersection = scene.globe.pick(ray, scene);
            // Return ground occlusion to original state
            scene.globe.depthTestAgainstTerrain = tmpGO;
            return intersection;
        }
        /**
         * Blows up rectangle by given meters in all 4 cardinal directions.
         * @param rectangle
         * @param meters
         */
        static BlowupRectangle(rectangle, meters) {
            let tLeft = Cesium.Cartographic.fromRadians(rectangle.west, rectangle.north, 0);
            let tRight = Cesium.Cartographic.fromRadians(rectangle.east, rectangle.north, 0);
            let bLeft = Cesium.Cartographic.fromRadians(rectangle.west, rectangle.south, 0);
            let bRight = Cesium.Cartographic.fromRadians(rectangle.east, rectangle.south, 0);
            tLeft = cesium_utils_1.CesiumUtils.toDegrees(tLeft);
            tRight = cesium_utils_1.CesiumUtils.toDegrees(tRight);
            bLeft = cesium_utils_1.CesiumUtils.toDegrees(bLeft);
            bRight = cesium_utils_1.CesiumUtils.toDegrees(bRight);
            tLeft = CesiumDrawingUtils.OffsetPoint(tLeft, meters, 315);
            tRight = CesiumDrawingUtils.OffsetPoint(tRight, meters, 45);
            bLeft = CesiumDrawingUtils.OffsetPoint(bLeft, meters, 225);
            bRight = CesiumDrawingUtils.OffsetPoint(bRight, meters, 135);
            tLeft = cesium_utils_1.CesiumUtils.toRadians(tLeft);
            tRight = cesium_utils_1.CesiumUtils.toRadians(tRight);
            bLeft = cesium_utils_1.CesiumUtils.toRadians(bLeft);
            bRight = cesium_utils_1.CesiumUtils.toRadians(bRight);
            Cesium.Rectangle.expand(rectangle, tLeft, rectangle);
            Cesium.Rectangle.expand(rectangle, tRight, rectangle);
            Cesium.Rectangle.expand(rectangle, bLeft, rectangle);
            Cesium.Rectangle.expand(rectangle, bRight, rectangle);
            return rectangle;
        }
        /**
         * Returns distance across globe between two positions.
         * @param start in degrees
         * @param end in degrees
         * @returns
         */
        static DistanceAcrossGlobe(start, end) {
            let ellipsoidGeodesic = new Cesium.EllipsoidGeodesic(cesium_utils_1.CesiumUtils.toRadians(start), cesium_utils_1.CesiumUtils.toRadians(end));
            let distance = ellipsoidGeodesic.surfaceDistance;
            return distance;
        }
        /**
         * Raycasts Cesium entities.
         * Returns back first 5 entities hit and the hit position for each entity.
         * @param viewer
         * @param start: The ray start.
         * @param end: The ray end.
         * @param ignoreEntities: What entities to ignore in the raycast.
         * @returns
         */
        static RaycastDrillEntities(viewer, start, end, ignoreEntities) {
            let direction = Cesium.Cartesian3.normalize(Cesium.Cartesian3.subtract(end, start, new Cesium.Cartesian3()), new Cesium.Cartesian3());
            let ray = new Cesium.Ray(start, direction);
            let scene = viewer.scene;
            let picked = scene.drillPickFromRay(ray, 5, ignoreEntities);
            let cleaned = [];
            if (picked) {
                for (let i = 0; i < picked.length; i++) {
                    let pick = picked[i];
                    if (!pick.exclude) {
                        let entity = pick.object;
                        if ((entity === null || entity === void 0 ? void 0 : entity.id) instanceof Cesium.Entity) {
                            entity = entity.id;
                        }
                        if (entity) {
                            let data = {
                                entity: entity,
                                position: pick.position
                            };
                            cleaned.push(data);
                        }
                    }
                }
            }
            return cleaned;
        }
    }
    exports.CesiumDrawingUtils = CesiumDrawingUtils;
});
define("entry-points/cesium/common/cesium-measure-handler", ["require", "exports", "cesium"], function (require, exports, Cesium) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumMeasureHandler = void 0;
    Cesium = __importStar(Cesium);
    /**
     * Used to handle measurement calculations
     */
    class CesiumMeasureHandler {
        /**
         * Returns polyline measurements for a given set of positions.
         * @param positions
         * @returns
         */
        measurePolyline(positions) {
            let totalLength = 0;
            let pos1 = null;
            let pos2 = null;
            for (let i = 0; i < positions.length; i++) {
                if (pos1 == null) {
                    pos1 = positions[i];
                }
                else if (pos2 == null) {
                    pos2 = positions[i];
                    totalLength += Cesium.Cartesian3.distance(pos1, pos2);
                    pos1 = pos2;
                    pos2 = null;
                }
            }
            let data = {
                totalLength: totalLength
            };
            return data;
        }
        /**
         * Returns polygon measurements for a given set of positions.
         * @param positions
         * @returns
         */
        measurePolygon(positions) {
            let posses = [].concat(positions);
            // If the first and last points do not match, add first point to end.
            if (posses.length > 2 && !Cesium.Cartesian3.equals(posses[0], posses[posses.length - 1])) {
                posses.push(posses[0]);
            }
            let indices = Cesium.PolygonPipeline.triangulate(posses, []);
            let area = 0;
            for (let i = 0; i < indices.length; i += 3) {
                let vector1 = posses[indices[i]];
                let vector2 = posses[indices[i + 1]];
                let vector3 = posses[indices[i + 2]];
                let vectorC = Cesium.Cartesian3.subtract(vector2, vector1, new Cesium.Cartesian3());
                let vectorD = Cesium.Cartesian3.subtract(vector3, vector1, new Cesium.Cartesian3());
                let areaVector = Cesium.Cartesian3.cross(vectorC, vectorD, new Cesium.Cartesian3());
                area += Cesium.Cartesian3.magnitude(areaVector) / 2.0;
            }
            let perimeter = this.measurePolyline(posses).totalLength;
            let data = {
                area: area,
                perimeter: perimeter
            };
            return data;
        }
        /**
         * Returns angle in degrees between two given positions
         * Adjusted version of the one in the thread below.
         * Their version I believe does an angle calculation for this:
         *
         *  X marking the angle calculated in the thread
         *
         *        Pos1
         *         /|
         *        / |
         *       /  |
         * Pos2 X___|
         *
         * This calculation gets the angle for (x marker again):
         *
         *        Pos1
         *          X
         *         /|
         *        / |
         *       /  |
         * Pos2 /___|
         *
         * (https://community.cesium.com/t/calculate-elevation-angle-between-two-points/5629/4)
         */
        measureAngle(pos1, pos2) {
            let shouldFlip = this.shouldFlip(pos1, pos2);
            if (shouldFlip) {
                let tmp = pos1;
                pos1 = pos2;
                pos2 = tmp;
            }
            let scratch1 = new Cesium.Cartesian3();
            let difference = Cesium.Cartesian3.subtract(pos2, pos1, scratch1);
            difference = Cesium.Cartesian3.normalize(difference, scratch1);
            let scratch2 = new Cesium.Cartesian3();
            let surfaceNormal = Cesium.Cartesian3.normalize(pos2, scratch2);
            let dotProduct = Cesium.Cartesian3.dot(difference, surfaceNormal);
            let angle = 180 - Cesium.Math.toDegrees(Math.acos(dotProduct));
            //if (shouldFlip) angle *= -1;
            return angle;
        }
        /**
         * Returns angle in degrees between two given positions
         *
         *  X marking the angle calculated in the thread
         *
         *        Pos1
         *         /|
         *        / |
         *       /  |
         * Pos2 X___|
         *
         * (https://community.cesium.com/t/calculate-elevation-angle-between-two-points/5629/4)
         */
        measureAngle2(pos1, pos2) {
            let shouldFlip = this.shouldFlip(pos1, pos2);
            let scratch1 = new Cesium.Cartesian3();
            let difference = Cesium.Cartesian3.subtract(pos1, pos2, scratch1);
            difference = Cesium.Cartesian3.normalize(difference, scratch1);
            let scratch2 = new Cesium.Cartesian3();
            let surfaceNormal = Cesium.Cartesian3.normalize(pos1, scratch2);
            let dotProduct = Cesium.Cartesian3.dot(difference, surfaceNormal);
            let angle = 90 - Cesium.Math.toDegrees(Math.acos(dotProduct));
            if (shouldFlip) {
                angle *= -1;
            }
            return angle;
        }
        /** Returns if the first point is lower than the second point */
        shouldFlip(pos1, pos2) {
            let pos1Carto = Cesium.Cartographic.fromCartesian(pos1);
            let pos2Carto = Cesium.Cartographic.fromCartesian(pos2);
            let change = pos1Carto.height < pos2Carto.height;
            return change;
        }
        /**
         * Converts meters to imperial readable text.
         * @param meters
         * @returns
         */
        meterToFeet(meters) {
            let feetDecimal = meters * 3.2808;
            let inchesTotal = feetDecimal * 12.0;
            let feet = Math.floor(inchesTotal / 12);
            let inches = Math.round(inchesTotal % 12);
            return feet + "ft " + " " + inches + "in";
        }
        angle(pos1, pos2, pos3) {
            let x1 = pos1.x;
            let y1 = pos1.y;
            let z1 = pos1.z;
            let x2 = pos2.x;
            let y2 = pos2.y;
            let z2 = pos2.z;
            let x3 = pos3.x;
            let y3 = pos3.y;
            let z3 = pos3.z;
            let num = (x2 - x1) * (x3 - x1) +
                (y2 - y1) * (y3 - y1) +
                (z2 - z1) * (z3 - z1);
            let den = Math.sqrt(Math.pow((x2 - x1), 2) + Math.pow((y2 - y1), 2) + Math.pow((z2 - z1), 2)) *
                Math.sqrt(Math.pow((x3 - x1), 2) + Math.pow((y3 - y1), 2) + Math.pow((z3 - z1), 2));
            return Cesium.Math.toDegrees(Math.acos(num / den));
        }
    }
    exports.CesiumMeasureHandler = CesiumMeasureHandler;
});
define("entry-points/cesium/common/cesium-entity-utils", ["require", "exports", "cesium", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-utils", "entry-points/cesium/visuals/cesium-bruce-entity", "entry-points/cesium/common/cesium-measure-handler"], function (require, exports, Cesium, cesium_drawing_utils_1, cesium_utils_2, cesium_bruce_entity_2, cesium_measure_handler_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumEntityUtils = void 0;
    Cesium = __importStar(Cesium);
    const INNER_ENTITY = {};
    const INNER_ENTITY_NAME = "INNER_ENTITY";
    /**
     * Utilities related to bruce entity Cesium visuals.
     */
    class CesiumEntityUtils {
        /**
         * Highlights a given cesium entity, primitive or tileset
         * @param viewer
         * @param entity
         * @param color Provide colour to use instead of the default view selection colour
         */
        static HighlightEntity(viewer, entity, color = null) {
            if (!entity) {
                return;
            }
            try {
                // Creates a color material from either given color or using view default
                let material = color == null ? CesiumEntityUtils.GetSelectionMaterial() : color;
                if (entity instanceof Cesium.Primitive) {
                    // @ts-ignore
                    if (entity.appearance.material.type == "Color") {
                        // @ts-ignore
                        entity.appearance._oldMaterial = entity.appearance.material;
                        // @ts-ignore
                        entity.appearance.material = new Cesium.Material({
                            fabric: {
                                type: "Color",
                                uniforms: {
                                    color: material
                                }
                            }
                        });
                    }
                }
                else if (entity instanceof Cesium.Cesium3DTileFeature) {
                    // @ts-ignore
                    let color = entity.color;
                    // @ts-ignore
                    entity._normalColor = new Cesium.Color(color.red, color.green, color.blue, color.alpha);
                    // @ts-ignore
                    entity.color = material;
                }
                else if (entity instanceof Cesium.Cesium3DTileset) {
                    // @ts-ignore
                    entity._oldStyle = entity.style;
                    // @ts-ignore
                    entity.style = new Cesium.Cesium3DTileStyle({
                        color: cesium_drawing_utils_1.CesiumDrawingUtils.GetSelectionColor()
                    });
                    // @ts-ignore
                    entity.makeStyleDirty();
                }
                else if (entity instanceof Cesium.Entity) {
                    // @ts-ignore
                    for (let e of cesium_utils_2.CesiumUtils.allEntities(entity)) {
                        if (e.polygon) {
                            // @ts-ignore
                            e.polygon.oldMaterial = e.polygon.material;
                            e.polygon.material = material;
                        }
                        else if (e.polyline) {
                            // @ts-ignore
                            e.polyline.oldMaterial = e.polyline.material;
                            e.polyline.material = material;
                            // @ts-ignore
                            e.polyline.oldDepthFailMaterial = e.polyline.depthFailMaterial;
                            e.polyline.depthFailMaterial = material;
                        }
                        else if (e.point) {
                            // @ts-ignore
                            e.point.oldMaterial = e.point.color;
                            e.point.color = material;
                        }
                        else if (e.billboard) {
                            // @ts-ignore
                            e.billboard.oldMaterial = e.billboard.color;
                            e.billboard.color = material;
                        }
                        else if (e.model) {
                            let scene = viewer.scene;
                            // @ts-ignore
                            let color = e.model.color ? e.model.color.getValue(scene.lastRenderTime) : {};
                            if (Cesium.PostProcessStageLibrary.isSilhouetteSupported(scene)) {
                                e.model.silhouetteSize = 5;
                                e.model.silhouetteColor = material;
                            }
                            else {
                                // @ts-ignore
                                e.model.oldColor = new Cesium.Color(color.red, color.green, color.blue, color.alpha);
                                e.model.color = material;
                            }
                        }
                    }
                }
                // What is this thing!?
                else {
                    console.log(">>Trying to highlight entity of unknown type. Entity is below:");
                    console.log(entity);
                }
                viewer.scene.requestRender();
            }
            catch (e) {
                console.log(">>Error highlighting entity");
            }
        }
        /**
         * Removes highlighting of a cesium entity, primitive or tileset.
         * @param viewer
         * @param entity
         */
        static UnhighlightEntity(viewer, entity) {
            if (!entity) {
                return;
            }
            let entities = [];
            try {
                // Swap entity with internal uiEntity if it's a bruce navigator entity
                if (entity instanceof cesium_bruce_entity_2.CesiumBruceEntity) {
                    entities = entity.uiEntities;
                }
                else {
                    entities = [entity];
                }
                for (let i = 0; i < entities.length; i++) {
                    let entity = entities[i];
                    if (entity) {
                        if (entity instanceof Cesium.Primitive) {
                            // @ts-ignore
                            let oldMaterial = entity.appearance ? entity.appearance._oldMaterial : null;
                            if (oldMaterial) {
                                // @ts-ignore
                                entity.appearance.material = oldMaterial;
                            }
                        }
                        else if (entity instanceof Cesium.Cesium3DTileset) {
                            // Undefined is a valid and most of the time correct style so we don't check against it
                            // @ts-ignore
                            entity.style = entity._oldStyle;
                            // @ts-ignore
                            entity.makeStyleDirty();
                        }
                        else if (entity instanceof Cesium.Cesium3DTileFeature) {
                            // @ts-ignore
                            entity.color = entity._normalColor;
                        }
                        else if (entity instanceof Cesium.Entity) {
                            // @ts-ignore
                            for (let e of cesium_utils_2.CesiumUtils.allEntities(entity)) {
                                if (e.polygon) {
                                    // @ts-ignore
                                    let oldMaterial = e.polygon.oldMaterial;
                                    if (oldMaterial) {
                                        e.polygon.material = oldMaterial;
                                    }
                                }
                                else if (e.polyline) {
                                    // @ts-ignore
                                    let oldMaterial = e.polyline.oldMaterial;
                                    if (oldMaterial) {
                                        e.polyline.material = oldMaterial;
                                    }
                                    // @ts-ignore
                                    let oldDepthFailMaterial = e.polyline.oldDepthFailMaterial;
                                    if (oldDepthFailMaterial) {
                                        e.polyline.depthFailMaterial = oldDepthFailMaterial;
                                    }
                                }
                                else if (e.point) {
                                    // @ts-ignore
                                    let oldMaterial = e.point.oldMaterial;
                                    if (oldMaterial) {
                                        e.point.color = oldMaterial;
                                    }
                                }
                                else if (e.billboard) {
                                    // @ts-ignore
                                    let oldMaterial = e.billboard.oldMaterial;
                                    // No null check because undefined is a valid material for billboards
                                    e.billboard.color = oldMaterial;
                                }
                                else if (e.model) {
                                    let scene = viewer.scene;
                                    if (Cesium.PostProcessStageLibrary.isSilhouetteSupported(scene)) {
                                        e.model.silhouetteSize = 0;
                                    }
                                    else {
                                        // @ts-ignore
                                        let oldColor = e.model.oldColor;
                                        if (oldColor) {
                                            e.model.color = oldColor;
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            console.log(">>Trying to unhighlight entity of unknown type. Entity is below:");
                            console.log(entity);
                        }
                    }
                }
                viewer.scene.requestRender();
            }
            catch (e) {
                console.log(">>Error unhighlighting entity");
            }
        }
        /**
         * Returns default entity selection material.
         */
        static GetSelectionMaterial() {
            return Cesium.Color.fromCssColorString("#000080").withAlpha(0.9);
        }
        /**
         * Returns default entity selection color.
         */
        static GetSelectionColor() {
            return "rgb(0, 0, 128, 0.9)";
        }
        /**
         * Marks a given entity as an inner entity of a parent.
         * @param entity
         */
        static MarkarkAsInner(entity) {
            entity[INNER_ENTITY_NAME] = INNER_ENTITY;
            return entity;
        }
        /**
         * Returns top-most parent entity for a given entity.
         * @deprecated Moved to CesiumEntityUtils.
         * @param entity
         */
        static getParentEntity(entity) {
            if (!entity) {
                return null;
            }
            let parent = entity.parent;
            while (parent) {
                if (!CesiumEntityUtils.isInnerEntity(parent)) {
                    return parent;
                }
                parent = parent.parent;
            }
        }
        /**
         * Returns if a given entity is an inner entity or not.
         * This means it has a parent 'container' entity.
         * @param entity
         */
        static isInnerEntity(entity) {
            return entity && entity[INNER_ENTITY_NAME] === INNER_ENTITY;
        }
        /**
         * Removes a child inner entity from a parent entity.
         * @param parent
         * @param child
         */
        static removeInnerEntity(parent, child) {
            let children = parent._children;
            let index = children.findIndex(x => x.id == child.id);
            if (index > -1) {
                children.splice(index, 1);
            }
            parent._children = children;
        }
        /**
         * Returns associated entities with a given visual.
         * This includes the given visual itself too.
         * @param entity
         * @param result
         */
        static getAllEntities(entity, result) {
            result = result || [entity];
            let children = entity._children;
            if (children && children.length) {
                children.forEach(x => {
                    result.push(x);
                    CesiumEntityUtils.getAllEntities(x, result);
                });
            }
            if (entity._model) {
                result.push(entity._model);
                CesiumEntityUtils.getAllEntities(entity._model, result);
            }
            if (entity.model) {
                result.push(entity.model);
                CesiumEntityUtils.getAllEntities(entity.model, result);
            }
            return result;
        }
        /**
         * Removes an entity and it's associated visuals from the view.
         * @param entity
         */
        static RemoveEntity(viewer, entity) {
            if (entity) {
                let entities = CesiumEntityUtils.getAllEntities(entity);
                if (entities) {
                    entities.forEach(x => {
                        let e = cesium_bruce_entity_2.CesiumBruceEntity.FromCesiumEntity(x);
                        if (e) {
                            e.dispose();
                        }
                        viewer.entities.remove(x);
                    });
                }
            }
            return null;
        }
        /**
         * Removes entities and their associated visuals from the view.
         */
        static RemoveEntities(viewer, entities) {
            if (entities) {
                for (let i = 0; i < entities.length; i++) {
                    let entity = entities[i];
                    if (entity) {
                        let attached = CesiumEntityUtils.getAllEntities(entity);
                        if (attached) {
                            for (let j = 0; j < attached.length; j++) {
                                let attach = attached[j];
                                let e = cesium_bruce_entity_2.CesiumBruceEntity.FromCesiumEntity(attach);
                                if (e) {
                                    e.RemoveVisual(attach);
                                    if (e.uiEntities.length <= 0) {
                                        e.dispose();
                                    }
                                }
                                viewer.entities.remove(attach);
                            }
                        }
                    }
                }
            }
        }
        /**
         * Drills at given cursor position for first visual matching given meta.
         * @param viewer
         * @param meta
         * @param cursor
         */
        static DigVisualsForMetaByCursor(viewer, meta, cursor) {
            // Drill picked list of cesium entities
            let pickedObjects = viewer.scene.drillPick(cursor, 5);
            for (let i = 0; i < pickedObjects.length; i++) {
                let object = pickedObjects[i];
                let entity = object && object.id && object.id instanceof Cesium.Entity ? object.id : object;
                let bruceEntity = cesium_utils_2.CesiumUtils.GetRealEntity(entity);
                if (bruceEntity) {
                    if (bruceEntity.bruceMeta.HashPath() == meta.HashPath()) {
                        return entity;
                    }
                }
            }
            return null;
        }
        /**
         * Calculates position from provided bruce info location, geometry, or boundaries.
         * @param viewer
         * @param info
         */
        static CalculatePosition(viewer, info) {
            // Has location, use location
            let location = info.location;
            if (location && location.latitude != null && location.longitude != null) {
                let altitude = location.altitude;
                if (!altitude == null) {
                    altitude = 0;
                }
                return Cesium.Cartesian3.fromDegrees(location.longitude, location.latitude, altitude);
            }
            // Has some sort of geometry? Let's try use it
            else if (info.geometry) {
                let geometry = info.geometry;
                if (typeof geometry == "object") {
                    // Using point geometry
                    if (geometry.Point && typeof geometry.Point == "string") {
                        let posses = cesium_utils_2.CesiumUtils.ParsePoints(geometry.Point);
                        let pos = posses.length > 0 ? posses[0] : null;
                        if (cesium_utils_2.CesiumUtils.ValidatePosition(pos)) {
                            return pos;
                        }
                    }
                    // Using polyline geometry
                    if (geometry.LineString && typeof geometry.LineString == "string") {
                        let lineString = geometry.LineString;
                        let posses = cesium_utils_2.CesiumUtils.ParsePoints(lineString);
                        let measurement = (new cesium_measure_handler_1.CesiumMeasureHandler).measurePolyline(posses);
                        let pos = cesium_drawing_utils_1.CesiumDrawingUtils.PointAcrossPolyline(viewer, posses, measurement.totalLength / 2);
                        if (cesium_utils_2.CesiumUtils.ValidatePosition(pos)) {
                            return pos;
                        }
                    }
                    // Using polygon geometry
                    if (geometry.Polygon && typeof geometry.Polygon == "object") {
                        let hierarchy = geometry.Polygon;
                        if (hierarchy.length > 0) {
                            let posses = cesium_utils_2.CesiumUtils.ParsePoints(hierarchy[0].LinearRing);
                            let pos = cesium_drawing_utils_1.CesiumDrawingUtils.CalculateCenterPosition(viewer, posses);
                            if (cesium_utils_2.CesiumUtils.ValidatePosition(pos)) {
                                return pos;
                            }
                        }
                    }
                }
            }
            // Ok let's use boundaries now...
            if (info.boundaries) {
                let rawLocation = {
                    latitude: (info.boundaries.minLatitude + info.boundaries.maxLatitude) / 2,
                    longitude: (info.boundaries.minLongitude + info.boundaries.maxLongitude) / 2,
                    altitude: 0
                };
                return Cesium.Cartesian3.fromDegrees(rawLocation.longitude, rawLocation.latitude, 0);
            }
            return null;
        }
        /**
         * Flies to a given entity's location.
         * @param viewer
         * @param info
         * @param duration: seconds duration for flight.
         * @returns: if a location to fly to was found successfully.
         */
        static FlyTo(viewer, info, duration = 0) {
            if (info === null || info === void 0 ? void 0 : info.boundaries) {
                let cartos = [
                    Cesium.Cartographic.fromDegrees(info.boundaries.minLongitude, info.boundaries.minLatitude),
                    Cesium.Cartographic.fromDegrees(info.boundaries.maxLongitude, info.boundaries.minLatitude),
                    Cesium.Cartographic.fromDegrees(info.boundaries.maxLongitude, info.boundaries.maxLatitude),
                    Cesium.Cartographic.fromDegrees(info.boundaries.maxLongitude, info.boundaries.maxLatitude)
                ];
                let boundaries = Cesium.Rectangle.fromCartographicArray(cartos);
                if (boundaries) {
                    viewer.scene.camera.flyTo({
                        duration: duration,
                        destination: boundaries
                    });
                    return true;
                }
            }
            let position = CesiumEntityUtils.CalculatePosition(viewer, info);
            if (position) {
                viewer.scene.camera.flyTo({
                    duration: duration,
                    destination: position
                });
                return true;
            }
            return false;
        }
        /**
         * Applies opacity to given entity's colours.
         * Applies to:
         * - polygon
         * - polyline
         * - point
         *
         * @param viewer
         * @param entity
         * @param opacity: value between 0 and 1.
         */
        static ApplyOpacity(viewer, entity, opacity) {
            if (entity.point) {
                let material = cesium_utils_2.CesiumUtils.getCesiumValue(viewer, entity.point.color);
                if ((material === null || material === void 0 ? void 0 : material.color) instanceof Cesium.Color) {
                    material = material.color;
                }
                if (material instanceof Cesium.Color) {
                    material.alpha = opacity;
                    entity.point.color = material;
                }
            }
            if (entity.polygon) {
                let material = cesium_utils_2.CesiumUtils.getCesiumValue(viewer, entity.polygon.material);
                if ((material === null || material === void 0 ? void 0 : material.color) instanceof Cesium.Color) {
                    material = material.color;
                }
                if (material instanceof Cesium.Color) {
                    material.alpha = opacity;
                    entity.polygon.material = material;
                }
            }
            if (entity.polyline) {
                let material = cesium_utils_2.CesiumUtils.getCesiumValue(viewer, entity.polyline.material);
                if ((material === null || material === void 0 ? void 0 : material.color) instanceof Cesium.Color) {
                    material = material.color;
                }
                if (material instanceof Cesium.Color) {
                    material.alpha = opacity;
                    entity.polyline.material = material;
                }
            }
        }
        /**
         * Clones and returns Cesium entity.
         * @param entity
         */
        static CloneEntity(entity) {
            let clone = new Cesium.Entity();
            if (entity.point) {
                clone.point = entity.point.clone();
            }
            if (entity.polygon) {
                clone.polygon = entity.polygon.clone();
            }
            if (entity.polyline) {
                clone.polyline = entity.polyline.clone();
            }
            if (entity.rectangle) {
                clone.rectangle = entity.rectangle.clone();
            }
            if (entity.ellipse) {
                clone.ellipse = entity.ellipse.clone();
            }
            if (entity.billboard) {
                clone.billboard = entity.billboard;
            }
            if (entity.position) {
                clone.position = entity.position;
            }
            if (entity.orientation) {
                clone.orientation = entity.orientation;
            }
            return clone;
        }
        /**
         * Returns the closest entity from given set at mouse position.
         * @param viewer
         * @param mouse
         * @param entities
         */
        static GetClosestEntity(viewer, mouse, entities) {
            var _a;
            if (entities.length <= 0) {
                return null;
            }
            try {
                let pos = cesium_drawing_utils_1.CesiumDrawingUtils.GetCartesian3FromMouse(viewer, mouse);
                // Mouse pos not valid, returning first entity as backup.
                if (!cesium_utils_2.CesiumUtils.ValidatePosition(pos)) {
                    return entities[0];
                }
                let closest = null;
                let distance = null;
                for (let i = 0; i < entities.length; i++) {
                    let entity = entities[i];
                    // I trust raycast when it comes to models and tileset features.
                    if (i == 0) {
                        let cEntity = entity.uiEntity;
                        if ((cEntity === null || cEntity === void 0 ? void 0 : cEntity.model) != null) {
                            return entity;
                        }
                        else if (cEntity instanceof Cesium.Primitive) {
                            return entity;
                        }
                        else if (cEntity instanceof Cesium.Cesium3DTileFeature) {
                            return entity;
                        }
                    }
                    let isCloser = false;
                    let entityDistance = null;
                    let entityPos = cesium_utils_2.CesiumUtils.getCesiumValue(viewer, (_a = entity.uiEntity) === null || _a === void 0 ? void 0 : _a.position);
                    if (entityPos) {
                        entityDistance = Cesium.Cartesian3.distance(entityPos, pos);
                        if (distance != null && entityDistance != null && entityDistance < distance) {
                            isCloser = true;
                        }
                    }
                    // If closer, or closest one currently has no valid distance.
                    if (isCloser || closest == null) {
                        closest = entity;
                        distance = entityDistance;
                    }
                }
                return closest;
            }
            // I don't trust anything, I need it to work 100% of the time.
            catch (_b) {
                return entities[0];
            }
        }
    }
    exports.CesiumEntityUtils = CesiumEntityUtils;
});
define("entry-points/cesium/visuals/cesium-bruce-entity", ["require", "exports", "cesium", "entry-points/cesium/common/cesium-utils", "entry-points/cesium/common/cesium-entity-utils"], function (require, exports, Cesium, cesium_utils_3, cesium_entity_utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumBruceEntity = void 0;
    Cesium = __importStar(Cesium);
    /**
     * Arbitrary class for any bruce entity we are rendering.
     */
    class CesiumBruceEntity {
        constructor(viewer, entities, bruceMeta) {
            // Visual references for this entity.
            this.uiEntities = [];
            this.viewer = viewer;
            this.uiEntities = entities;
            this.DoOnEntity((entity) => {
                this.applyInstance(entity);
            });
            this.bruceMeta = bruceMeta;
        }
        /**
         * Backwards compatability.
         * @deprecated Please use uiEntities now.
         */
        get uiEntity() {
            return this.uiEntities && this.uiEntities.length > 0 ? this.uiEntities[0] : null;
        }
        /**
         * Backwards compatability.
         * @deprecated Please use uiEntities now.
         */
        set uiEntity(value) {
            this.uiEntities = [value];
        }
        applyInstance(entity) {
            entity._bruceEntity = this;
            if (entity._bruceEntitySelected == null) {
                entity._bruceEntitySelected = false;
            }
        }
        removeInstance(entity) {
            entity._bruceEntity = null;
            entity._bruceEntitySelected = null;
        }
        /**
         * Adds a new visual to the bruce entity.
         * @param visual
         */
        AddVisual(visual) {
            if (visual) {
                if (this.uiEntities == null) {
                    this.uiEntities = [];
                }
                let index = this.uiEntities.findIndex(x => x && x.id == visual.id);
                if (index <= -1) {
                    this.applyInstance(visual);
                    this.uiEntities.push(visual);
                }
            }
        }
        /**
         * Removes a visual from the bruce entity.
         * @param visual
         */
        RemoveVisual(visual) {
            if (visual) {
                if (this.uiEntities == null) {
                    this.uiEntities = [];
                }
                let index = this.uiEntities.findIndex(x => x && x.id == visual.id);
                if (index <= -1) {
                    this.removeInstance(visual);
                    this.uiEntities.splice(index, 1);
                }
            }
        }
        dispose() {
            this.DoOnEntity((entity) => {
                this.removeInstance(entity);
            });
            this.bruceMeta = null;
        }
        /**
         * Returns BruceNavigatorEntity for given cesium entity.
         * If entity was not a bruce entity, null is returned.
         * @param entity
         */
        static FromCesiumEntity(entity) {
            let bruce = entity;
            if (bruce && bruce._bruceEntity) {
                return bruce._bruceEntity;
            }
            return null;
        }
        /**
         * Updates the colouring of the cesium visual entity.
         * If the entity is selected then it will update the 'old colours' it falls back on and updates the model fill colour.
         * @param color
         */
        Colorize(color) {
            this.DoOnEntity((entity) => {
                // If it's selected then update the oldMaterial / Color that it will be reverting to
                if (entity._bruceEntitySelected) {
                    if (entity instanceof Cesium.Primitive) {
                        if (entity.appearance.material.type == "Color") {
                            // @ts-ignore
                            entity.appearance._oldMaterial = color;
                        }
                    }
                    else if (entity instanceof Cesium.Cesium3DTileFeature) {
                        // @ts-ignore
                        entity._normalColor = color;
                    }
                    else if (entity instanceof Cesium.Entity) {
                        for (let e of cesium_utils_3.CesiumUtils.allEntities(entity)) {
                            if (e.polygon) {
                                // @ts-ignore
                                e.polygon.oldMaterial = color;
                            }
                            else if (e.polyline) {
                                // @ts-ignore
                                e.polyline.oldMaterial = color;
                            }
                            else if (e.point) {
                                // @ts-ignore
                                e.point.oldMaterial = color;
                            }
                            else if (e.billboard) {
                                // @ts-ignore
                                e.billboard.oldMaterial = color;
                            }
                            else if (e.model) {
                                // @ts-ignore
                                e.model.oldColor = color;
                                let scene = this.viewer.scene;
                                if (Cesium.PostProcessStageLibrary.isSilhouetteSupported(scene)) {
                                    // Selected models now use silhouettes so we can always update the fill
                                    e.model.color = color;
                                }
                            }
                        }
                    }
                }
                else {
                    if (entity instanceof Cesium.Primitive) {
                        if (entity.appearance.material.type == "Color") {
                            entity.appearance.material = color;
                        }
                    }
                    else if (entity instanceof Cesium.Cesium3DTileFeature) {
                        entity.color = color;
                    }
                    else if (entity instanceof Cesium.Entity) {
                        for (let e of cesium_utils_3.CesiumUtils.allEntities(entity)) {
                            if (e.polygon) {
                                e.polygon.material = color;
                            }
                            else if (e.polyline) {
                                e.polyline.material = color;
                            }
                            else if (e.point) {
                                e.point.color = color;
                            }
                            else if (e.billboard) {
                                e.billboard.color = color;
                            }
                            else if (e.model) {
                                e.model.color = color;
                            }
                        }
                    }
                }
            });
        }
        /**
         * Does a select / deselect depending on current selected state without affecting the selected count
         * This is used when the graphics of the entity have changed and an update is needed
         */
        RefreshSelect() {
            this.DoOnEntity((entity) => {
                if (entity._bruceEntitySelected == true) {
                    cesium_entity_utils_1.CesiumEntityUtils.HighlightEntity(this.viewer, entity);
                }
                else if (entity._bruceEntitySelected == false) {
                    cesium_entity_utils_1.CesiumEntityUtils.UnhighlightEntity(this.viewer, entity);
                }
            });
        }
        /**
         * Highlights the entity
         * Increments the selected count
         */
        Select() {
            this.DoOnEntity((entity) => {
                if (!entity._bruceEntitySelected) {
                    entity._bruceEntitySelected = true;
                    cesium_entity_utils_1.CesiumEntityUtils.HighlightEntity(this.viewer, entity);
                }
            });
        }
        /**
         * Decrements the selected count
         * Unighlights the entity if selected count is 0 or below
         */
        DeSelect() {
            this.DoOnEntity((entity) => {
                if (entity._bruceEntitySelected) {
                    entity._bruceEntitySelected = false;
                    cesium_entity_utils_1.CesiumEntityUtils.UnhighlightEntity(this.viewer, entity);
                }
            });
        }
        /**
         * Performs callback action on every visual entity.
         * @param action
         */
        DoOnEntity(action) {
            let entities = this.uiEntities;
            if (entities) {
                for (let i = 0; i < entities.length; i++) {
                    let entity = entities[i];
                    if (entity) {
                        action(entity);
                    }
                }
            }
        }
        /**
         * Performs async callback action on every visual entity.
         * @param action
         */
        DoAsyncOnEntity(action) {
            return __awaiter(this, void 0, void 0, function* () {
                let entities = this.uiEntities;
                if (entities) {
                    for (let i = 0; i < entities.length; i++) {
                        let entity = entities[i];
                        if (entity) {
                            yield action(entity);
                        }
                    }
                }
            });
        }
        /**
         * Clones all visuals and returns new Cesium entities for them.
         * Warning: Generated visuals are not added to Cesium Viewer.
         * Warning: Not all visuals can be cloned.
         * @returns: Successfully cloned visuals.
         */
        CloneVisuals() {
            let clones = [];
            this.DoOnEntity((cEntity) => {
                if (cEntity instanceof Cesium.Entity) {
                    let clone = cesium_entity_utils_1.CesiumEntityUtils.CloneEntity(cEntity);
                    if (clone) {
                        clones.push(clone);
                    }
                }
            });
            return clones;
        }
        /**
         * Returns first found entity from given screen position.
         * @param viewer
         * @param screenPos
         */
        static FromMouse(viewer, screenPos) {
            let many = this.ManyFromMouse(viewer, screenPos);
            if (many.length == 0) {
                return null;
            }
            else if (many.length == 1) {
                return many[0];
            }
            return cesium_entity_utils_1.CesiumEntityUtils.GetClosestEntity(viewer, screenPos, many);
        }
        /**
         * Returns array of entities from given screen position.
         * @param viewer
         * @param screenPos
         * @returns
         */
        static ManyFromMouse(viewer, screenPos) {
            // Drill picked list of cesium entities.
            let pickedObjects = viewer.scene.drillPick(screenPos, 8, 3, 3);
            let entities = [];
            for (let i = 0; i < pickedObjects.length; i++) {
                let object = pickedObjects[i];
                let entity = object && object.id && object.id instanceof Cesium.Entity ? object.id : object;
                let bruceEntity = cesium_utils_3.CesiumUtils.GetRealEntity(entity);
                if (bruceEntity) {
                    entities.push(bruceEntity);
                }
            }
            return entities;
        }
    }
    exports.CesiumBruceEntity = CesiumBruceEntity;
    // Counter to help differentiate loaded in entities.
    CesiumBruceEntity.ENTITY_ID = 0;
});
define("entry-points/cesium/menu-items/cesium-visual-register", ["require", "exports", "entry-points/common/bruce-meta", "entry-points/cesium/common/cesium-entity-utils", "utils/bruce-event"], function (require, exports, bruce_meta_2, cesium_entity_utils_2, bruce_event_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumVisualRegister = exports.VisualType = void 0;
    /**
     * Acceptable visual types.
     */
    var VisualType;
    (function (VisualType) {
        VisualType[VisualType["MODEL3D"] = 1] = "MODEL3D";
        VisualType[VisualType["GLB"] = 1] = "GLB";
        VisualType[VisualType["GEOMETRY"] = 2] = "GEOMETRY";
        VisualType[VisualType["POINT"] = 3] = "POINT";
        VisualType[VisualType["TILESET_FEATURE"] = 4] = "TILESET_FEATURE";
        VisualType[VisualType["CC3D"] = 4] = "CC3D"; // Deprecated, use tileset feature.
    })(VisualType = exports.VisualType || (exports.VisualType = {}));
    /**
     * Defines cesium visual registration.
     */
    class VisualRego {
        constructor(entity, type, priority) {
            this.entity = entity;
            this.type = type;
            this.priority = priority;
        }
        RemoveVisuals(viewer) {
            var _a;
            cesium_entity_utils_2.CesiumEntityUtils.RemoveEntities(viewer, (_a = this.entity) === null || _a === void 0 ? void 0 : _a.uiEntities);
        }
    }
    /**
     * Defines a cesium visual's highlight registration.
     */
    class VisualHighlightRego {
    }
    /**
     * Class to keep track of all rendered entities.
     */
    class CesiumVisualRegister {
        /**
         * Instantiates register for given viewer.
         * @param viewer
         */
        constructor(viewer) {
            // All current visual registrations identified by entity hashpaths.
            this.visuals = {};
            // Dictionary of entity IDs to auto highlight on adding / updating visuals.
            this.highlightedEntities = {};
            // List of hashpaths corresponding to entities that are hidden.
            this.hiddenEntities = [];
            // Called any update of visibility on individual meta.
            // Event provides visual rego that was enabled. If null then entity not visible.
            this.onVisualUpdate = new bruce_event_4.BruceEvent();
            this.viewer = viewer;
        }
        /**
         * @returns: visual update event to subscribe to.
         */
        getVisualUpdateEvent() {
            return this.onVisualUpdate;
        }
        /**
         * Returns visuals matching given meta.
         * @param meta
         */
        getVisuals(meta) {
            let result = [];
            let hash = meta.HashPath();
            if (this.visuals[hash]) {
                result = Object.values(this.visuals[hash]).map(x => x.entity);
            }
            return result;
        }
        /**
         * Returns array of entity hashpaths and their corresponding variants.
         */
        getAllVisuals() {
            let visuals = [];
            let rawVisuals = this.visuals;
            for (let prop in rawVisuals) {
                if (Object.prototype.hasOwnProperty.call(rawVisuals, prop)) {
                    let mapped = Object.values(rawVisuals[prop]).map(x => x.entity);
                    visuals.push({
                        hashPath: prop,
                        variants: mapped
                    });
                }
            }
            return visuals;
        }
        /**
         * Adds an entity to the visual register
         * All items to be added hiden andn the visual register will turn them on
         * @param entity the visual entity added
         * @param actualType the type of the visual used
         * @param intendedType the type of the visual that was requested originally
         * @param clamping the requested clamping style for the item
         * @param menuItem the menu item originating the item
         * @deprecated Please use Add() method instead.
         */
        addVisual(entity, actualType, intendedType, clamping, menuItem) {
            //this.Add(entity, actualType, intendedType, clamping, menuItem);
            this.Add(entity, actualType, menuItem);
        }
        /**
         * Registers a given entity for a given menu item.
         * @param entity
         * @param type
         * @param menuItemId
         * @param priority The higher the number the more priority this has over other registrations.
         */
        Add(entity, type, menuItemId, priority = 0) {
            let oldRegistration;
            let hashPath = entity.bruceMeta.HashPath();
            let registration = this.visuals[hashPath];
            if (registration) {
                // Get the previous registration for this entity from the same menu item.
                oldRegistration = registration[menuItemId];
            }
            else {
                this.visuals[hashPath] = registration = {};
            }
            // Update value using provided entity.
            registration[menuItemId] = new VisualRego(entity, type, priority);
            // Run an update on the entity's visuals.
            this.UpdateVisibilityOfEntity(hashPath);
            // Remove the old registration.
            if (oldRegistration) {
                oldRegistration.RemoveVisuals(this.viewer);
            }
        }
        /**
         * Remove entity visual for a provided menu item.
         * @param menuItem
         * @param item
         * @deprecated Please use RemoveForMenuItem() method instead.
         */
        removeVisualForMenuItem(menuItem, item) {
            this.RemoveForMenuItem(menuItem, item);
        }
        /**
         * Remove entity visual for a provided menu item.
         * @param menuItemId
         * @param meta
         */
        RemoveForMenuItem(menuItemId, meta) {
            let hashPath = meta.HashPath();
            let registration = this.visuals[hashPath];
            if (registration) {
                let menuItemVisual = registration[menuItemId];
                if (menuItemVisual) {
                    // Delete menu item's registration.
                    delete registration[menuItemId];
                    // Remove visual associated with the menu item's specific rego.
                    menuItemVisual.RemoveVisuals(this.viewer);
                    // Update with whatever other menu items are left.
                    this.UpdateVisibilityOfEntity(hashPath);
                    // This was the last menu item registration of this entity.
                    if (Object.keys(registration).length <= 0) {
                        delete this.visuals[hashPath];
                    }
                    this.viewer.scene.requestRender();
                }
            }
        }
        /**
         * Returns all visuals for a menu item.
         * Note that these visuals may not be the ones visible as another menu item with higher-
         * render priority rendered them instead.
         * @param menuItemId
         */
        getByMenuItem(menuItemId) {
            let visuals = [];
            let keys = Object.keys(this.visuals);
            for (let i = 0; i < keys.length; i++) {
                let registration = this.visuals[keys[i]];
                let menuItemVisual = registration === null || registration === void 0 ? void 0 : registration[menuItemId];
                if (menuItemVisual) {
                    visuals.push(menuItemVisual.entity);
                }
            }
            return visuals;
        }
        /**
         * Removes all visuals corresponding to given meta.
         * @deprecated Please use Remove() method instead.
         * @param item
         */
        removeVisual(item) {
            this.Remove(item);
        }
        /**
         * Removes all visuals for a single entity.
         * @param meta
         */
        Remove(meta) {
            let hashPath = meta.HashPath();
            let registration = this.visuals[hashPath];
            if (registration) {
                for (let menuItemId in registration) {
                    let menuItemVisual = registration[menuItemId];
                    menuItemVisual.RemoveVisuals(this.viewer);
                }
                delete this.visuals[hashPath];
                this.viewer.scene.requestRender();
            }
        }
        /**
         * Reviews the entity visuals and picks one to display.
         */
        UpdateVisibilityOfEntity(hashPath, render = true) {
            let registration = this.visuals[hashPath];
            if (registration) {
                let visualTypes = [VisualType.MODEL3D, VisualType.TILESET_FEATURE, VisualType.GEOMETRY, VisualType.POINT];
                let validRego;
                for (let menuItemId in registration) {
                    let menuItemVisual = registration[menuItemId];
                    if ((!validRego || validRego.priority < menuItemVisual.priority) && visualTypes.includes(menuItemVisual.type)) {
                        validRego = menuItemVisual;
                    }
                    menuItemVisual.entity.DoOnEntity((cesiumEntity) => {
                        cesiumEntity.show = false;
                    });
                }
                if (validRego && !this.hiddenEntities.includes(hashPath)) {
                    validRego.entity.DoOnEntity((cesiumEntity) => {
                        cesiumEntity.show = true;
                    });
                    if (this.isHighlighted(hashPath)) {
                        validRego.entity.Select();
                    }
                }
                if (render) {
                    this.viewer.scene.requestRender();
                }
                this.onVisualUpdate.Trigger(validRego);
            }
        }
        /**
         * Adds given entity ID to list of highlighted entities, if visual already exists, it highlights it.
         * @param bruceMeta
         * @deprecated Please use Highlight() method instead.
         */
        highlightEntity(bruceMeta) {
            this.Highlight(bruceMeta);
        }
        /**
         * Adds given entity ID to list of highlighted entities, if visual already exists, it highlights it.
         * @param meta
         */
        Highlight(meta) {
            let hash = meta.HashPath();
            let highlightRec = this.highlightedEntities[hash];
            if (highlightRec) {
                highlightRec.count += 1;
            }
            else {
                this.highlightedEntities[hash] =
                    {
                        count: 1,
                        meta: meta
                    };
            }
            let visuals = this.getVisuals(meta);
            for (let i = 0; i < visuals.length; i++) {
                let visual = visuals[i];
                visual.Select();
            }
        }
        /**
         * Removes given meta from list of highlighted entities, if visual already exists, it unhighlights it
         * @param bruceMeta
         * @deprecated Please use Unhighlight() instead.
         */
        removeHighlight(bruceMeta) {
            this.Unhighlight(bruceMeta);
        }
        /**
         * Removes given meta from list of highlighted entities, if visual already exists, it unhighlights it
         * @param meta
         */
        Unhighlight(meta) {
            let hash = meta.HashPath();
            // We only want to remove highlight if count drops to 0.
            let removeHighlight = true;
            let highlightRec = this.highlightedEntities[hash];
            if (highlightRec) {
                highlightRec.count -= 1;
                if (highlightRec.count <= 0) {
                    delete this.highlightedEntities[hash];
                }
                else {
                    removeHighlight = false;
                }
            }
            if (removeHighlight) {
                let visuals = this.getVisuals(meta);
                for (let i = 0; i < visuals.length; i++) {
                    let visual = visuals[i];
                    visual.DeSelect();
                }
            }
        }
        /**
         * Returns if a given meta exists within the visual register.
         * @param meta
         */
        DoesExist(meta) {
            if (!meta) {
                return false;
            }
            let hash = meta.HashPath();
            let visual = this.visuals[hash];
            return !!visual;
        }
        /**
         * Returns if a given meta is highlighted within the visual register.
         * @param meta
         */
        IsHightlighted(meta) {
            if (!meta) {
                return false;
            }
            let hash = meta.HashPath();
            return this.isHighlighted(hash);
        }
        isHighlighted(hashpath) {
            let highlightRec = this.highlightedEntities[hashpath];
            return highlightRec != null && highlightRec.count > 0;
        }
        /**
         * Returns all highlighted entities.
         */
        getHighlightedEntities() {
            let highlights = Object.keys(this.highlightedEntities);
            let entities = [];
            for (let i = 0; i < highlights.length; i++) {
                let highlight = this.highlightedEntities[highlights[i]];
                if (highlight.meta) {
                    entities.push(highlight.meta);
                }
            }
            return entities;
        }
        /**
         * Isolates entity visuals corresponding to given meta.
         * Pass null to remove isolation.
         * @param meta
         */
        Isolate(meta) {
            let hash = meta ? meta.HashPath() : null;
            if (this.isolatedEntity != hash) {
                this.isolatedEntity = hash;
                let visuals = this.getAllVisuals();
                for (let i = 0; i < visuals.length; i++) {
                    let visual = visuals[i];
                    for (let j = 0; j < visual.variants.length; j++) {
                        this.UpdateVisibilityOfEntity(visual.hashPath);
                    }
                }
            }
        }
        /**
         * Returns current isolated entity's hashpath.
         */
        getIsolated() {
            return this.isolatedEntity;
        }
        /**
         * Hides visuals corresponding to given meta.
         * @param meta
         */
        Hide(meta) {
            let hashPath = meta.HashPath();
            if (!this.hiddenEntities.includes(hashPath)) {
                this.hiddenEntities.push(hashPath);
                this.UpdateVisibilityOfEntity(hashPath, true);
            }
        }
        HideByHashPath(hashPath) {
            if (!this.hiddenEntities.includes(hashPath)) {
                this.hiddenEntities.push(hashPath);
                this.UpdateVisibilityOfEntity(hashPath, true);
            }
        }
        HideByPath(path) {
            let hashPath = bruce_meta_2.BruceMeta.HashPath(path);
            if (!this.hiddenEntities.includes(hashPath)) {
                this.hiddenEntities.push(hashPath);
                this.UpdateVisibilityOfEntity(hashPath, true);
            }
        }
        /**
         * Hides array of visuals corresponding to given metas.
         * @param metas
         */
        HideList(metas) {
            for (let i = 0; i < metas.length; i++) {
                let meta = metas[i];
                let hashPath = meta.HashPath();
                if (!this.hiddenEntities.includes(hashPath)) {
                    this.hiddenEntities.push(hashPath);
                    this.UpdateVisibilityOfEntity(hashPath, false);
                }
            }
            this.viewer.scene.requestRender();
        }
        /**
         * Unhides visuals corresponding to given meta.
         * @param meta
         */
        Unhide(meta) {
            let hashPath = meta.HashPath();
            if (this.hiddenEntities.includes(hashPath)) {
                this.hiddenEntities = this.hiddenEntities.filter((value) => (value != hashPath));
                this.UpdateVisibilityOfEntity(hashPath);
            }
        }
        /**
         * Unhides list of visuals corresponding to given meta.
         * @param meta
         */
        UnhideList(metas) {
            for (let i = 0; i < metas.length; i++) {
                let meta = metas[i];
                let hashPath = meta.HashPath();
                if (this.hiddenEntities.includes(hashPath)) {
                    this.hiddenEntities = this.hiddenEntities.filter((value) => (value != hashPath));
                    this.UpdateVisibilityOfEntity(hashPath, false);
                }
            }
            this.viewer.scene.requestRender();
        }
        /**
         * Unhides all hidden visuals.
         */
        UnhideAll() {
            let items = this.hiddenEntities;
            this.hiddenEntities = [];
            items.forEach((item) => {
                this.UpdateVisibilityOfEntity(item);
            });
        }
        /**
         * Returns array of hashpaths corresponding to hidden visuals.
         */
        getHidden() {
            return this.hiddenEntities;
        }
        /**
         * Returns if visuals corresponding to given meta are set to be hidden or not.
         * @param meta
         * @returns
         */
        isHidden(meta) {
            if (meta) {
                let hash = meta.HashPath();
                return this.hiddenEntities.findIndex(x => x == hash) > -1;
            }
            else {
                return false;
            }
        }
        /**
         * Returns if visuals corresponding to given meta are isolated.
         * @param meta
         */
        isIsolated(meta) {
            if (meta) {
                let hash = meta.HashPath();
                return this.isolatedEntity == hash;
            }
            else {
                return false;
            }
        }
    }
    exports.CesiumVisualRegister = CesiumVisualRegister;
});
define("utils/bruce-event-disposable", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceEventDisposable = void 0;
    class BruceEventDisposable {
        constructor() {
            this._eventRemoveCallbacks = [];
            // If dispose event has been called at least once.
            this.disposed = false;
        }
        /**
         * Records a given event id.
         * @param eventId
         */
        addDisposable(removeCallback) {
            this._eventRemoveCallbacks.push(removeCallback);
        }
        /**
         * Disposes any recorded subscriptions.
         */
        dispose() {
            this.disposed = true;
            let eventRemvoeCallbacks = this._eventRemoveCallbacks;
            for (let i = 0; i < eventRemvoeCallbacks.length; i++) {
                let removeCallback = eventRemvoeCallbacks[i];
                removeCallback();
            }
            this._eventRemoveCallbacks = [];
        }
    }
    exports.BruceEventDisposable = BruceEventDisposable;
});
define("entry-points/cesium/visuals/cesium-generator-geometry", ["require", "exports", "cesium", "entry-points/common/calculator", "utils/bruce-event-disposable", "utils/object-utils", "entry-points/cesium/visuals/cesium-bruce-entity", "entry-points/common/bruce-meta", "entry-points/cesium/common/cesium-utils", "bruce-models/common/geometry", "bruce-models/common/altitude-options", "bruce-models/common/camera-zoom-control", "entry-points/cesium/common/cesium-entity-utils", "bruce-models/common/client-file"], function (require, exports, Cesium, calculator_2, bruce_event_disposable_1, object_utils_40, cesium_bruce_entity_3, bruce_meta_3, cesium_utils_4, geometry_4, altitude_options_2, camera_zoom_control_3, cesium_entity_utils_3, client_file_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumGeneratorGeometry = void 0;
    Cesium = __importStar(Cesium);
    const DEFAULT_COLOR = "rgb(0,0,0)";
    const DEFAULT_WIDTH = 3;
    const DEFAULT_POINT_COLOR = "rgba(33,150,243,0.8)";
    const DEFAULT_POLYGON_COLOR = "rgba(139,195,74,0.8)";
    const DEFAULT_POLYGON_LINE_COLOR = "rgba(80,80,80,0.8)";
    const DEFAULT_POLYLINE_COLOR = "rgba(255,193,7,0.8)";
    class CesiumGeneratorGeometry extends bruce_event_disposable_1.BruceEventDisposable {
        constructor(api, viewer, style, cesiumEntity) {
            super();
            // Caluclator used for non-static values
            this.calculator = new calculator_2.Calculator();
            this.api = api;
            this.viewer = viewer;
            this.parent = cesiumEntity;
            if (style) {
                this.pointStyle = style.pointStyle;
                this.polygonStyle = style.polygonStyle;
                this.polylineStyle = style.polylineStyle;
            }
            if (!this.pointStyle) {
                this.pointStyle = {};
            }
            if (!this.polygonStyle) {
                this.polygonStyle = {};
            }
            if (!this.polylineStyle) {
                this.polylineStyle = {};
            }
            this.init();
        }
        /**
         * Initializes styles for the calculator to reference later.
         */
        init() {
            // Returns picker value / type object from given value type
            // Used to set default values a bit easier
            let getDefaultPickerValue = (type = calculator_2.FieldPickerType.Input, defaultValue) => [{ type: type, value: defaultValue }];
            // Point styling
            this.pointStyle.color = object_utils_40.ObjectUtils.evl(this.pointStyle.color, getDefaultPickerValue(calculator_2.FieldPickerType.Color, DEFAULT_POINT_COLOR));
            this.pointStyle.size = object_utils_40.ObjectUtils.evl(this.pointStyle.size, getDefaultPickerValue(calculator_2.FieldPickerType.Input, DEFAULT_POINT_COLOR));
            this.pointStyle.iconScale = object_utils_40.ObjectUtils.evl(this.pointStyle.iconScale, getDefaultPickerValue(calculator_2.FieldPickerType.Input, 1));
            // Polygon styling
            this.polygonStyle.fillColor = object_utils_40.ObjectUtils.evl(this.polygonStyle.fillColor, getDefaultPickerValue(calculator_2.FieldPickerType.Color, DEFAULT_POLYGON_COLOR));
            this.polygonStyle.lineColor = object_utils_40.ObjectUtils.evl(this.polygonStyle.lineColor, getDefaultPickerValue(calculator_2.FieldPickerType.Input, DEFAULT_POLYGON_LINE_COLOR));
            this.polygonStyle.lineWidth = object_utils_40.ObjectUtils.evl(this.polygonStyle.lineWidth, getDefaultPickerValue(calculator_2.FieldPickerType.Input, DEFAULT_WIDTH));
            // Polyline styling
            this.polylineStyle.lineColor = object_utils_40.ObjectUtils.evl(this.polylineStyle.lineColor, getDefaultPickerValue(calculator_2.FieldPickerType.Input, DEFAULT_POLYLINE_COLOR));
            this.polylineStyle.lineWidth = object_utils_40.ObjectUtils.evl(this.polylineStyle.lineWidth, getDefaultPickerValue(calculator_2.FieldPickerType.Input, DEFAULT_WIDTH));
        }
        /**
         * Generates cesium entity and returns bruce navigator entity.
         * @param info The bruce info to use for style calculations.
         * @param displayType If we should be going down the tree of priorities or drawing a fixed type.
         */
        loadEntity(info, displayType) {
            // Create bruce navigator entity
            let meta = new bruce_meta_3.BruceMeta([info.Bruce.ID], info.Bruce["EntityType.ID"], this.api.clientAccountId);
            let bruceEntity = new cesium_bruce_entity_3.CesiumBruceEntity(this.viewer, [], meta);
            // Update the cesium entity's geometry
            this.updateGeometry(bruceEntity, info, info.geometry, displayType);
            // Return result
            return bruceEntity;
        }
        generateVisual(bruceEntity, info) {
            let entityID = info.Bruce.ID;
            let position = this.getSinglePosition(info);
            // Create cesium entity
            if (this.viewer.entities.contains(this.parent) && cesium_utils_4.CesiumUtils.ValidatePosition(position)) {
                let visual = this.viewer.entities.add(new Cesium.Entity({
                    id: `__entity_geom_${(++cesium_bruce_entity_3.CesiumBruceEntity.ENTITY_ID)}_${entityID}`,
                    position: position,
                    parent: this.parent,
                    show: false
                }));
                bruceEntity.AddVisual(visual);
                return visual;
            }
            return null;
        }
        /**
         * Returns position value to use for points from given bruce info.
         * @param info
         */
        getSinglePosition(info) {
            return cesium_entity_utils_3.CesiumEntityUtils.CalculatePosition(this.viewer, info);
        }
        /**
        * Updates the geometry for given cesium entity.
        * @param info What bruce info to use for non-static style calculations?
        * @param geometry What geometry are we reading to use for the update?
        * @param displayType If we should be going down the tree of priorities or drawing a fixed type.
        */
        updateGeometry(bruceEntity, info, geometry, displayType) {
            if (!geometry) {
                // No geometry AND no location? Then definitely cant show anything
                if (!info.location) {
                    return;
                }
                geometry = new geometry_4.Geometry(null);
            }
            // Returns point geometry position
            // (needed in 2 places here and I dont want to write this mess out twice)
            // (The reason I cant just do this.getSinglePosition is because we want geometry priority not location priority here)
            let getPointPos = () => {
                let pointGeo = geometry.Point;
                let points = typeof pointGeo == "string" ? cesium_utils_4.CesiumUtils.ParsePoints(pointGeo) : pointGeo;
                return points && points.length > 0 ? points[0] : null;
            };
            // We want a point! give us a point!
            if (displayType == camera_zoom_control_3.ECameraZoomControlDisplayType.Point) {
                this.createPoint(bruceEntity, info, getPointPos());
            }
            // Create polygon
            else if (geometry.Polygon && geometry.Polygon.length > 0) {
                let hierarchy = this.getPolygonGraphics(geometry.Polygon);
                if (hierarchy) {
                    this.createPolygon(bruceEntity, info, hierarchy);
                }
            }
            // Create polyline
            else if (geometry.LineString && geometry.LineString.length > 0) {
                this.createPolyline(bruceEntity, info, geometry.LineString);
            }
            // Create surface polygon
            else if (geometry.MultiSurface && geometry.MultiSurface.length > 0) {
                let hierarchy = this.createSurfaceGraphics(geometry.MultiSurface);
                if (hierarchy) {
                    this.createPolygon(bruceEntity, info, hierarchy);
                }
            }
            // There is multiple geometry, create multiple
            else if (geometry.MultiGeometry && geometry.MultiGeometry.length > 0) {
                for (let i = 0; i < geometry.MultiGeometry.length; i++) {
                    let geo = geometry.MultiGeometry[i];
                    this.updateGeometry(bruceEntity, info, geo, displayType);
                }
            }
            // Create point
            else {
                this.createPoint(bruceEntity, info, getPointPos());
            }
        }
        /**
         * Creates point / billboard geometry for current cesium entity.
         * @param bruceEntity
         * @param info
         * @param pos
         */
        createPoint(bruceEntity, info, pos) {
            // If position is missing, let's try calculate it from other parts of the record
            if (!pos || pos.x == null) {
                pos = this.getSinglePosition(info);
            }
            // If we are still missing the position we cant do anything
            if (pos && pos.x != null) {
                let icon;
                let iconScale;
                // We want a billboard picture instead of point graphics
                if (this.pointStyle.useIcon) {
                    // Get icon from icon URL
                    icon = this.calculator.calcValues(info.raw, this.pointStyle.iconUrl);
                    // Let's try fallback to an iconId...
                    if (!icon && this.pointStyle.iconId) {
                        icon = client_file_2.ClientFile.getClientFileURL(this.api, this.pointStyle.iconId);
                    }
                    // If we have an icon let's calculate its scale, otherwise we're creating point graphics afterall
                    iconScale = icon ? object_utils_40.ObjectUtils.nvl(this.calculator.calcValues(info.raw, this.pointStyle.iconScale), 1) : null;
                }
                let heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
                let altitudeOptionID = object_utils_40.ObjectUtils.FindValue(this.pointStyle, ["altitudeOption", "id"]);
                if (altitudeOptionID == null) {
                    altitudeOptionID = altitude_options_2.EAltitudeOption.ClampToGround;
                }
                switch (altitudeOptionID) {
                    case altitude_options_2.EAltitudeOption.Absolute:
                        heightReference = Cesium.HeightReference.NONE;
                        break;
                    case altitude_options_2.EAltitudeOption.FromGround:
                        heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                        break;
                }
                let cesiumEntity = this.generateVisual(bruceEntity, info);
                // Time to create billboard!
                if (icon) {
                    cesiumEntity.billboard = new Cesium.BillboardGraphics({
                        image: icon,
                        horizontalOrigin: Cesium.HorizontalOrigin.CENTER,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        heightReference: heightReference,
                        scale: iconScale
                    });
                    cesiumEntity.position = pos;
                }
                // Creating point graphics
                else {
                    // Color of the point
                    let colorRaw = object_utils_40.ObjectUtils.nvl(this.calculator.calcValues(info.raw, this.pointStyle.color), DEFAULT_COLOR);
                    let color = this.calculator.getColor(colorRaw);
                    // Pixel width of the point
                    let width = object_utils_40.ObjectUtils.nvl(object_utils_40.ObjectUtils.parseNum(this.calculator.calcValues(info.raw, this.pointStyle.size)), DEFAULT_WIDTH);
                    cesiumEntity.point = new Cesium.PointGraphics({
                        color: cesium_utils_4.CesiumUtils.ColorToCesiumColor(color),
                        pixelSize: width,
                        heightReference: heightReference
                    });
                    cesiumEntity.position = pos;
                }
            }
        }
        /**
         * Creates polyline geometry for the current cesium entity.
         * @param bruceEntity
         * @param info
         * @param line
         */
        createPolyline(bruceEntity, info, line) {
            let posses = line && typeof line == "string" ? cesium_utils_4.CesiumUtils.ParsePoints(line) : line;
            if (!posses || posses.length < 2) {
                return;
            }
            let bcolor = this.calculator.getColor(this.calculator.calcValues(info.raw, this.polylineStyle.lineColor));
            let color = cesium_utils_4.CesiumUtils.ColorToCesiumColor(bcolor);
            let width = parseFloat(this.calculator.calcValues(info.raw, this.polylineStyle.lineWidth));
            if (width <= 0 || !this.isColorVisible(color)) {
                return null;
            }
            let altitudeOptionID = object_utils_40.ObjectUtils.FindValue(this.polylineStyle, ["altitudeOption", "id"]);
            if (altitudeOptionID == null) {
                altitudeOptionID = altitude_options_2.EAltitudeOption.ClampToGround;
            }
            let cesiumEntity = this.generateVisual(bruceEntity, info);
            if (cesiumEntity) {
                cesiumEntity.polyline = new Cesium.PolylineGraphics({
                    positions: posses,
                    material: color,
                    width: width,
                    clampToGround: altitudeOptionID == altitude_options_2.EAltitudeOption.ClampToGround,
                    classificationType: Cesium.ClassificationType.TERRAIN,
                    arcType: Cesium.ArcType.GEODESIC
                    //followSurface: altitudeOptionID == EAltitudeOption.ClampToGround || altitudeOptionID == EAltitudeOption.FromGround
                });
            }
        }
        /**
         * Creates polygon geometry for the current cesium entity.
         * @param bruceEntity
         * @param info
         * @param hierarchy
         */
        createPolygon(bruceEntity, info, hierarchy) {
            let bfillColor = this.calculator.getColor(this.calculator.calcValues(info.raw, this.polygonStyle.fillColor));
            let fillColor = cesium_utils_4.CesiumUtils.ColorToCesiumColor(bfillColor);
            let blineColor = this.calculator.getColor(this.calculator.calcValues(info.raw, this.polygonStyle.lineColor));
            let lineColor = cesium_utils_4.CesiumUtils.ColorToCesiumColor(blineColor);
            let lineWidth = object_utils_40.ObjectUtils.parseNum(this.calculator.calcValues(info.raw, this.polygonStyle.lineWidth));
            let polygonFilled = this.isColorVisible(fillColor);
            let polygonHasBorder = lineWidth > 0 && lineColor != null && this.isColorVisible(lineColor);
            let hasHoles = hierarchy && hierarchy.holes && hierarchy.holes.length ? true : false;
            let heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
            let altitudeOptionID = object_utils_40.ObjectUtils.FindValue(this.polygonStyle, ["altitudeOption", "id"]);
            if (altitudeOptionID == null) {
                altitudeOptionID = altitude_options_2.EAltitudeOption.ClampToGround;
            }
            switch (altitudeOptionID) {
                case altitude_options_2.EAltitudeOption.Absolute:
                    heightReference = Cesium.HeightReference.NONE;
                    break;
                case altitude_options_2.EAltitudeOption.FromGround:
                    heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                    break;
            }
            let clampToGround = altitudeOptionID == altitude_options_2.EAltitudeOption.ClampToGround;
            let cesiumEntity = this.generateVisual(bruceEntity, info);
            if (!cesiumEntity) {
                return;
            }
            // Only create polygon entity if fill colour is visible
            // === currently always drawing. If we draw polygon then tools assume polygon exists. ===
            if (true || polygonFilled) {
                let extrusion = this.getExtrusion(info);
                if (!extrusion) {
                    extrusion = undefined;
                }
                cesiumEntity.polygon = new Cesium.PolygonGraphics({
                    hierarchy: hierarchy,
                    material: !polygonFilled ? Cesium.Color.TRANSPARENT : fillColor,
                    extrudedHeight: extrusion,
                    extrudedHeightReference: extrusion ? Cesium.HeightReference.RELATIVE_TO_GROUND : undefined,
                    shadows: Cesium.ShadowMode.ENABLED,
                    heightReference: heightReference,
                    height: undefined,
                    clampToGround: clampToGround,
                    classificationType: Cesium.ClassificationType.BOTH,
                    perPositionHeight: altitudeOptionID == altitude_options_2.EAltitudeOption.ClampToGround ? false : true
                });
            }
            // Lets create a polyline for the border
            if (polygonHasBorder) {
                let polylinePosses = this.closePolygon(hierarchy.positions);
                cesiumEntity.polyline = new Cesium.PolylineGraphics({
                    positions: polylinePosses,
                    material: lineColor,
                    width: lineWidth,
                    followSurface: altitudeOptionID == altitude_options_2.EAltitudeOption.ClampToGround || altitudeOptionID == altitude_options_2.EAltitudeOption.FromGround,
                    clampToGround: clampToGround,
                    classificationType: Cesium.ClassificationType.TERRAIN,
                    arcType: Cesium.ArcType.GEODESIC
                });
                // The hierarchy had holes! let's create more polylines...
                if (hasHoles) {
                    for (let i = 0; i < hierarchy.holes.length; i++) {
                        let hole = hierarchy.holes[i];
                        this.viewer.entities.add(cesium_entity_utils_3.CesiumEntityUtils.MarkarkAsInner(new Cesium.Entity({
                            parent: cesiumEntity,
                            polyline: new Cesium.PolylineGraphics({
                                positions: hole.positions,
                                material: lineColor,
                                width: lineWidth,
                                clampToGround: clampToGround,
                                classificationType: Cesium.ClassificationType.TERRAIN,
                                arcType: Cesium.ArcType.GEODESIC
                            })
                        })));
                    }
                }
            }
        }
        /**
         * Returns extrusion value caluclated from given bruce info.
         * @param bruceInfo
         */
        getExtrusion(bruceInfo) {
            let path = this.polygonStyle.extrusionPath;
            if (!this.polygonStyle.useExtrusion || !path) {
                return null;
            }
            try {
                let result = object_utils_40.ObjectUtils.parseNum(this.calculator.calcValues(bruceInfo.raw, path));
                if (result == null || isNaN(result)) {
                    return null;
                }
                return result;
            }
            catch (e) {
                return 0;
            }
        }
        /**
         * Creates polygon hierarchy from given surface geometry string.
         * @param surface
         */
        createSurfaceGraphics(surface) {
            let numbers = surface.trim().split(" ");
            let longLatHeight = [];
            for (let i = 0; i < numbers.length; i++) {
                let num = numbers[i];
                longLatHeight.push(parseFloat(num));
                if (i % 2 != 0) {
                    longLatHeight.push(0);
                }
            }
            let points = Cesium.Cartesian3.fromDegreesArrayHeights(longLatHeight);
            if (points) {
                return new Cesium.PolygonHierarchy(points, null);
            }
            else {
                return null;
            }
        }
        /**
         * Creates cesium polygon hierarchy from given bruce polygon hierarchy record.
         * @param polygons
         */
        getPolygonGraphics(polygons) {
            let result = [];
            for (let i = 0; i < polygons.length; i++) {
                let polygon = polygons[i];
                let points = cesium_utils_4.CesiumUtils.ParsePoints(polygon.LinearRing);
                points = geometry_4.Geometry.CleanCartesian3Points(points);
                if (points.length > 2) {
                    if (polygon.Facing === "out") {
                        let item = new Cesium.PolygonHierarchy(points, []);
                        result.push(item);
                    }
                    else if (polygon.Facing === "in" && result.length) {
                        let last = result[result.length - 1];
                        last.holes.push(new Cesium.PolygonHierarchy(points));
                    }
                }
            }
            if (result.length) {
                return new Cesium.PolygonHierarchy(result[0].positions, result[0].holes);
            }
            else {
                return null;
            }
        }
        /**
         * Closes a polygon shape (makes sure first and last points are the same).
         * @param posses
         */
        closePolygon(posses) {
            if (posses.length < 2) {
                return posses;
            }
            else {
                // So we dont affect the referenced object
                let tmp = [].concat(posses);
                // If the first and last points do not match, add first point to end
                if (tmp.length > 2 && !Cesium.Cartesian3.equals(tmp[0], tmp[tmp.length - 1])) {
                    tmp.push(tmp[0]);
                }
                return tmp;
            }
        }
        /**
         * @param color
         * @returns: if a given colour is visible or not (exists and has above 0 alpha).
         */
        isColorVisible(color) {
            return color && color.alpha > 0;
        }
    }
    exports.CesiumGeneratorGeometry = CesiumGeneratorGeometry;
});
define("entry-points/cesium/visuals/cesium-generator-model", ["require", "exports", "cesium", "utils/bruce-event-disposable", "utils/object-utils", "entry-points/cesium/visuals/cesium-bruce-entity", "entry-points/common/bruce-meta", "entry-points/common/calculator", "entry-points/cesium/common/cesium-utils", "bruce-models/common/altitude-options", "bruce-models/common/geometry", "bruce-models/common/lod"], function (require, exports, Cesium, bruce_event_disposable_2, object_utils_41, cesium_bruce_entity_4, bruce_meta_4, calculator_3, cesium_utils_5, altitude_options_3, geometry_5, lod_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumGeneratorModel = void 0;
    Cesium = __importStar(Cesium);
    class CesiumGeneratorModel extends bruce_event_disposable_2.BruceEventDisposable {
        constructor(api, viewer, modelStyle, lodCategory, lod, cesiumEntity) {
            super();
            // Caluclator used for non-static values
            this.calculator = new calculator_3.Calculator();
            // Counter used to kill cache
            this.counter = 0;
            this.api = api;
            this.viewer = viewer;
            this.parent = cesiumEntity;
            this.modelStyle = modelStyle;
            if (!this.modelStyle) {
                this.modelStyle = {};
            }
            this.lodCategory = lodCategory;
            this.lod = lod;
        }
        /**
         * Loads a GLB entity
         * @param info the bruce data
         * @param noCache Adds a fake param to the GLB url (cant be used with strict LOD)
        */
        loadEntity(info, noCache = false) {
            var _a;
            return __awaiter(this, void 0, void 0, function* () {
                let id = (_a = info === null || info === void 0 ? void 0 : info.Bruce) === null || _a === void 0 ? void 0 : _a.ID;
                let bruceEntity = null;
                // Without LOD category we don't know what to draw it
                // We need this to find LOD
                if (this.lodCategory) {
                    let url = yield lod_1.LOD.getURL(this.api, id, this.lodCategory, this.lod, false);
                    if (url) {
                        // Kill cache
                        if (noCache) {
                            url += "?token=" + (this.counter++);
                        }
                        /// Get height reference ///
                        let heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                        let altitudeOptionID = object_utils_41.ObjectUtils.FindValue(this.modelStyle, ["altitudeOption", "id"]);
                        if (altitudeOptionID == null) {
                            altitudeOptionID = altitude_options_3.EAltitudeOption.FromGround;
                        }
                        switch (altitudeOptionID) {
                            case altitude_options_3.EAltitudeOption.Absolute:
                                heightReference = Cesium.HeightReference.NONE;
                                break;
                            case altitude_options_3.EAltitudeOption.FromGround:
                                heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                                break;
                            case altitude_options_3.EAltitudeOption.ClampToGround:
                                // Clamp to ground does not work with models
                                // It always makes it relative so we use relative and set height to 0 ourselves
                                heightReference = Cesium.HeightReference.RELATIVE_TO_GROUND;
                                break;
                        }
                        /// Get location ///
                        let position = this.getSinglePosition(info);
                        // If we're clamping to the ground we need to make position's height equal to 0
                        if (altitudeOptionID == altitude_options_3.EAltitudeOption.ClampToGround) {
                            position = this.zeroHeight(position);
                        }
                        /// Get Orientation ///
                        let transform = info === null || info === void 0 ? void 0 : info.transform;
                        let heading = 0;
                        let pitch = 0;
                        let roll = 0;
                        let scale = 1;
                        // Load transform values from bruce rec
                        if (transform) {
                            if (transform.heading) {
                                heading = object_utils_41.ObjectUtils.parseNum(transform.heading);
                            }
                            if (transform.pitch) {
                                pitch = object_utils_41.ObjectUtils.parseNum(transform.pitch);
                            }
                            if (transform.roll) {
                                roll = object_utils_41.ObjectUtils.parseNum(transform.roll);
                            }
                            if (transform.scale) {
                                scale = object_utils_41.ObjectUtils.parseNum(transform.scale);
                                if (scale <= 0 || scale == null) {
                                    scale = 1;
                                }
                            }
                        }
                        heading = (heading + 90) % 360;
                        heading = Cesium.Math.toRadians(object_utils_41.ObjectUtils.parseNum((heading)));
                        pitch = Cesium.Math.toRadians(object_utils_41.ObjectUtils.parseNum(pitch));
                        roll = Cesium.Math.toRadians(object_utils_41.ObjectUtils.parseNum(roll));
                        let hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
                        let orientation = Cesium.Transforms.headingPitchRollQuaternion(position, hpr);
                        try {
                            let model = new Cesium.ModelGraphics({
                                uri: url,
                                heightReference: heightReference,
                                scale: scale,
                                shadows: Cesium.ShadowMode.ENABLED
                            });
                            let entity = new Cesium.Entity({
                                id: `__entity_glb_${(++cesium_bruce_entity_4.CesiumBruceEntity.ENTITY_ID)}_${id}_${this.lod}`,
                                position: position,
                                orientation: orientation,
                                parent: this.parent,
                                show: false,
                                model: model
                            });
                            this.viewer.entities.add(entity);
                            bruceEntity = new cesium_bruce_entity_4.CesiumBruceEntity(this.viewer, [entity], new bruce_meta_4.BruceMeta([id], info === null || info === void 0 ? void 0 : info.Bruce["EntityType.ID"], this.api.clientAccountId));
                        }
                        catch (e) {
                        }
                    }
                    // Style the entity if it was created
                    if (bruceEntity != null) {
                        this.styleEntity(bruceEntity, info);
                    }
                }
                return Promise.resolve(bruceEntity);
            });
        }
        /**
         * Applies color blend mode and colours depending on current model style settings.
         * @param bruceEntity
         * @param info
         */
        styleEntity(bruceEntity, info) {
            var _a, _b, _c;
            let entities = bruceEntity.uiEntities;
            for (let i = 0; i < entities.length; i++) {
                let entity = entities[i];
                let model = entity === null || entity === void 0 ? void 0 : entity.model;
                if (model) {
                    let colorBlendMode = null;
                    let colorBlendAmount = null;
                    // Only read colour blend mode and amount if customize enabled
                    if ((_a = this.modelStyle) === null || _a === void 0 ? void 0 : _a.customize) {
                        // Set mode and if missing set to default (highlight)
                        colorBlendMode = this.modelStyle.fillColorBlendMode;
                        if (!colorBlendMode) {
                            colorBlendMode = Cesium.ColorBlendMode.HIGHLIGHT;
                        }
                        // Only apply blend amount if blend mode is in mix
                        if (colorBlendMode == Cesium.ColorBlendMode.MIX) {
                            colorBlendAmount = this.modelStyle.fillColorBlendAmount;
                            if (!colorBlendAmount) {
                                colorBlendAmount = 0.5;
                            }
                        }
                    }
                    model.colorBlendMode = colorBlendMode;
                    model.colorBlendAmount = colorBlendAmount;
                }
            }
            if (((_b = this.modelStyle) === null || _b === void 0 ? void 0 : _b.customize) && ((_c = this.modelStyle) === null || _c === void 0 ? void 0 : _c.fillColor)) {
                let color = this.calculator.calcValues(info.raw, this.modelStyle.fillColor);
                if (color != null) {
                    let bColor = this.calculator.getColor(color);
                    let cColor = cesium_utils_5.CesiumUtils.ColorToCesiumColor(bColor);
                    bruceEntity.Colorize(cColor);
                }
            }
        }
        /**
         * Returns position value from given bruce info.
         * @param info
         */
        getSinglePosition(info) {
            // Has location, use location
            let location = info.location;
            if (location && location.latitude != null && location.longitude != null) {
                let altitude = location.altitude;
                if (!altitude == null) {
                    altitude = 0;
                }
                return Cesium.Cartesian3.fromDegrees(location.longitude, location.latitude, altitude);
            }
            // Has some sort of geometry? Let's try use it
            else if (info.geometry) {
                let geometry = info.geometry;
                if (typeof geometry == "object") {
                    // Using point geometry
                    if (geometry.Point && typeof geometry.Point == "string") {
                        let posses = geometry_5.Geometry.ParsePoints(geometry.Point);
                        if (posses.length > 0) {
                            let pos = Cesium.Cartesian3.fromDegrees(posses[0].longitude, posses[0].latitude, posses[0].altitude);
                            if (cesium_utils_5.CesiumUtils.ValidatePosition(pos)) {
                                return pos;
                            }
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Sets given position to have height 0.
         * @param pos
         */
        zeroHeight(pos) {
            let carto = Cesium.Cartographic.fromCartesian(pos);
            let newPos = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, 0);
            return newPos;
        }
    }
    exports.CesiumGeneratorModel = CesiumGeneratorModel;
});
define("entry-points/common/entities-getter-interface", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GetterPagesLoadingState = void 0;
    /**
     * Represents the possible loading states.
     */
    var GetterPagesLoadingState;
    (function (GetterPagesLoadingState) {
        GetterPagesLoadingState["Started"] = "STARTED";
        GetterPagesLoadingState["Stopped"] = "STOPPED";
    })(GetterPagesLoadingState = exports.GetterPagesLoadingState || (exports.GetterPagesLoadingState = {}));
});
define("entry-points/cesium/menu-items/cesium-menu-item-ifs", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("entry-points/cesium/menu-items/cesium-menu-item-bruce-entities-extended", ["require", "exports", "cesium", "entry-points/cesium/menu-items/cesium-visual-register", "utils/bruce-event-disposable", "entry-points/cesium/common/cesium-utils", "entry-points/common/bruce-meta", "entry-points/cesium/visuals/cesium-generator-geometry", "entry-points/cesium/visuals/cesium-generator-model", "entry-points/cesium/menu-items/cesium-menu-item-manager", "utils/bruce-event", "bruce-models/common/camera-zoom-control", "bruce-models/common/style", "entry-points/cesium/common/cesium-entity-utils", "bruce-models/common/polygon", "bruce-models/common/entity-type"], function (require, exports, Cesium, cesium_visual_register_1, bruce_event_disposable_3, cesium_utils_6, bruce_meta_5, cesium_generator_geometry_1, cesium_generator_model_1, cesium_menu_item_manager_1, bruce_event_5, camera_zoom_control_4, style_1, cesium_entity_utils_4, polygon_3, entity_type_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumMenuItemBruceEntitiesExtended = void 0;
    Cesium = __importStar(Cesium);
    /**
     * Loads in bruce entities, registers them and renders them.
     */
    class CesiumMenuItemBruceEntitiesExtended extends bruce_event_disposable_3.BruceEventDisposable {
        constructor(api, viewer, visualRegister, menuItem, getter) {
            super();
            // All entities that have been registered after loading.
            this.loadedEntities = {};
            // Array of defined entity generators created from zoom control lod specifications.
            this.generators = [];
            // Notifies when visuals are added or removed.
            this.visualUpdateEvent = new bruce_event_5.BruceEvent();
            // If the menu item has been initialized yet.
            this.initialized = false;
            this.api = api;
            this.viewer = viewer;
            this.visualRegister = visualRegister;
            this.menuItem = menuItem;
            this.entitiesGetter = getter;
        }
        /**
         * Returns if the menu item has been initialized.
         */
        get IsInitialized() {
            return this.initialized;
        }
        /**
         * Initializes the menu item.
         */
        Init() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.initialized) {
                    return;
                }
                try {
                    this.root = this.viewer.entities.add(new Cesium.Entity({
                        id: `__layer_${(cesium_menu_item_manager_1.CesiumMenuItemManager.counter++)}`,
                        show: true
                    }));
                    this.addDisposable(this.entitiesGetter.entityReadyEvent.Subscribe((entity) => {
                        this.entityReady(entity);
                    }));
                    yield this.initLods();
                    this.initialized = true;
                }
                catch (e) {
                    console.log(">>Error: Failed to initialize extended menu item.");
                    console.log(this);
                    console.log(e);
                }
            });
        }
        /**
         * Checks if menu item has been initialized.
         * Throws error if false.
         */
        initCheck() {
            if (!this.initialized) {
                throw (">>Error: Menu item not initialized. Please call Init method.");
            }
        }
        /**
         * Starts the loading process.
         */
        Start() {
            this.initCheck();
            this.entitiesGetter.Start();
        }
        /**
         * Stops loading anymore entities.
         */
        Pause() {
            this.initCheck();
            this.entitiesGetter.Pause();
        }
        /**
         * Triggers an update on boundaries.
         * This will cascade into getting entities if boundaries are valid.
         */
        Update() {
            this.initCheck();
            this.entitiesGetter.Update();
        }
        /**
         * Returns all visuals registered for this menu item.
         * Note that these visuals may not be the ones visible as another menu item with higher-
         * render priority rendered them instead.
         */
        GetMenuItemVisuals() {
            return this.visualRegister.getByMenuItem(this.menuItem.id);
        }
        /**
         * @returns entity ready event for this menu item.
         */
        getEntityReadyEvent() {
            this.initCheck();
            return this.entitiesGetter.entityReadyEvent;
        }
        /**
         * @returns loading state change event for this menu item.
         */
        getLoadingStateChangedEvent() {
            this.initCheck();
            return this.entitiesGetter.loadingStateChangedEvent;
        }
        /**
         * @returns event for when visuals are added or removed.
         */
        getVisualUpdateEvent() {
            return this.visualUpdateEvent;
        }
        /**
         * Parses the ZoomControl table to create generators for different LODs.
         */
        initLods() {
            return __awaiter(this, void 0, void 0, function* () {
                for (let i = 0; i < this.menuItem.zoomControl.length; i++) {
                    let viewSettings = null;
                    if (this.menuItem.zoomControl[i].Style) {
                        viewSettings =
                            {
                                ID: "-1",
                                Name: "Custom - Preloaded",
                                Type: style_1.IStyleType.Entity,
                                Settings: this.menuItem.zoomControl[i].Style
                            };
                    }
                    else if (this.menuItem.zoomControl[i].StyleID) {
                        viewSettings = yield this.api.getViewSettings(this.menuItem.zoomControl[i].StyleID.toString());
                    }
                    else {
                        let entityType = yield entity_type_3.EntityType.GetByID(this.api, this.menuItem.BruceEntity["EntityType.ID"]);
                        if (entityType["DisplaySetting.ID"] != 0) {
                            let entityTypeViewSettings = yield this.api.getViewSettings(entityType["DisplaySetting.ID"].toString());
                            viewSettings = entityTypeViewSettings;
                        }
                        else {
                            let entityTypeViewSettings = yield this.api.getDefaultViewSettings();
                            viewSettings = entityTypeViewSettings;
                        }
                    }
                    // Cache into zoom control.
                    if (viewSettings === null || viewSettings === void 0 ? void 0 : viewSettings.Settings) {
                        this.menuItem.zoomControl[i].Style = viewSettings.Settings;
                    }
                    // Fixing old polygon setting - its now "geometry".
                    if (this.menuItem.zoomControl[i].DisplayType == camera_zoom_control_4.ECameraZoomControlDisplayType.GeometryOld) {
                        this.menuItem.zoomControl[i].DisplayType = camera_zoom_control_4.ECameraZoomControlDisplayType.Geometry;
                    }
                    this.generators[i] =
                        {
                            geometry: new cesium_generator_geometry_1.CesiumGeneratorGeometry(this.api, this.viewer, viewSettings === null || viewSettings === void 0 ? void 0 : viewSettings.Settings, this.root),
                            glb: new cesium_generator_model_1.CesiumGeneratorModel(this.api, this.viewer, viewSettings === null || viewSettings === void 0 ? void 0 : viewSettings.Settings.modelStyle, this.menuItem.zoomControl[i].LODCategoryID, this.menuItem.zoomControl[i].LODLevel, this.root)
                        };
                }
            });
        }
        /**
         * Disposes menu item and related subscriptions.
         */
        dispose() {
            super.dispose();
            this.entitiesGetter.Dispose();
            this.generators.forEach(element => {
                element.geometry.dispose();
                element.glb.dispose();
            });
            // Remove root entity, this will remove all entities for the menu item from the 3d view.
            cesium_entity_utils_4.CesiumEntityUtils.RemoveEntity(this.viewer, this.root);
            let visuals = Object.keys(this.loadedEntities);
            for (let i = 0; i < visuals.length; i++) {
                let visual = visuals[i];
                let meta = new bruce_meta_5.BruceMeta([visual], null, this.api.clientAccountId);
                this.visualRegister.RemoveForMenuItem(this.menuItem.id, meta);
                // Notify subscriptions that visual was removed.
                this.entityRemove(meta);
            }
            this.viewer.scene.requestRender();
        }
        /**
         * Called when an individual entity loads.
         * @param info
         */
        entityReady(info) {
            if (!this.disposed) {
                this.createEntity(info, false);
            }
        }
        /**
         * Parse the items returned by the request to backend into entities of the UI
         * @param items - the items receievd
         */
        createEntity(item, forced) {
            return __awaiter(this, void 0, void 0, function* () {
                let bruceId = item.Bruce.ID;
                if (item.location == undefined) {
                    return;
                }
                let cameraPos = cesium_utils_6.CesiumUtils.toDegrees(this.viewer.camera.positionCartographic);
                let entityPos = new Cesium.Cartographic(item.location.longitude, item.location.latitude, item.location.altitude != null ? item.location.altitude : 0);
                let current = this.loadedEntities[bruceId];
                let distance = cesium_utils_6.CesiumUtils.distanceBetweenPoints(cameraPos, entityPos);
                let lod = this.zoomControlFromDistance(distance);
                let type = this.menuItem.zoomControl[lod].DisplayType;
                let meta = new bruce_meta_5.BruceMeta([item.Bruce.ID], item.Bruce["EntityType.ID"], this.api.clientAccountId);
                /*
                let createEntity: boolean =
                    (((this.loadedEntities[bruceId] != null) && (this.loadedEntities[bruceId].lod != lod)) || (this.loadedEntities[bruceId] == null))
                    && (lod != -1)
                    && (this.menuItem.zoomControl[lod].DisplayType != ECameraZoomControlDisplayType.Hidden);
                */
                let createEntity = type != camera_zoom_control_4.ECameraZoomControlDisplayType.Hidden
                    &&
                        (forced
                            ||
                                current == null
                            ||
                                (current != null && current.lod != lod)
                            ||
                                (current != null && current.type != type));
                if (createEntity) {
                    if (this.menuItem.fixPolygons) {
                        if (item.geometry.Polygon && item.geometry.Polygon.length > 0) {
                            item.geometry.Polygon = polygon_3.Polygon.Fix(item.geometry.Polygon);
                        }
                    }
                    let newCesiumEntity = yield this.drawEntity(item, lod, forced);
                    if (newCesiumEntity === null || newCesiumEntity === void 0 ? void 0 : newCesiumEntity["entity"]) {
                        newCesiumEntity["entity"].bruceMeta = meta;
                        this.loadedEntities[bruceId] = newCesiumEntity["entity"];
                        // Register the created visual.
                        this.visualRegister.Add(newCesiumEntity["entity"], newCesiumEntity["actualVisual"], this.menuItem.id, this.menuItem.renderPriority);
                        // Notify subscriptions that visual was updated.
                        this.entityDrawn(meta, newCesiumEntity === null || newCesiumEntity === void 0 ? void 0 : newCesiumEntity.entity);
                    }
                }
                let destroyEntity = ((lod == -1) || (type == camera_zoom_control_4.ECameraZoomControlDisplayType.Hidden) || this.disposed);
                if (destroyEntity) {
                    // Remove registration of visual.
                    let meta = new bruce_meta_5.BruceMeta([item.Bruce.ID], item.Bruce["EntityType.ID"], this.api.clientAccountId);
                    this.visualRegister.RemoveForMenuItem(this.menuItem.id, meta);
                    if (this.loadedEntities[bruceId]) {
                        delete this.loadedEntities[bruceId];
                        // Notify subscriptions that visual was removed.
                        this.entityRemove(meta);
                    }
                }
            });
        }
        /**
         * Creates visual representation of a entity
         * @param item Bruce Info describing the entity
         * @param lod The lod level required for it
         */
        drawEntity(item, lod, forceCacheInCesium) {
            return __awaiter(this, void 0, void 0, function* () {
                let newVisualEntity = null;
                let intendedVisual = null;
                let actualVisual = null;
                let displayType = this.menuItem.zoomControl[lod].DisplayType;
                if (displayType == camera_zoom_control_4.ECameraZoomControlDisplayType.Model3D) {
                    intendedVisual = cesium_visual_register_1.VisualType.MODEL3D;
                    actualVisual = cesium_visual_register_1.VisualType.MODEL3D;
                    newVisualEntity = yield this.generators[lod].glb.loadEntity(item, forceCacheInCesium);
                    if (this.disposed) {
                        return null;
                    }
                    if (!newVisualEntity) {
                        displayType = camera_zoom_control_4.ECameraZoomControlDisplayType.Geometry;
                    }
                }
                if (displayType == camera_zoom_control_4.ECameraZoomControlDisplayType.Geometry || displayType == camera_zoom_control_4.ECameraZoomControlDisplayType.Polygon) {
                    intendedVisual = intendedVisual ? intendedVisual : cesium_visual_register_1.VisualType.GEOMETRY;
                    actualVisual = cesium_visual_register_1.VisualType.GEOMETRY;
                    newVisualEntity = this.generators[lod].geometry.loadEntity(item, displayType);
                    if (!newVisualEntity) {
                        displayType = camera_zoom_control_4.ECameraZoomControlDisplayType.Point;
                    }
                }
                if (displayType == camera_zoom_control_4.ECameraZoomControlDisplayType.Point) {
                    intendedVisual = intendedVisual ? intendedVisual : cesium_visual_register_1.VisualType.POINT;
                    actualVisual = cesium_visual_register_1.VisualType.POINT;
                    newVisualEntity = this.generators[lod].geometry.loadEntity(item, camera_zoom_control_4.ECameraZoomControlDisplayType.Point);
                }
                if (newVisualEntity) {
                    newVisualEntity.lod = lod;
                    newVisualEntity.type = displayType;
                }
                let clamping = this.clampingForEntities(newVisualEntity.uiEntities);
                return Promise.resolve({
                    "entity": newVisualEntity,
                    "intendedVisual": intendedVisual,
                    "actualVisual": actualVisual,
                    "clamping": clamping
                });
            });
        }
        /**
         * Explores an entity and undestant its clamping values.
         * @param entity
         */
        clampingForEntities(entities) {
            if (entities) {
                for (let i = 0; i < entities.length; i++) {
                    let entity = entities[i];
                    if (entity) {
                        if (entity.model) {
                            // @ts-ignore
                            return (entity.model.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                        if (entity.polygon) {
                            // @ts-ignore
                            return (entity.polygon.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                        if (entity.polyline) {
                            //TODO:polylines dont have hight references
                            return (entity.polyline.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                        if (entity.point) {
                            // @ts-ignore
                            return (entity.point.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                        if (entity.billboard) {
                            return (entity.billboard.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                    }
                }
            }
            return false;
        }
        /**
         * Returns the zoom control entry for a given distance
         * @param distance the distance to the item
         */
        zoomControlFromDistance(distance) {
            for (let i = 0; i < this.menuItem.zoomControl.length; i++) {
                let zoomItem = this.menuItem.zoomControl[i];
                if ((distance >= zoomItem.MinZoom) && (distance <= zoomItem.MaxZoom)) {
                    return i;
                }
            }
            return -1;
        }
        /**
         * Notifies subscriptions about entity visual being created or updated.
         * @param meta
         * @param entity
         */
        entityDrawn(meta, entity) {
            this.visualUpdateEvent.Trigger({ visual: entity, meta: meta });
        }
        /**
         * Notifies subscriptions about entity visual being removed.
         * @param meta
         */
        entityRemove(meta) {
            this.visualUpdateEvent.Trigger({ visual: null, meta: meta });
        }
        /**
         * Adds a given entity if no current entity matches meta.
         * @param entity
         */
        AddEntity(entity) {
            let cur = this.loadedEntities[entity.Bruce.ID];
            if (!cur) {
                this.entityReady(entity);
            }
        }
        /**
         * Removes entity that matches given meta.
         * @param meta
         * @param eventTrigger, if subscriptions should be notified.
         */
        RemoveEntity(meta, eventTrigger = true) {
            let cur = this.loadedEntities[meta.EntityID()];
            if (cur) {
                this.visualRegister.RemoveForMenuItem(this.menuItem.id, cur.bruceMeta);
                delete this.loadedEntities[meta.EntityID()];
                if (eventTrigger) {
                    this.entityRemove(meta);
                }
                this.viewer.scene.requestRender();
            }
        }
        /**
         * Performs the process of removing and re-adding a given entity.
         * @param entity
         */
        UpdateEntity(entity) {
            let meta = new bruce_meta_5.BruceMeta([entity.Bruce.ID], entity.Bruce["EntityType.ID"], null);
            this.RemoveEntity(meta);
            this.AddEntity(entity);
        }
    }
    exports.CesiumMenuItemBruceEntitiesExtended = CesiumMenuItemBruceEntitiesExtended;
});
define("entry-points/cesium/getters/cesium-entities-getter-pages", ["require", "exports", "bruce-models/common/bruce-info", "utils/bruce-event-disposable", "utils/bruce-event", "entry-points/common/entities-getter-interface"], function (require, exports, bruce_info_2, bruce_event_disposable_4, bruce_event_6, entities_getter_interface_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumEntitiesGetterPages = void 0;
    // The threshhold from which we actually start fetching anything.
    const MAXIMUM_AREA_IN_DEGREES = 90;
    /**
     * Handles requesting entities within provided view area using a given entity filter.
     */
    class CesiumEntitiesGetterPages extends bruce_event_disposable_4.BruceEventDisposable {
        constructor(api, viewMonitor, loadManager, filter) {
            super();
            // Cache record of all loaded entities so far.
            this.bruceItems = {};
            // If loading is currently paused.
            this.paused = false;
            // If loading is disposed and should stop entirely.
            this.getterDisposed = false;
            // What filter to use when searching for entities.
            // Page index will be overriden and incremented to request all entities in batches.
            // Page size will be overriden with a page size default.
            this.filter = null;
            // The last loading state.
            this._lastLoadingState = entities_getter_interface_1.GetterPagesLoadingState.Stopped;
            this.api = api;
            this.viewMonitor = viewMonitor;
            this.loadManager = loadManager;
            this.filter = filter;
            this.entityReadyEvent = new bruce_event_6.BruceEvent();
            this.loadingStateChangedEvent = new bruce_event_6.BruceEvent();
        }
        /**
         * Returns the last loading state.
         */
        get LastLoadingState() {
            return this._lastLoadingState;
        }
        /**
         * Initialize subscriptions.
         */
        subs() {
            this.addDisposable(this.viewMonitor.ViewAreaUpdated().Subscribe(() => {
                this.UpdateBounds();
            }));
        }
        /**
         * Updates the bounds we are loading for and calls to load entities within those bounds.
         */
        UpdateBounds() {
            return __awaiter(this, void 0, void 0, function* () {
                let viewRect = this.viewMonitor.GetViewAreaInDegrees();
                let poi = this.viewMonitor.GetTargetPointInDegrees();
                if (viewRect && poi) {
                    if (Math.abs(viewRect.west - viewRect.east) > MAXIMUM_AREA_IN_DEGREES) {
                        return;
                    }
                    if (Math.abs(viewRect.south - viewRect.north) > MAXIMUM_AREA_IN_DEGREES) {
                        return;
                    }
                    this.viewRect = viewRect;
                    this.viewCenter = poi;
                    this.LoadingThread();
                }
            });
        }
        /**
         * Loads next area from the defined view rect.
        */
        LoadingThread() {
            this.bruceItems = {};
            const pageSize = 100;
            let center = this.viewCenter;
            new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
                let pageIndex = 0;
                let paused = this.paused;
                // Notify that loader has started.
                this.loadingStateChangedEvent.Trigger(entities_getter_interface_1.GetterPagesLoadingState.Started);
                while (paused == false && this.getterDisposed == false) {
                    this.filter.pageIndex = pageIndex;
                    this.filter.pageSize = pageSize;
                    this.filter.bounds = this.viewRect;
                    this.filter.orderBy =
                        {
                            geometry: {
                                distanceTo: [
                                    this.viewCenter.latitude,
                                    this.viewCenter.longitude
                                ]
                            }
                        };
                    let page = yield bruce_info_2.BruceInfo.GetEntitiesByFilter(this.api, this.filter);
                    for (let i = 0; i < page.length && paused == false; i++) {
                        if (center != this.viewCenter) {
                            paused = true;
                            break;
                        }
                        paused = paused || this.paused;
                        let bruceInfo = page[i];
                        this.bruceItems[bruceInfo.Bruce.ID] = bruceInfo;
                        this.entityReadyEvent.Trigger(bruceInfo);
                        yield this.loadManager.RequestToAddLoad(1);
                    }
                    if (page.length < pageSize || center != this.viewCenter) {
                        break;
                    }
                    if (center != this.viewCenter) {
                        break;
                    }
                    paused = paused || this.paused;
                    pageIndex++;
                }
                // Notify that loader has stopped.
                this.loadingStateChangedEvent.Trigger(entities_getter_interface_1.GetterPagesLoadingState.Stopped);
                resolve(null);
            }));
        }
        /**
         * Sets the getter to paused state.
         * This means entities that are already requested from db will continue to load,
         * but new requests wont be made.
         */
        Pause() {
            super.dispose();
            this.paused = true;
        }
        /**
         * Sets the getter to unpaused state.
         * This means entity requests will continue to be made.
         */
        Start() {
            this.paused = false;
            this.subs();
            this.UpdateBounds();
        }
        /**
         * Disposes the getter.
         * This means entities that are already requested from db will not load.
         * New requests will not be made.
         */
        Dispose() {
            super.dispose();
            this.paused = true;
            this.getterDisposed = true;
        }
        /**
         * Manual trigger to update.
         */
        Update() {
            this.UpdateBounds();
        }
    }
    exports.CesiumEntitiesGetterPages = CesiumEntitiesGetterPages;
});
define("entry-points/cesium/common/cesium-tileset-utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumTilesetUtils = void 0;
    /**
     * Utilities relating to tileset visuals in Cesium.
     */
    class CesiumTilesetUtils {
        /**
         * Returns tileset information from given tileset entity.
         * @param tileset
         */
        static GetTilesetInfo(tileset) {
            var _a, _b;
            let ID = this.GetTilesetID(tileset);
            // @ts-ignore
            let URL = ((_a = tileset === null || tileset === void 0 ? void 0 : tileset.resource) === null || _a === void 0 ? void 0 : _a.url) == null ? tileset.url : (_b = tileset === null || tileset === void 0 ? void 0 : tileset.resource) === null || _b === void 0 ? void 0 : _b.url;
            let URLFileIndex = URL ? URL.indexOf("/file/") : -1;
            let BruceRecURL = URLFileIndex > -1 ? URL.slice(0, URLFileIndex) : null;
            return { TilesetID: ID, TilesetURL: URL, BruceRecURL: BruceRecURL };
        }
        /**
         * Returns tileset ID for given tileset entity.
         * @param tileset
         */
        static GetTilesetID(tileset) {
            var _a, _b, _c;
            // @ts-ignore
            if (!tileset || !((_a = tileset === null || tileset === void 0 ? void 0 : tileset.resource) === null || _a === void 0 ? void 0 : _a.url)) {
                return null;
            }
            // @ts-ignore
            let url = ((_b = tileset === null || tileset === void 0 ? void 0 : tileset.resource) === null || _b === void 0 ? void 0 : _b.url) == null ? tileset.url : (_c = tileset === null || tileset === void 0 ? void 0 : tileset.resource) === null || _c === void 0 ? void 0 : _c.url;
            let index = url.lastIndexOf("ui.tileset/");
            let lastIndex = url.lastIndexOf("/file/tileset.json");
            let tilesetID = null;
            if (index > -1 && lastIndex > -1) {
                tilesetID = url.slice(index + 11, lastIndex);
            }
            return tilesetID;
        }
        /**
         * Tries to locate a bruce entity path within a given tileset feature.
         * @param entity
         */
        static EntityIDPathFromFeature(entity) {
            let props = entity.getPropertyNames([]);
            // Lets see if we have | seperated list of entities 
            if (props.find(x => x == "BrucePath")) {
                let path;
                path = (String)(entity.getProperty("BrucePath")).split("|");
                return path;
            }
            // it not a path so lets make it an array 
            let entityNames = ["Building_ID", "BuildingID", "BruceId"];
            // This is just array of possible names.
            // We need to make a better euristic later.
            // Or even get property names and cross reference.
            for (let name of entityNames) {
                if (props.indexOf(name) > -1) {
                    let singleId = entity.getProperty(name);
                    if (singleId) {
                        return [singleId];
                    }
                }
            }
            return null;
        }
    }
    exports.CesiumTilesetUtils = CesiumTilesetUtils;
});
define("bruce-models/common/rotation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
});
define("bruce-models/tileset-old/tileset-settings-etc", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetSettingsETC = void 0;
    /**
     * Represents the ETC portion of "tileset settings".
     */
    class TilesetSettingsETC {
        constructor(rawData) {
            // If rotation should be disabled for this tileset.
            this.dontRotate = false;
            // If all kinds of transformation should be disabled for this tileset (including rotation).
            this.dontTransform = false;
            // If advanced settings should be visible when editing this tileset.
            this.showAdvancedSettings = false;
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current state of settings as raw JSON.
         */
        get JSON() {
            let etc = {
                dontRotate: this.dontRotate,
                dontTransform: this.dontTransform,
                showAdvancedSettings: this.showAdvancedSettings
            };
            return etc;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.dontRotate != null) {
                this.dontRotate = rawData.dontRotate;
            }
            if (rawData.dontTransform != null) {
                this.dontTransform = rawData.dontTransform;
            }
            if (rawData.showAdvancedSettings != null) {
                this.showAdvancedSettings = rawData.showAdvancedSettings;
            }
        }
    }
    exports.TilesetSettingsETC = TilesetSettingsETC;
});
define("bruce-models/tileset-old/tileset-settings-origin", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetSettingsOrigin = void 0;
    /**
     * Represents origin settings within tileset settings.
     */
    class TilesetSettingsOrigin {
        constructor(rawData) {
            // If origin is based on the center of the tileset visuals instead of matrix.
            this.usingBoundingBox = true;
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current state of origin settings as raw JSON data.
         */
        get JSON() {
            let origin = {
                latitude: this.latitude,
                longitude: this.longitude,
                altitude: this.altitude,
                usingBoundingBox: this.usingBoundingBox
            };
            return origin;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.latitude != null) {
                this.latitude = rawData.latitude;
            }
            if (rawData.longitude != null) {
                this.longitude = rawData.longitude;
            }
            if (rawData.altitude != null) {
                this.altitude = rawData.altitude;
            }
            if (rawData.usingBoundingBox != null) {
                this.usingBoundingBox = rawData.usingBoundingBox;
            }
        }
    }
    exports.TilesetSettingsOrigin = TilesetSettingsOrigin;
});
define("bruce-models/tileset-old/tileset-settings-position-offset", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetSettingsPositionOffset = void 0;
    /**
     * Represents position offset settings for a UITileset.
     */
    class TilesetSettingsPositionOffset {
        constructor(rawData) {
            // Offset to apply to tileset in meters towards north.
            this.north = 0;
            // Offset to apply to tileset in meters towards east.
            this.east = 0;
            // Offset to apply to tileset in meters to the altitude value.
            this.altitude = 0;
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current state of position offset as raw JSON data.
         */
        get JSON() {
            let data = {
                north: this.north,
                east: this.east,
                altitude: this.altitude
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.north != null) {
                this.north = rawData.north;
            }
            if (rawData.east != null) {
                this.east = rawData.east;
            }
            if (rawData.altitude != null) {
                this.altitude = rawData.altitude;
            }
        }
    }
    exports.TilesetSettingsPositionOffset = TilesetSettingsPositionOffset;
});
define("bruce-models/tileset-old/tileset-settings-rotation", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetSettingsRotation = void 0;
    /**
     * Represents rotation settings for a UITileset.
     */
    class TilesetSettingsRotation {
        constructor(rawData) {
            // X rotation in degrees.
            this.x = 0;
            // Y rotation in degrees.
            this.y = 0;
            // Z rotation in degrees.
            this.z = 0;
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current state of rotation settings as raw JSON data.
         */
        get JSON() {
            let data = {
                x: this.x,
                y: this.y,
                z: this.z
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.x != null) {
                this.x = rawData.x;
            }
            if (rawData.y != null) {
                this.y = rawData.y;
            }
            if (rawData.z != null) {
                this.z = rawData.z;
            }
        }
    }
    exports.TilesetSettingsRotation = TilesetSettingsRotation;
});
define("bruce-models/tileset-old/tileset-settings-visual", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetSettingsVisual = void 0;
    /**
     * Represents visual settings for a UITileset.
     */
    class TilesetSettingsVisual {
        constructor(rawData) {
            // The maximum screen space error used to drive level of detail refinement.
            this.maximumScreenSpaceError = 4.52;
            // Perform point attenuation based on geometric error.
            this.attenuation = true;
            // Maximum point attenuation in pixels.
            this.attenuationMax = 4;
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current state of model as raw JSON data.
         */
        get JSON() {
            let data = {
                maximumScreenSpaceError: this.maximumScreenSpaceError,
                attenuation: this.attenuation,
                attenuationMax: this.attenuationMax
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.maximumScreenSpaceError != null) {
                this.maximumScreenSpaceError = rawData.maximumScreenSpaceError;
            }
            if (rawData.attenuation != null) {
                this.attenuation = rawData.attenuation;
            }
            if (rawData.attenuationMax != null) {
                this.attenuationMax = rawData.attenuationMax;
            }
        }
    }
    exports.TilesetSettingsVisual = TilesetSettingsVisual;
});
define("bruce-models/tileset-old/tileset-settings-old", ["require", "exports", "bruce-models/tileset-old/tileset-settings-etc", "bruce-models/tileset-old/tileset-settings-origin", "bruce-models/tileset-old/tileset-settings-position-offset", "bruce-models/tileset-old/tileset-settings-rotation", "bruce-models/tileset-old/tileset-settings-visual"], function (require, exports, tileset_settings_etc_1, tileset_settings_origin_1, tileset_settings_position_offset_1, tileset_settings_rotation_1, tileset_settings_visual_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetSettingsOld = void 0;
    /**
     * Represents tileset settings related to loading and rendering.
     */
    class TilesetSettingsOld {
        constructor(rawData) {
            // Tileset position. Null = don't move from default.
            this.origin = new tileset_settings_origin_1.TilesetSettingsOrigin(null);
            // Tileset offset to apply to position.
            this.positionOffset = new tileset_settings_position_offset_1.TilesetSettingsPositionOffset(null);
            // Rotation in degrees.
            this.rotation = new tileset_settings_rotation_1.TilesetSettingsRotation(null);
            // Tileset rendering settings.
            this.visual = new tileset_settings_visual_1.TilesetSettingsVisual(null);
            // General settings.
            this.ETC = new tileset_settings_etc_1.TilesetSettingsETC(null);
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns the current state of settings as formatted JSON.
         */
        get JSON() {
            let settings = {
                origin: this.origin.JSON,
                positionOffset: this.positionOffset.JSON,
                rotation: this.rotation.JSON,
                visual: this.visual.JSON,
                etc: this.ETC.JSON
            };
            return settings;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.etc != null) {
                this.ETC.Update(rawData.etc);
            }
            if (rawData.origin != null) {
                this.origin.Update(rawData.origin);
            }
            if (rawData.positionOffset != null) {
                this.positionOffset.Update(rawData.positionOffset);
            }
            if (rawData.rotation != null) {
                this.rotation.Update(rawData.rotation);
            }
            if (rawData.visual != null) {
                this.visual.Update(rawData.visual);
            }
        }
    }
    exports.TilesetSettingsOld = TilesetSettingsOld;
});
define("entry-points/cesium/visuals/cesium-generator-tileset", ["require", "exports", "cesium", "utils/object-utils", "entry-points/cesium/common/cesium-drawing-utils"], function (require, exports, Cesium, object_utils_42, cesium_drawing_utils_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumGeneratorTileset = exports.TilesetEntityRecordVariable = void 0;
    Cesium = __importStar(Cesium);
    exports.TilesetEntityRecordVariable = "_TilesetEntityRecord";
    class CesiumGeneratorTileset {
        static ApplySettings(viewer, tileset, settings) {
            if (typeof settings == "string") {
                settings = JSON.parse(settings);
            }
            else if (!settings) {
                settings = {};
            }
            /// [1] Preparing settings to be used ///
            // Position offset check
            if (settings.positionOffset == null || settings.positionOffset.north == null) {
                settings.positionOffset =
                    {
                        north: 0,
                        east: 0,
                        altitude: 0
                    };
            }
            // Rotation settings check
            if (settings.rotation == null) {
                settings.rotation = { x: 0, y: 0, z: 0 };
            }
            // No rotation is default so the person uploading the tileset has to make sure it's at the correct position first
            let dontRotate = object_utils_42.ObjectUtils.FindValue(settings, ["etc", "dontRotate"], false);
            let dontTransform = object_utils_42.ObjectUtils.FindValue(settings, ["etc", "dontTransform"], false);
            // New bounding box setting check
            if (settings.origin && settings.origin.usingBoundingBox == null) {
                settings.origin.usingBoundingBox = true;
            }
            // An origin is needed as part of settings for the editor to work!
            if ((!settings.origin || settings.origin.altitude == null)) {
                let cartes = null;
                let useBounding = object_utils_42.ObjectUtils.FindValue(settings, ["origin", "usingBoundingBox"], true);
                if (useBounding) {
                    cartes = Cesium.Cartesian3.clone(tileset.root.boundingSphere.center);
                }
                else {
                    // @ts-ignore
                    cartes = Cesium.Matrix4.getTranslation(tileset.root.transform, new Cesium.Cartesian3());
                }
                let carto = Cesium.Cartographic.fromCartesian(cartes);
                if (carto) {
                    carto.latitude = Cesium.Math.toDegrees(carto.latitude);
                    carto.longitude = Cesium.Math.toDegrees(carto.longitude);
                    settings.origin = Object.assign(Object.assign({}, settings.origin), { altitude: carto.height, latitude: carto.latitude, longitude: carto.longitude });
                }
            }
            /// [2] Applying visual settings (settings related to rendering and quality) ///
            tileset.pointCloudShading.attenuation = object_utils_42.ObjectUtils.FindValue(settings, ["visual", "attenuation"], true);
            tileset.pointCloudShading.maximumAttenuation = object_utils_42.ObjectUtils.FindValue(settings, ["visual", "attenuationMax"], 4);
            tileset.maximumScreenSpaceError = object_utils_42.ObjectUtils.FindValue(settings, ["visual", "maximumScreenSpaceError"], 5);
            /// [3] Applying location settings (settings relating to position and rotation) ///
            let preparedSettings = {
                origin: settings.origin,
                rotation: settings.rotation,
                positionOffset: settings.positionOffset,
                etc: {
                    dontRotate: dontRotate,
                    dontTransform: dontTransform
                }
            };
            if (!dontTransform) {
                CesiumGeneratorTileset.Transform(viewer, tileset, preparedSettings);
            }
            /// [4] Finalize ///
            // Store a record of the process within the tileset so editing tools can read and upate it properly
            tileset[exports.TilesetEntityRecordVariable] =
                {
                    originalCenter: Cesium.Cartesian3.clone(tileset.root.boundingSphere.center),
                    // @ts-ignore
                    currentRootMatrix: Cesium.Matrix4.clone(tileset.root.transform, new Cesium.Matrix4()),
                    // @ts-ignore
                    originalRootMatrix: Cesium.Matrix4.clone(tileset.root.transform, new Cesium.Matrix4()),
                    currentSettings: settings,
                    originalSettings: JSON.parse(JSON.stringify(settings))
                };
        }
        static Transform(viewer, tileset, settings) {
            // Parse a desired origin for the tileset from the settings (if available)
            let origin = null;
            if (settings.origin != null) {
                let lat = settings.origin.latitude;
                let lon = settings.origin.longitude;
                let alt = settings.origin.altitude;
                if (lat != null && lon != null && alt != null) {
                    origin = Cesium.Cartesian3.fromDegrees(lon, lat, alt);
                }
            }
            // What is the current position of the tileset?
            // This is a function as we may want to get the current origin after transformations
            let getCurrentOrigin = () => {
                let currentOrigin;
                // If settings dictate to use bounding, then clone bounding sphere center
                if (useBounding) {
                    currentOrigin = Cesium.Cartesian3.clone(root.boundingSphere.center);
                }
                // If settings dictate not to use bounding, then get translation from tileset matrix and clone it
                else {
                    // @ts-ignore
                    currentOrigin = Cesium.Matrix4.getTranslation(tileset.root.transform, new Cesium.Cartesian3());
                }
                return currentOrigin;
            };
            // Should we use the visual bounding box or the tileset matrix for positions?
            let useBounding = settings.origin.usingBoundingBox;
            // Quick access to tileset root
            let root = tileset.root;
            // If there is no origin provided in settings then we dont want to move the tileset.
            // We still need to generate an origin however because after rotation, 
            // we may want to move the tileset to where it was to maintain the position.
            if (!origin) {
                origin = getCurrentOrigin();
            }
            // Calculate offset
            let savedOffset = settings.positionOffset;
            let offset = cesium_drawing_utils_2.CesiumDrawingUtils.GetOffset(origin, savedOffset.north, savedOffset.east, savedOffset.altitude);
            // If an offset was produced, add it to the desired origin
            if (offset != null && offset.x != null) {
                origin.x += offset.x;
                origin.y += offset.y;
                origin.z += offset.z;
            }
            if (settings.etc.dontRotate != true) {
                // Rotate the tileset relative to the desired rotation (so that 'upright' is 'up' where it will be, not where it was)
                let rotation = settings.rotation;
                let hpr = Cesium.HeadingPitchRoll.fromDegrees(rotation.z, rotation.x, rotation.y, new Cesium.HeadingPitchRoll());
                // Apply the result transformation matrix
                // @ts-ignore
                root.transform = Cesium.Transforms.headingPitchRollToFixedFrame(origin, hpr);
                // Force matrix to update
                root.updateTransform();
            }
            // Get where the tileset center is currently (after we applied rotation)
            let currentOrigin = getCurrentOrigin();
            // Apply the difference so that the tileset is at the desired position
            // @ts-ignore
            let newTransform = Cesium.Matrix4.pack(root.transform.clone(new Cesium.Matrix4()), []);
            newTransform[12] += origin.x - currentOrigin.x;
            newTransform[13] += origin.y - currentOrigin.y;
            newTransform[14] += origin.z - currentOrigin.z;
            // @ts-ignore
            root.transform = Cesium.Matrix4.unpack(newTransform);
            // Force matrix to update
            root.updateTransform();
            viewer.scene.requestRender();
        }
    }
    exports.CesiumGeneratorTileset = CesiumGeneratorTileset;
});
define("utils/error-utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ErrorUtils = void 0;
    class ErrorUtils {
        static getMessage(error) {
            if (error == null) {
                return null;
            }
            if (typeof error === "string") {
                return error;
            }
            if (error instanceof Error) {
                return (error).message;
            }
            if (typeof error === "object") {
                if (error.message) {
                    return error.message;
                }
                if (error.Message) {
                    return error.Message;
                }
            }
            return error.toString();
        }
        static LazyCatch(callback, defaultValue = null) {
            try {
                let data = callback();
                return data;
            }
            catch (e) {
                console.log(">>LazyCatchCrash: " + ErrorUtils.getMessage(e));
            }
            return defaultValue;
        }
        static LazyAsyncCatch(callback, defaultValue = null) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield callback();
                    return data;
                }
                catch (e) {
                    console.log(">>LazyAsyncCatchCrash: " + ErrorUtils.getMessage(e));
                }
                return defaultValue;
            });
        }
    }
    exports.ErrorUtils = ErrorUtils;
});
define("bruce-models/common/height-reference", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EHeightReference = void 0;
    var EHeightReference;
    (function (EHeightReference) {
        EHeightReference[EHeightReference["CLAMP_TO_GROUND"] = 0] = "CLAMP_TO_GROUND";
        EHeightReference[EHeightReference["NONE"] = 1] = "NONE";
        EHeightReference[EHeightReference["RELATIVE_TO_GROUND"] = 2] = "RELATIVE_TO_GROUND";
    })(EHeightReference = exports.EHeightReference || (exports.EHeightReference = {}));
});
define("bruce-models/tileset-old/tileset-creation-settings-location", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetCreationSettingsLocation = void 0;
    /**
     * Represents UITileset creation location.
     */
    class TilesetCreationSettingsLocation {
        constructor(rawData) {
            // Origin in degrees / meters to move tileset to. If 0 / null then ignore.
            this.latitude = 0;
            this.longitude = 0;
            this.altitude = 0;
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current state of model as raw JSON data.
         */
        get JSON() {
            let data = {
                latitude: this.latitude,
                longitude: this.longitude,
                altitude: this.altitude
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.latitude != null) {
                this.latitude = rawData.latitude;
            }
            if (rawData.longitude != null) {
                this.longitude = rawData.longitude;
            }
            if (rawData.altitude != null) {
                this.altitude = rawData.altitude;
            }
        }
    }
    exports.TilesetCreationSettingsLocation = TilesetCreationSettingsLocation;
});
define("bruce-models/tileset-old/tileset-creation-settings", ["require", "exports", "bruce-models/common/height-reference", "bruce-models/tileset-old/tileset-creation-settings-location"], function (require, exports, height_reference_1, tileset_creation_settings_location_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UITilesetCreationSettings = exports.PivotOption = exports.ETilesetGeoType = void 0;
    var ETilesetGeoType;
    (function (ETilesetGeoType) {
        ETilesetGeoType["Geoloate"] = "GEOLOCATE";
        ETilesetGeoType["Ungeolocate"] = "UNGEOLOCATE";
    })(ETilesetGeoType = exports.ETilesetGeoType || (exports.ETilesetGeoType = {}));
    var PivotOption;
    (function (PivotOption) {
        PivotOption["None"] = "none";
        PivotOption["Box"] = "box";
        PivotOption["Weight"] = "weight";
    })(PivotOption = exports.PivotOption || (exports.PivotOption = {}));
    /**
     * Represents creation settings for a UITileset.
     * These settings are not applied in any way to the result, only when generating.
     */
    class UITilesetCreationSettings {
        constructor(rawData) {
            // Polygon extrusion style.
            this.polygonExtrusion = [];
            // If polygon geometry should be extruded or not.
            this.polygonExtrusionEnabled = false;
            // Height reference for entities.
            // 0 = clamp to ground, 1 = absolute, relative to ground.
            this.heightReference = height_reference_1.EHeightReference.CLAMP_TO_GROUND;
            // Determines where the generated pivot will be for graphics.
            this.movePivotMode = PivotOption.None;
            // If generated entities should have absolute positions from 0,0,0 or relative to tileset origin.
            // Values are GEOLOCATE or UNGEOLOCATE.
            this.TilesetGeoType = ETilesetGeoType.Geoloate;
            // Center position for the tileset to use in generation.
            this.location = new tileset_creation_settings_location_1.TilesetCreationSettingsLocation(null);
            // If double sided rendering should be forced on for generated models.
            this.doubleSidedRendering = false;
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current state of model as raw JSON data.
         */
        get JSON() {
            let data = {
                TilesetGeoType: this.TilesetGeoType,
                doubleSidedRendering: this.doubleSidedRendering,
                epsg: this.EPSG,
                heightReference: this.heightReference,
                location: this.location.JSON,
                polygonExtrusion: this.polygonExtrusion,
                polygonExtrusionEnabled: this.polygonExtrusionEnabled,
                movePivotMode: this.movePivotMode
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.TilesetGeoType != null) {
                // Bad data contains non sometimes. None = Geo in our system.
                if (rawData.TilesetGeoType == "NONE") {
                    this.TilesetGeoType = ETilesetGeoType.Geoloate;
                }
                else {
                    this.TilesetGeoType = rawData.TilesetGeoType;
                }
            }
            if (rawData.doubleSidedRendering != null) {
                this.doubleSidedRendering = rawData.doubleSidedRendering;
            }
            if (rawData.epsg != null) {
                this.EPSG = rawData.epsg;
            }
            if (rawData.heightReference != null) {
                this.heightReference = rawData.heightReference;
            }
            if (rawData.location != null) {
                this.location.Update(rawData.location);
            }
            if (rawData.polygonExtrusion != null) {
                this.polygonExtrusion = rawData.polygonExtrusion;
            }
            if (rawData.polygonExtrusionEnabled != null) {
                this.polygonExtrusionEnabled = rawData.polygonExtrusionEnabled;
            }
            if (rawData.movePivotMode != null) {
                this.movePivotMode = rawData.movePivotMode;
            }
        }
    }
    exports.UITilesetCreationSettings = UITilesetCreationSettings;
});
define("bruce-models/tileset-old/tileset-creation-terrain-source", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetCreationTerrainSource = exports.EDynamicUITilesetTerrainSourceType = void 0;
    /**
     * Represents the different terrain source types a creation terrain could be.
     */
    var EDynamicUITilesetTerrainSourceType;
    (function (EDynamicUITilesetTerrainSourceType) {
        EDynamicUITilesetTerrainSourceType["External"] = "EXTERNAL";
        EDynamicUITilesetTerrainSourceType["ION"] = "ION";
        EDynamicUITilesetTerrainSourceType["Default"] = "DEFAULT";
    })(EDynamicUITilesetTerrainSourceType = exports.EDynamicUITilesetTerrainSourceType || (exports.EDynamicUITilesetTerrainSourceType = {}));
    /**
     * Represents terrain source used for height referencing in UITileset generation.
     */
    class TilesetCreationTerrainSource {
        constructor(rawData) {
            // The terrain source's name.
            this.name = "Cesium World Terrain";
            // The terrain source's type. Eg: EXTERNAL, ION or DEFAULT.
            this.type = EDynamicUITilesetTerrainSourceType.Default;
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current state of model as raw JSON data.
         */
        get JSON() {
            let data = {
                name: this.name,
                type: this.type,
                ionId: this.ionId,
                url: this.url
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.name != null) {
                this.name = rawData.name;
            }
            if (rawData.type != null) {
                this.type = rawData.type;
            }
            if (rawData.ionId != null) {
                this.ionId = rawData.ionId;
            }
            if (rawData.url != null) {
                this.url = rawData.url;
            }
        }
    }
    exports.TilesetCreationTerrainSource = TilesetCreationTerrainSource;
});
define("bruce-models/tileset-old/tileset-old", ["require", "exports", "utils/error-utils", "bruce-models/tileset-old/tileset-creation-settings", "bruce-models/tileset-old/tileset-creation-terrain-source", "bruce-models/tileset-old/tileset-settings-old"], function (require, exports, error_utils_1, tileset_creation_settings_1, tileset_creation_terrain_source_1, tileset_settings_old_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TilesetOld = exports.ETilesetOldType = void 0;
    /**
     * Possible valid tileset types.
     */
    var ETilesetOldType;
    (function (ETilesetOldType) {
        ETilesetOldType["Static"] = "S";
        ETilesetOldType["Dynamic"] = "D";
        ETilesetOldType["External"] = "X";
        ETilesetOldType["Raster"] = "R";
        ETilesetOldType["MapTiles"] = "M";
    })(ETilesetOldType = exports.ETilesetOldType || (exports.ETilesetOldType = {}));
    /**
     * Represents a single Bruce UITileset.
     */
    class TilesetOld {
        constructor(rawData) {
            // The type of tileset this is.
            this.Type = ETilesetOldType.Static;
            // Name of the root tileset file.
            this.RootFileName = "tileset.json";
            // Settings associated with rendering the tileset.
            this.Settings = new tileset_settings_old_1.TilesetSettingsOld(null);
            // Terrain source used for height referencing during tileset generation.
            this.TilesetCreationTerrainSource = new tileset_creation_terrain_source_1.TilesetCreationTerrainSource(null);
            // Settings related to generating the tileset.
            this.TilesetCreationSettings = new tileset_creation_settings_1.UITilesetCreationSettings(null);
            // Array of associated file ids to the current tileset.
            // This is not automatically loaded. Call load method.
            this.tilesetFileIDs = [];
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current state of tilet as raw JSON data.
         */
        get JSON() {
            let tileset = {
                ID: this.ID,
                Name: this.Name,
                RootFileName: this.RootFileName,
                Type: this.Type,
                Settings: this.Settings.JSON,
                "TilesetCreation.EntitiesFilter": this.TilesetCreationEntitiesFilter,
                "TilesetCreation.EntityType.ID": this.TilesetCreationEntityTypeID,
                "TilesetCreation.Settings": this.TilesetCreationSettings.JSON,
                "TilesetCreation.TerrainSource": this.TilesetCreationTerrainSource.JSON,
                "TilesetCreation.ZoomControl": this.TilesetCreationZoomControl
            };
            return tileset;
        }
        get isIDValid() {
            let id = this.ID;
            if (id == null || !id.trim()) {
                return false;
            }
            return true;
        }
        get isNameValid() {
            let name = this.Name;
            if (name == null || !name.trim()) {
                return false;
            }
            return true;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            if (!rawData) {
                return;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.Name != null) {
                this.Name = rawData.Name;
            }
            if (rawData.Type != null) {
                this.Type = rawData.Type;
            }
            if (rawData.RootFileName != null) {
                this.RootFileName = rawData.RootFileName;
            }
            if (rawData.Settings != null) {
                this.Settings.Update(rawData.Settings);
            }
            if (rawData["TilesetCreation.EntityType.ID"] != null) {
                this.TilesetCreationEntityTypeID = rawData["TilesetCreation.EntityType.ID"];
            }
            if (rawData["TilesetCreation.EntitiesFilter"] != null) {
                this.TilesetCreationEntitiesFilter = rawData["TilesetCreation.EntitiesFilter"];
            }
            if (rawData["TilesetCreation.TerrainSource"] != null) {
                this.TilesetCreationTerrainSource.Update(rawData["TilesetCreation.TerrainSource"]);
            }
            if (rawData["TilesetCreation.Settings"] != null) {
                this.TilesetCreationSettings.Update(rawData["TilesetCreation.Settings"]);
            }
            if (rawData["TilesetCreation.ZoomControl"] != null) {
                this.TilesetCreationZoomControl = this.raw["TilesetCreation.ZoomControl"];
            }
        }
        /**
         * Requests save on current state.
         * @param onError callback to notify about error.
         */
        Save(api, onError) {
            return __awaiter(this, void 0, void 0, function* () {
                if (!this.isIDValid) {
                    onError("Tileset ID is not valid.");
                }
                if (!this.isNameValid) {
                    onError("Tileset Name is not valid.");
                }
                let tileset = this.JSON;
                try {
                    yield api.post(api.BRUCE_URL + "ui.tileset/" + this.ID, JSON.stringify(tileset));
                }
                catch (e) {
                    onError(error_utils_1.ErrorUtils.getMessage(e));
                }
            });
        }
        /**
         * Requests deletion of current tileset.
         * @param onError callback to notify about error.
         */
        Delete(api, onError) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    api.delete(api.BRUCE_URL + `ui.tileset/${this.ID}`);
                }
                catch (e) {
                    onError(error_utils_1.ErrorUtils.getMessage(e));
                }
            });
        }
        /**
         * Refreshes tileset using updated record.
         * @param refreshFileIds If array of file ids should be reloaded.
         */
        Refresh(api, refreshFileIds = false) {
            return __awaiter(this, void 0, void 0, function* () {
                let rawData = yield TilesetOld.GetRawTilesetByID(api, this.ID);
                this._raw = rawData;
                this.Update(rawData);
                if (refreshFileIds === true) {
                    yield this.LoadTilesetFileIDs(api);
                }
            });
        }
        /**
         * Loads/reloads and returns the list of file ids corresponding to the current tileset.
         */
        LoadTilesetFileIDs(api) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield api.get(api.BRUCE_URL + `ui.tileset/${this.ID}/files`);
                    let items = data.Items;
                    this.tilesetFileIDs = items;
                    return items;
                }
                catch (e) {
                    console.log(">>Error: Failed to load list of file ids for tileset: " + this.ID);
                    console.log(e);
                }
            });
        }
        /**
         * Deletes all files associated with the tileset.
         */
        DeleteAllTilesetFiles(api) {
            return __awaiter(this, void 0, void 0, function* () {
                yield api.delete(api.BRUCE_URL + `ui.tileset/${this.ID}/files`);
                this.tilesetFileIDs = [];
            });
        }
        /**
         * Deletes file associated with the tileset.
         * @param fileName
         */
        DeleteTilesetFile(api, fileName) {
            return __awaiter(this, void 0, void 0, function* () {
                yield api.delete(api.BRUCE_URL + `ui.tileset/${this.ID}/file/${fileName}`);
                let fileIndex = this.tilesetFileIDs.findIndex(x => x == fileName);
                if (fileIndex > -1) {
                    this.tilesetFileIDs.splice(fileIndex, 1);
                }
            });
        }
        /**
         * Extracts all DAE files from the tileset and registers them as entities + LOD.
         * @param entityTypeId The entity type to put entity registrations inside.
         * @returns pending action id to monitor.
         */
        IndexGraphics(api, entityTypeId) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.post(api.BRUCE_URL + `ui.tileset/${this.ID}/indexgraphics`, JSON.stringify({
                    entityTypeId: entityTypeId,
                    lodCategoryId: "DAE",
                    lodLevel: 0
                }));
                return data.ID;
            });
        }
        /**
         * Initiates dynamic tileset generation.
         * @param sourceData Will be deprecated. Currently passes some settings to API. Soon API will check tileset record instead.
         * @returns
         */
        GenerateFiles(api, sourceData) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.post(api.BRUCE_URL + `ui.tileset/${this.ID}/generate`, JSON.stringify(sourceData));
                return data.ID;
            });
        }
        /**
         * Returns tileset corresponding to given id.
         * @param tilesetId
         * @param onError callback to notify about error.
         */
        static GetTilesetByID(api, tilesetId, onError) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield TilesetOld.GetRawTilesetByID(api, tilesetId, onError);
                if (data && data.ID != null) {
                    return new TilesetOld(data);
                }
                return null;
            });
        }
        /**
         * Returns raw tileset data corresponding to given id.
         * @param tilesetId
         * @param onError callback to notify about error.
         */
        static GetRawTilesetByID(api, tilesetId, onError) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield api.get(api.BRUCE_URL + `ui.tileset/${tilesetId}`);
                    return data;
                }
                catch (e) {
                    onError(error_utils_1.ErrorUtils.getMessage(e));
                }
                return null;
            });
        }
        /**
         * Returns list of all tileset records.
         */
        static GetTilesetList(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let tilesets = [];
                try {
                    let data = yield api.get(api.BRUCE_URL + "ui.tilesets");
                    let items = data.Items;
                    for (let i = 0; i < items.length; i++) {
                        let tileset = new TilesetOld(items[i]);
                        tilesets.push(tileset);
                    }
                }
                catch (e) {
                    console.log(">>Error: Failed to get tileset list.");
                    console.log(e);
                }
                return tilesets;
            });
        }
    }
    exports.TilesetOld = TilesetOld;
});
define("entry-points/cesium/menu-items/cesium-menu-item-arbitrary-tileset-extended", ["require", "exports", "cesium", "entry-points/cesium/menu-items/cesium-visual-register", "utils/bruce-event-disposable", "entry-points/cesium/menu-items/cesium-menu-item-manager", "entry-points/common/calculator", "entry-points/cesium/visuals/cesium-bruce-entity", "entry-points/cesium/common/cesium-tileset-utils", "entry-points/cesium/visuals/cesium-generator-tileset", "entry-points/common/bruce-meta", "bruce-models/common/bruce-info", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, cesium_visual_register_2, bruce_event_disposable_5, cesium_menu_item_manager_2, calculator_4, cesium_bruce_entity_5, cesium_tileset_utils_1, cesium_generator_tileset_1, bruce_meta_6, bruce_info_3, cesium_utils_7) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumMenuItemArbitraryTilesetExtended = void 0;
    Cesium = __importStar(Cesium);
    class CesiumMenuItemArbitraryTilesetExtended extends bruce_event_disposable_5.BruceEventDisposable {
        constructor(api, viewer, visualRegister, menuItem) {
            super();
            // Dictionary of loaded entities within the tileset
            this.loadedCesiumEntities = {};
            // Style -> Entity type mapping for this layer
            this.styleMapping = [];
            // Calculator used for styling the tileset features
            this.calculator = new calculator_4.Calculator();
            // If the menu item has been initialized yet.
            this.initialized = false;
            this.api = api;
            this.viewer = viewer;
            this.visualRegister = visualRegister;
            this.menuItem = menuItem;
        }
        /**
         * Returns if the menu item has been initialized.
         */
        get IsInitialized() {
            return this.initialized;
        }
        /**
         * Initializes menu item.
         */
        Init() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.initialized) {
                    return;
                }
                try {
                    this.root = this.viewer.entities.add(new Cesium.Entity({
                        id: `__layer_${(cesium_menu_item_manager_2.CesiumMenuItemManager.counter++)}`,
                        show: true
                    }));
                    yield this.initLods();
                    this.initialized = true;
                }
                catch (e) {
                    console.log(">>Error: Failed to initialize extended menu item.");
                    console.log(this);
                    console.log(e);
                }
            });
        }
        /**
         * Checks if menu item has been initialized.
         * Throws error if false.
         */
        initCheck() {
            if (!this.initialized) {
                throw (">>Error: Menu item not initialized. Please call Init method.");
            }
        }
        /**
         * Starts loading tileset graphics.
         */
        Start() {
            return __awaiter(this, void 0, void 0, function* () {
                this.initCheck();
                let menuItem = this.menuItem;
                // Load from tileset URL
                if ((menuItem.tileset && menuItem.tileset.TilesetURL) || menuItem.tilesetURL) {
                    let tilesetUrl = menuItem.tileset ? menuItem.tileset.TilesetURL : menuItem.tilesetURL;
                    this.tileset = new Cesium.Cesium3DTileset({
                        url: tilesetUrl
                    });
                }
                if (this.tileset) {
                    // Add to cesium view and listen for the load
                    let promise = this.viewer.scene.primitives.add(this.tileset);
                    promise.readyPromise.then(() => {
                        this.onCesiumLoad();
                    });
                    this.listeners();
                }
            });
        }
        /**
         * Parses style mapping.
         */
        initLods() {
            return __awaiter(this, void 0, void 0, function* () {
                let menuItem = this.menuItem;
                let styleMapping = menuItem.StyleMapping;
                if (styleMapping) {
                    let fallbackStyleID = menuItem.styleId;
                    if (fallbackStyleID) {
                        try {
                            let data = yield this.api.getViewSettings(fallbackStyleID);
                            this.fallbackStyle = data === null || data === void 0 ? void 0 : data.Settings;
                        }
                        catch (_a) {
                        }
                    }
                }
                else {
                    styleMapping = [];
                    this.fallbackStyle = menuItem.style;
                }
                // Load styles in the style mapping
                for (let i = 0; i < styleMapping.length; i++) {
                    let styleMap = styleMapping[i];
                    if (!styleMap.Style) {
                        let styleID = styleMap.StyleID;
                        if (styleID) {
                            try {
                                let data = yield this.api.getViewSettings(styleID);
                                if (data) {
                                    styleMap.Style = data.Settings;
                                }
                            }
                            catch (_b) {
                            }
                        }
                    }
                }
                this.styleMapping = styleMapping;
            });
        }
        dispose() {
            if (this.tileset) {
                this.tileset.show = false;
            }
            let keys = Object.keys(this.loadedCesiumEntities);
            for (let i = 0; i < keys.length; i++) {
                let visual = this.loadedCesiumEntities[keys[i]];
                if (visual != null && visual.bruceMeta != null) {
                    this.visualRegister.RemoveForMenuItem(this.menuItem.id, visual.bruceMeta);
                }
            }
            super.dispose();
            if (this.loadProgressHandler) {
                this.loadProgressHandler();
                this.loadProgressHandler = null;
            }
            if (this.tileLoadHandler) {
                this.tileLoadHandler();
                this.tileLoadHandler = null;
            }
            if (this.tileFailedHandler) {
                this.tileFailedHandler();
                this.tileFailedHandler = null;
            }
            delete this.tileset;
        }
        /**
         * Initializes cesium event listeners,
         */
        listeners() {
            this.loadProgressHandler = this.tileset.loadProgress.addEventListener((numberOfPendingRequests, numberOfTilesProcessing) => {
            });
            this.tileLoadHandler = this.tileset.tileLoad.addEventListener((tile) => {
                this.mapCyberCityTile(tile);
            });
            this.tileFailedHandler = this.tileset.tileFailed.addEventListener(() => {
            });
        }
        /**
         * Apply tileset settings once tileset has loaded in cesium view.
         */
        onCesiumLoad() {
            return __awaiter(this, void 0, void 0, function* () {
                // Apply settings (transform).
                let tilesetMeta = cesium_tileset_utils_1.CesiumTilesetUtils.GetTilesetInfo(this.tileset);
                if (tilesetMeta.BruceRecURL) {
                    let raw = yield this.api.get(tilesetMeta.BruceRecURL);
                    let settings = raw.Settings;
                    cesium_generator_tileset_1.CesiumGeneratorTileset.ApplySettings(this.viewer, this.tileset, settings);
                }
                // Fly to if menu item is set to that
                if (this.menuItem.FlyTo) {
                    this.viewer.zoomTo(this.tileset, new Cesium.HeadingPitchRange(0.0, -0.5, this.tileset.boundingSphere.radius / 4.0));
                }
            });
        }
        /**
         * Maps tileset features to bruce entities.
         * @param tile
         */
        mapCyberCityTile(tile) {
            let content = tile.content;
            // The ids to request the data
            let entities = [];
            for (let i = 0; i < content.featuresLength; i++) {
                let feature = content.getFeature(i);
                let meta = this.mapCyberCityCesiumEntity(feature);
                if (meta != undefined && meta.EntityID() != null) {
                    entities.push(meta);
                }
            }
            let paths = entities.map(x => x.entityPath);
            bruce_info_3.BruceInfo.GetInstanceIDs(this.api, paths).then((ids) => {
                // Get bruce infos
                bruce_info_3.BruceInfo.GetEntitiesByList(this.api, ids).then((info) => {
                    entities.forEach((entity, index) => {
                        let bruceItem = info.find(x => x.Bruce.ID == ids[index]);
                        let cesiumEntity = this.loadedCesiumEntities[entity.HashPath()];
                        if (bruceItem) {
                            // This overrides the blanket entity ID from menu item with the correct ID from bruce info
                            // CC3D entities use blanket ID whereas our (IFC) tilesets have individual IDs so need to be updated
                            if (cesiumEntity) {
                                cesiumEntity.bruceMeta.entityTypeId = bruceItem.Bruce["EntityType.ID"];
                            }
                            this.customizeModel(cesiumEntity, bruceItem);
                        }
                        else {
                            this.customizeModel(cesiumEntity);
                        }
                        this.visualRegister.Add(cesiumEntity, cesium_visual_register_2.VisualType.TILESET_FEATURE, this.menuItem.id, this.menuItem.renderPriority);
                    });
                })
                    .catch(() => {
                    entities.forEach((entity) => {
                        let cesiumEntity = this.loadedCesiumEntities[entity.HashPath()];
                        this.customizeModel(cesiumEntity);
                        this.visualRegister.Add(cesiumEntity, cesium_visual_register_2.VisualType.TILESET_FEATURE, this.menuItem.id, this.menuItem.renderPriority);
                    });
                });
            });
        }
        /**
         * Maps and stores CC3D entity to possible Bruce ID.
         * @param cesiumEntity
         */
        mapCyberCityCesiumEntity(cesiumEntity) {
            let entity = null;
            let id = cesium_tileset_utils_1.CesiumTilesetUtils.EntityIDPathFromFeature(cesiumEntity);
            if (id != undefined) {
                entity = new cesium_bruce_entity_5.CesiumBruceEntity(this.viewer, [cesiumEntity], new bruce_meta_6.BruceMeta(id, null, this.api.clientAccountId));
                entity.DoOnEntity((entity) => {
                    entity.show = true;
                });
                this.loadedCesiumEntities[entity.bruceMeta.HashPath()] = entity;
            }
            return entity ? entity.bruceMeta : null;
        }
        /**
         * Customizes tileset entity using current model styling.
         * @param bruceEntity
         * @param info
         */
        customizeModel(bruceEntity, info = null) {
            if (!bruceEntity) {
                return;
            }
            try {
                let entityTypeID = bruceEntity.bruceMeta.entityTypeId;
                // Try find entity type style map
                let styleMap = this.styleMapping.find(x => x.EntityTypeID == entityTypeID);
                let style = styleMap ? styleMap.Style : null;
                // No style found? Try use fallback
                if (!style) {
                    style = this.fallbackStyle;
                }
                let modelStyle = style ? style.modelStyle : null;
                if (modelStyle && modelStyle.customize) {
                    let bcolor = this.calculator.getColor(this.calculator.calcValues(info.raw, modelStyle.fillColor));
                    let color = cesium_utils_7.CesiumUtils.ColorToCesiumColor(bcolor);
                    if (color != null) {
                        bruceEntity.Colorize(color);
                    }
                }
            }
            catch (e) {
            }
        }
        /**
         * Performs the process of refreshing application of style on an entity.
         * @param entity
         */
        UpdateEntity(entity) {
            let meta = new bruce_meta_6.BruceMeta([entity.Bruce.ID], entity.Bruce["EntityType.ID"], null);
            let cesiumEntity = this.loadedCesiumEntities[meta.HashPath()];
            this.customizeModel(cesiumEntity, entity);
        }
    }
    exports.CesiumMenuItemArbitraryTilesetExtended = CesiumMenuItemArbitraryTilesetExtended;
});
define("entry-points/cesium/menu-items/cesium-menu-item-loaded-bruce-entities-extended", ["require", "exports", "cesium", "bruce-models/common/camera-zoom-control", "bruce-models/common/polygon", "utils/bruce-event", "utils/bruce-event-disposable", "entry-points/common/bruce-meta", "entry-points/cesium/common/cesium-entity-utils", "entry-points/cesium/visuals/cesium-generator-geometry", "entry-points/cesium/visuals/cesium-generator-model", "entry-points/cesium/menu-items/cesium-menu-item-manager", "entry-points/cesium/menu-items/cesium-visual-register"], function (require, exports, Cesium, camera_zoom_control_5, polygon_4, bruce_event_7, bruce_event_disposable_6, bruce_meta_7, cesium_entity_utils_5, cesium_generator_geometry_2, cesium_generator_model_2, cesium_menu_item_manager_3, cesium_visual_register_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumMenuItemLoadedBruceEntitiesExtended = void 0;
    Cesium = __importStar(Cesium);
    class CesiumMenuItemLoadedBruceEntitiesExtended extends bruce_event_disposable_6.BruceEventDisposable {
        constructor(api, viewer, visualRegister, menuItem, getter) {
            super();
            // All entities that have been registered after loading.
            this.loadedEntities = {};
            // Notifies when visuals are added or removed.
            this.visualUpdateEvent = new bruce_event_7.BruceEvent();
            // If the menu item has been initialized yet.
            this.initialized = false;
            this.api = api;
            this.viewer = viewer;
            this.visualRegister = visualRegister;
            this.menuItem = menuItem;
            this.entitiesGetter = getter;
        }
        /**
         * Returns if the menu item has been initialized.
         */
        get IsInitialized() {
            return this.initialized;
        }
        /**
         * Initializes menu item.
         */
        Init() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.initialized) {
                    return;
                }
                try {
                    this.root = this.viewer.entities.add(new Cesium.Entity({
                        id: `__layer_${(cesium_menu_item_manager_3.CesiumMenuItemManager.counter++)}`,
                        show: true
                    }));
                    this.addDisposable(this.entitiesGetter.entityReadyEvent.Subscribe((entity) => {
                        this.entityReady(entity);
                    }));
                    yield this.initLods();
                    this.initialized = true;
                }
                catch (e) {
                    console.log(">>Error: Failed to initialize extended menu item.");
                    console.log(this);
                    console.log(e);
                }
            });
        }
        /**
         * Checks if menu item has been initialized.
         * Throws error if false.
         */
        initCheck() {
            if (!this.initialized) {
                throw (">>Error: Menu item not initialized. Please call Init method first.");
            }
        }
        /**
         * Starts the loading process.
         */
        Start() {
            this.initCheck();
            this.entitiesGetter.Start();
        }
        /**
         * Stops loading anymore entities.
         */
        Pause() {
            this.initCheck();
            this.entitiesGetter.Pause();
        }
        /**
         * Triggers an update on boundaries.
         * This will cascade into getting entities if boundaries are valid.
         */
        Update() {
            this.initCheck();
            this.entitiesGetter.Update();
        }
        /**
         * Adds a given entity if no current entity matches meta.
         * @param entity
         */
        AddEntity(entity) {
            let cur = this.loadedEntities[entity.Bruce.ID];
            if (!cur) {
                this.entityReady(entity);
            }
        }
        /**
         * Removes entity that matches given meta.
         * @param meta
         * @param eventTrigger, if subscriptions should be notified.
         */
        RemoveEntity(meta, eventTrigger = true) {
            let cur = this.loadedEntities[meta.EntityID()];
            if (cur) {
                this.visualRegister.RemoveForMenuItem(this.menuItem.id, cur.bruceMeta);
                delete this.loadedEntities[meta.EntityID()];
                if (eventTrigger) {
                    this.entityRemove(meta);
                }
                this.viewer.scene.requestRender();
            }
        }
        /**
         * Performs the process of removing and re-adding a given entity.
         * @param entity
         */
        UpdateEntity(entity) {
            let meta = new bruce_meta_7.BruceMeta([entity.Bruce.ID], entity.Bruce["EntityType.ID"], null);
            this.RemoveEntity(meta);
            this.AddEntity(entity);
        }
        /**
         * Returns all visuals registered for this menu item.
         * Note that these visuals may not be the ones visible as another menu item with higher-
         * render priority rendered them instead.
         */
        GetMenuItemVisuals() {
            return this.visualRegister.getByMenuItem(this.menuItem.id);
        }
        /**
         * @returns entity ready event for this menu item.
         */
        getEntityReadyEvent() {
            this.initCheck();
            return this.entitiesGetter.entityReadyEvent;
        }
        /**
         * @returns event for when visuals are added or removed.
         */
        getVisualUpdateEvent() {
            return this.visualUpdateEvent;
        }
        /**
         * Parses styles to create generators.
         */
        initLods() {
            return __awaiter(this, void 0, void 0, function* () {
                let style = this.menuItem.Style;
                if (!style && this.menuItem.StyleID) {
                    try {
                        let data = yield this.api.getViewSettings(this.menuItem.StyleID.toString());
                        style = data.Settings;
                    }
                    catch (_a) {
                    }
                }
                this.geometryGenerator = new cesium_generator_geometry_2.CesiumGeneratorGeometry(this.api, this.viewer, style, this.root),
                    this.glbGenerator = new cesium_generator_model_2.CesiumGeneratorModel(this.api, this.viewer, style === null || style === void 0 ? void 0 : style.modelStyle, this.menuItem.LODCategoryID, this.menuItem.LODLevel, this.root);
            });
        }
        /**
         * Disposes menu item and related subscriptions.
         */
        dispose() {
            super.dispose();
            this.entitiesGetter.Dispose();
            this.geometryGenerator.dispose();
            this.glbGenerator.dispose();
            // Remove root entity, this will remove all entities for the menu item from the 3d view.
            cesium_entity_utils_5.CesiumEntityUtils.RemoveEntity(this.viewer, this.root);
            let visuals = Object.keys(this.loadedEntities);
            for (let i = 0; i < visuals.length; i++) {
                let visual = visuals[i];
                let meta = new bruce_meta_7.BruceMeta([visual], null, this.api.clientAccountId);
                this.visualRegister.RemoveForMenuItem(this.menuItem.id, meta);
                // Notify subscriptions that visual was removed.
                this.entityRemove(meta);
            }
            this.viewer.scene.requestRender();
        }
        /**
         * Called when an individual entity loads.
         * @param info
         */
        entityReady(info) {
            if (!this.disposed) {
                this.createEntity(info, false);
            }
        }
        /**
         * Parse the items returned by the request to backend into entities of the UI
         * @param items - the items receievd
         */
        createEntity(item, forced) {
            return __awaiter(this, void 0, void 0, function* () {
                let bruceId = item.Bruce.ID;
                if (item.location == undefined) {
                    return;
                }
                let lod = this.menuItem.LODLevel;
                let meta = new bruce_meta_7.BruceMeta([item.Bruce.ID], item.Bruce["EntityType.ID"], this.menuItem.clientAccountId);
                let createEntity = (((this.loadedEntities[bruceId] != null) && (this.loadedEntities[bruceId].lod != lod)) || (this.loadedEntities[bruceId] == null))
                    && (lod != -1)
                    && (this.menuItem.DisplayType != camera_zoom_control_5.ECameraZoomControlDisplayType.Hidden);
                createEntity = createEntity || forced;
                if (createEntity) {
                    if (this.menuItem.fixPolygons) {
                        if (item.geometry.Polygon && item.geometry.Polygon.length > 0) {
                            item.geometry.Polygon = polygon_4.Polygon.Fix(item.geometry.Polygon);
                        }
                    }
                    let newCesiumEntity = yield this.drawEntity(item, lod, forced);
                    if (newCesiumEntity === null || newCesiumEntity === void 0 ? void 0 : newCesiumEntity["entity"]) {
                        newCesiumEntity["entity"].bruceMeta = meta;
                        this.loadedEntities[bruceId] = newCesiumEntity["entity"];
                        // Register the created visual.
                        this.visualRegister.Add(newCesiumEntity["entity"], newCesiumEntity["actualVisual"], 
                        //newCesiumEntity["intendedVisual"],
                        //newCesiumEntity["clamping"],
                        this.menuItem.id, this.menuItem.renderPriority);
                        // Notify subscriptions that visual was updated.
                        this.entityDrawn(meta, newCesiumEntity === null || newCesiumEntity === void 0 ? void 0 : newCesiumEntity.entity);
                    }
                }
                let destroyEntity = ((lod == -1) || (this.menuItem.DisplayType == camera_zoom_control_5.ECameraZoomControlDisplayType.Hidden) || this.disposed);
                if (destroyEntity) {
                    // Remove registration of visual.
                    let meta = new bruce_meta_7.BruceMeta([item.Bruce.ID], item.Bruce["EntityType.ID"], this.api.clientAccountId);
                    this.visualRegister.RemoveForMenuItem(this.menuItem.id, meta);
                    if (this.loadedEntities[bruceId]) {
                        delete this.loadedEntities[bruceId];
                        // Notify subscriptions that visual was removed.
                        this.entityRemove(meta);
                    }
                }
            });
        }
        /**
         * Creates visual representation of a entity
         * @param item Bruce Info describing the entity
         * @param lod The lod level required for it
         */
        drawEntity(item, lod, forceCacheInCesium) {
            return __awaiter(this, void 0, void 0, function* () {
                let newVisualEntity = null;
                let intendedVisual = null;
                let actualVisual = null;
                let displayType = this.menuItem.DisplayType;
                if (displayType == camera_zoom_control_5.ECameraZoomControlDisplayType.Model3D) {
                    intendedVisual = cesium_visual_register_3.VisualType.MODEL3D;
                    actualVisual = cesium_visual_register_3.VisualType.MODEL3D;
                    newVisualEntity = yield this.glbGenerator.loadEntity(item, forceCacheInCesium);
                    if (this.disposed) {
                        return null;
                    }
                    if (!newVisualEntity) {
                        displayType = camera_zoom_control_5.ECameraZoomControlDisplayType.Geometry;
                    }
                }
                if (displayType == camera_zoom_control_5.ECameraZoomControlDisplayType.Geometry || displayType == camera_zoom_control_5.ECameraZoomControlDisplayType.Polygon) {
                    intendedVisual = intendedVisual ? intendedVisual : cesium_visual_register_3.VisualType.GEOMETRY;
                    actualVisual = cesium_visual_register_3.VisualType.GEOMETRY;
                    newVisualEntity = this.geometryGenerator.loadEntity(item, displayType);
                    if (!newVisualEntity) {
                        displayType = camera_zoom_control_5.ECameraZoomControlDisplayType.Point;
                    }
                }
                if (displayType == camera_zoom_control_5.ECameraZoomControlDisplayType.Point) {
                    intendedVisual = intendedVisual ? intendedVisual : cesium_visual_register_3.VisualType.POINT;
                    actualVisual = cesium_visual_register_3.VisualType.POINT;
                    newVisualEntity = this.geometryGenerator.loadEntity(item, camera_zoom_control_5.ECameraZoomControlDisplayType.Point);
                }
                if (newVisualEntity) {
                    newVisualEntity.lod = lod;
                }
                let clamping = this.clampingForEntities(newVisualEntity.uiEntities);
                return Promise.resolve({
                    "entity": newVisualEntity,
                    "intendedVisual": intendedVisual,
                    "actualVisual": actualVisual,
                    "clamping": clamping
                });
            });
        }
        /**
         * Explores an entity and undestant its clamping values.
         * @param entity
         */
        clampingForEntities(entities) {
            if (entities) {
                for (let i = 0; i < entities.length; i++) {
                    let entity = entities[i];
                    if (entity) {
                        if (entity.model) {
                            // @ts-ignore
                            return (entity.model.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                        if (entity.polygon) {
                            // @ts-ignore
                            return (entity.polygon.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                        if (entity.polyline) {
                            //TODO:polylines dont have hight references
                            return (entity.polyline.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                        if (entity.point) {
                            // @ts-ignore
                            return (entity.point.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                        if (entity.billboard) {
                            return (entity.billboard.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND);
                        }
                    }
                }
            }
            return false;
        }
        /**
         * Notifies subscriptions about entity visual being created or updated.
         * @param meta
         * @param entity
         */
        entityDrawn(meta, entity) {
            this.visualUpdateEvent.Trigger({ visual: entity, meta: meta });
        }
        /**
         * Notifies subscriptions about entity visual being removed.
         * @param meta
         */
        entityRemove(meta) {
            this.visualUpdateEvent.Trigger({ visual: null, meta: meta });
        }
    }
    exports.CesiumMenuItemLoadedBruceEntitiesExtended = CesiumMenuItemLoadedBruceEntitiesExtended;
});
define("entry-points/common/entity-preloaded-getter", ["require", "exports", "utils/bruce-event", "utils/bruce-event-disposable", "entry-points/common/entities-getter-interface"], function (require, exports, bruce_event_8, bruce_event_disposable_7, entities_getter_interface_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityPreloadedGetter = void 0;
    class EntityPreloadedGetter extends bruce_event_disposable_7.BruceEventDisposable {
        /**
         * Create getter instance for given entities to deliver batches of entities.
         * @param entities the pool of entities to deliver.
         * @param delay how often in milliseconds should batch be delivered.
         * @param batchSize how many entities to deliver per batch.
         */
        constructor(entities, delay = 300, batchSize = 200) {
            super();
            // The last loading state.
            this._lastLoadingState = entities_getter_interface_2.GetterPagesLoadingState.Stopped;
            // If loading is disposed and should stop entirely.
            this.getterDisposed = false;
            // Current delivery index.
            this.currentIndex = 0;
            this.entityReadyEvent = new bruce_event_8.BruceEvent();
            this.loadingStateChangedEvent = new bruce_event_8.BruceEvent();
            this.delay = delay;
            this.entities = entities;
            this.batchSize = batchSize;
        }
        /**
         * Returns the last loading state.
         */
        get LastLoadingState() {
            return this._lastLoadingState;
        }
        startLoadingThread() {
            if (this.deliverTimeout == null && !this.getterDisposed) {
                let tick = () => {
                    this.doDelivery();
                    if (this.currentIndex >= this.entities.length) {
                        this.loadingStateChangedEvent.Trigger(entities_getter_interface_2.GetterPagesLoadingState.Stopped);
                        this.deliverTimeout = null;
                    }
                    else {
                        this.deliverTimeout = setTimeout(() => {
                            tick();
                        }, this.delay);
                    }
                };
                this.loadingStateChangedEvent.Trigger(entities_getter_interface_2.GetterPagesLoadingState.Started);
                tick();
            }
        }
        doDelivery() {
            let index = this.currentIndex;
            let entities = this.entities;
            let slice = entities.slice(index, this.batchSize + index);
            for (let i = 0; i < slice.length; i++) {
                this.entityReadyEvent.Trigger(slice[i]);
            }
            this.currentIndex += this.batchSize;
        }
        /**
         * Manually calls a batch delivery.
         */
        Update() {
            this.doDelivery();
        }
        /**
         * Sets the getter to paused state.
         * This means entities that are already delivering will continue to load,
         * but new requests wont be made.
         */
        Pause() {
            super.dispose();
            clearTimeout(this.deliverTimeout);
            this.deliverTimeout = null;
        }
        /**
         * Sets the getter to unpaused state.
         * This means new entity deliveries will be made.
         */
        Start() {
            this.startLoadingThread();
        }
        /**
         * Disposes the getter.
         * This means entities that are already delivering will not load.
         * New batches will not be delivered.
         */
        Dispose() {
            super.dispose();
            clearTimeout(this.deliverTimeout);
            this.deliverTimeout = null;
            this.getterDisposed = true;
        }
    }
    exports.EntityPreloadedGetter = EntityPreloadedGetter;
});
define("entry-points/cesium/menu-items/cesium-menu-item-unknown", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumMenuItemUnknown = void 0;
    /**
     * Represents a menu item that did not fall into other extended cateogories.
     * This is also used for category level menu items that are used to enable others.
     */
    class CesiumMenuItemUnknown {
        constructor(menuItem) {
            this.menuItem = menuItem;
        }
        Init() {
            return;
        }
        Start() {
            return;
        }
        dispose() {
            return;
        }
        UpdateEntity(entity) {
            return;
        }
    }
    exports.CesiumMenuItemUnknown = CesiumMenuItemUnknown;
});
define("entry-points/cesium/menu-items/cesium-menu-item-model-tileset-extended", ["require", "exports", "cesium", "entry-points/cesium/menu-items/cesium-visual-register", "utils/bruce-event-disposable", "entry-points/cesium/menu-items/cesium-menu-item-manager", "entry-points/common/calculator", "entry-points/cesium/visuals/cesium-bruce-entity", "entry-points/common/bruce-meta", "bruce-models/common/bruce-info", "entry-points/cesium/common/cesium-utils", "bruce-models/tileset/tileset", "bruce-maps-widget"], function (require, exports, Cesium, cesium_visual_register_4, bruce_event_disposable_8, cesium_menu_item_manager_4, calculator_5, cesium_bruce_entity_6, bruce_meta_8, bruce_info_4, cesium_utils_8, tileset_3, bruce_maps_widget_6) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumMenuItemModelTilesetExtended = void 0;
    Cesium = __importStar(Cesium);
    const MAX_BATCHES = 2;
    const BATCH_SIZE = 30;
    const BATCH_CHECK_SIZE = 1000;
    const BATCH_DELAY = 200;
    class CesiumMenuItemModelTilesetExtended extends bruce_event_disposable_8.BruceEventDisposable {
        constructor(api, viewer, visualRegister, menuItem) {
            super();
            // Dictionary of loaded entities within the tileset
            this.loadedCesiumEntities = {};
            // Calculator used for styling the tileset features
            this.calculator = new calculator_5.Calculator();
            // If the menu item has been initialized yet.
            this.initialized = false;
            // Entity type id -> style mapping.
            this.styleMapping = [];
            // If all styles in mapping have finished loading.
            this.styleMappingLoaded = false;
            // What entity type styles have finished loading so far.
            // Entity type id -> true/false if finished loading.
            this.styleMappingsLoaded = {};
            // Amount of styling queues currently being processed.
            // This should not exceed 'MAX_BATCHES'.
            this.runningQueues = 0;
            // Array of entity ids that are for features that need full entity data to be styled.
            // When something is loaded it will be removed from this queue.
            this.recordLoadQueue = [];
            // Array of entity ids that are for features yet to be determined if they need full data for styling.
            this.recordCheckQueue = [];
            this.api = api;
            this.viewer = viewer;
            this.visualRegister = visualRegister;
            this.menuItem = menuItem;
        }
        /**
         * Returns if the menu item has been initialized.
         */
        get IsInitialized() {
            return this.initialized;
        }
        /**
         * Initializes menu item.
         */
        Init() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.initialized) {
                    return;
                }
                try {
                    this.root = this.viewer.entities.add(new Cesium.Entity({
                        id: `__layer_${(cesium_menu_item_manager_4.CesiumMenuItemManager.counter++)}`,
                        show: true
                    }));
                    this.initialized = true;
                }
                catch (e) {
                    console.log(">>Error: Failed to initialize extended menu item.");
                    console.log(this);
                    console.log(e);
                }
            });
        }
        /**
         * Checks if menu item has been initialized.
         * Throws error if false.
         */
        initCheck() {
            if (!this.initialized) {
                throw (">>Error: Menu item not initialized. Please call Init method.");
            }
        }
        /**
         * Starts loading tileset graphics.
         */
        Start() {
            return __awaiter(this, void 0, void 0, function* () {
                this.initCheck();
                const menuItem = this.menuItem;
                const rec = yield tileset_3.Tileset.GetByID(this.api, menuItem.tileset.TilesetID, true);
                this.tilesetRecord = rec;
                const rootFile = rec.rootFileName ? rec.rootFileName : "tileset.json";
                const url = rec.getFileURL(this.api, rootFile) + "?generation=" + rec.generateVersion;
                this.tileset = new Cesium.Cesium3DTileset({
                    // Generation added so on re-generation of tileset we can make sure cache is cleared.
                    url: url
                });
                const blending = menuItem === null || menuItem === void 0 ? void 0 : menuItem.StyleBlending;
                this.tileset.colorBlendMode = blending ? blending.blendMode : Cesium.Cesium3DTileColorBlendMode.MIX;
                this.tileset.colorBlendAmount = blending ? blending.blendPercent : 0.9;
                this.tileset.show = true;
                // Add to cesium view and listen for the load.
                const promise = this.viewer.scene.primitives.add(this.tileset);
                promise.readyPromise.then(() => {
                    this.onCesiumLoad();
                });
                this.listeners();
            });
        }
        /**
         * Parses style mapping.
         */
        initStyleMap() {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                let menuItem = this.menuItem;
                if (menuItem.Style) {
                    this.fallbackStyle = menuItem.Style;
                }
                else {
                    let fallbackStyleID = menuItem.styleId;
                    if (fallbackStyleID) {
                        try {
                            let data = yield this.api.getViewSettings(fallbackStyleID);
                            this.fallbackStyle = data === null || data === void 0 ? void 0 : data.Settings;
                        }
                        catch (e) {
                            console.log(e);
                        }
                    }
                }
                // Load styles in the style mapping
                let styleMapping = menuItem.StyleMapping;
                if (!styleMapping) {
                    styleMapping = [];
                }
                this.styleMapping = styleMapping;
                // It is default style.
                // We have to get all possible entity type ids and append them to mapping.
                if (!this.fallbackStyle) {
                    try {
                        const modelTree = (_b = (_a = this.tileset) === null || _a === void 0 ? void 0 : _a.extensions) === null || _b === void 0 ? void 0 : _b.modelTree;
                        if (modelTree) {
                            const entityTypeIds = this.getEntityTypeIdsFromModelTree(modelTree);
                            for (let i = 0; i < entityTypeIds.length; i++) {
                                let entityTypeId = entityTypeIds[i];
                                if (styleMapping.findIndex(x => x.EntityTypeID == entityTypeId) <= -1) {
                                    styleMapping.push({
                                        EntityTypeID: entityTypeId,
                                        StyleID: null,
                                        Style: null
                                    });
                                }
                            }
                        }
                    }
                    catch (e) {
                        console.log(e);
                    }
                }
                for (let i = 0; i < styleMapping.length; i++) {
                    if (this.disposed) {
                        break;
                    }
                    let styleMap = styleMapping[i];
                    if (!styleMap.Style) {
                        let styleId = styleMap.StyleID;
                        // Get default style of the entity type.
                        if (!styleId) {
                            try {
                                let entityType = yield bruce_maps_widget_6.EntityType.GetByID(this.api, styleMap.EntityTypeID);
                                styleId = entityType === null || entityType === void 0 ? void 0 : entityType["DisplaySetting.ID"];
                            }
                            catch (e) {
                                console.log(e);
                            }
                        }
                        if (styleId) {
                            try {
                                let data = yield this.api.getViewSettings(styleId);
                                if (data) {
                                    styleMap.Style = data.Settings;
                                    styleMap.StyleID = styleId;
                                }
                            }
                            catch (e) {
                                console.log(e);
                            }
                        }
                    }
                    if (styleMap.EntityTypeID && styleMap.Style) {
                        this.styleMappingsLoaded[styleMap.EntityTypeID] = true;
                        // Process what has loaded so far.
                        this.processTilesetFeatureCheckQueue();
                        // Style what has loaded so far.
                        this.processQueue();
                    }
                }
                this.styleMappingLoaded = true;
                if (!this.disposed) {
                    // Process all unchecked features.
                    yield this.processTilesetFeatureCheckQueue();
                    // Style remaining features.
                    this.processQueue();
                }
            });
        }
        /**
         * Returns array of all entity type ids inside given model tree.
         * @param modelTree
         * @returns
         */
        getEntityTypeIdsFromModelTree(modelTree) {
            let entityTypeIds = [];
            this.digEntityTypeIdsFromModelTreeBranch(modelTree, entityTypeIds);
            return entityTypeIds;
        }
        /**
         * Appends to given array all entity type ids found in given branch and its children.
         * @param branch
         * @param arr
         */
        digEntityTypeIdsFromModelTreeBranch(branch, arr) {
            if (branch) {
                // Does not yet include this entity type id.
                if (branch.typeId && !arr.includes(branch.typeId)) {
                    arr.push(branch.typeId);
                }
                if (branch.children) {
                    for (let i = 0; i < branch.children.length; i++) {
                        let child = branch.children[i];
                        this.digEntityTypeIdsFromModelTreeBranch(child, arr);
                    }
                }
            }
        }
        dispose() {
            if (this.tileset) {
                this.tileset.show = false;
            }
            clearInterval(this.queueLoadInterval);
            clearInterval(this.queueCheckInterval);
            const keys = Object.keys(this.loadedCesiumEntities);
            for (let i = 0; i < keys.length; i++) {
                const visual = this.loadedCesiumEntities[keys[i]];
                if (visual != null && visual.bruceMeta != null) {
                    this.visualRegister.RemoveForMenuItem(this.menuItem.id, visual.bruceMeta);
                }
            }
            super.dispose();
            if (this.loadProgressHandler) {
                this.loadProgressHandler();
                this.loadProgressHandler = null;
            }
            if (this.tileLoadHandler) {
                this.tileLoadHandler();
                this.tileLoadHandler = null;
            }
            if (this.tileFailedHandler) {
                this.tileFailedHandler();
                this.tileFailedHandler = null;
            }
            delete this.tileset;
        }
        /**
         * Initializes cesium event listeners,
         */
        listeners() {
            this.loadProgressHandler = this.tileset.loadProgress.addEventListener((numberOfPendingRequests, numberOfTilesProcessing) => {
            });
            this.tileLoadHandler = this.tileset.tileLoad.addEventListener((tile) => {
                this.mapTile(tile);
            });
            this.tileFailedHandler = this.tileset.tileFailed.addEventListener(() => {
            });
        }
        /**
         * Apply tileset settings once tileset has loaded in cesium view.
         */
        onCesiumLoad() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.disposed) {
                    return;
                }
                this.positionTileset();
                this.configureTileset();
                this.viewer.scene.requestRender();
                // Fly to if menu item is set to that
                if (this.menuItem.FlyTo) {
                    this.viewer.zoomTo(this.tileset, new Cesium.HeadingPitchRange(0.0, -0.5, this.tileset.boundingSphere.radius / 4.0));
                }
                this.initStyleMap();
                this.startRecordLoadingQueue();
            });
        }
        /**
         * Starts interval that occasionally checks for records that need loading (for styling).
         */
        startRecordLoadingQueue() {
            this.queueLoadInterval = setInterval(() => {
                this.processQueue();
            }, 5000);
        }
        positionTileset() {
            const settings = this.tilesetRecord.settings;
            const origin = Cesium.Cartesian3.fromDegrees(+settings.location.longitude, +settings.location.latitude, +settings.location.altitude);
            const transform = settings.transform;
            const heading = !(transform === null || transform === void 0 ? void 0 : transform.heading) ? 0 : transform.heading;
            const pitch = !(transform === null || transform === void 0 ? void 0 : transform.pitch) ? 0 : transform.pitch;
            const roll = !(transform === null || transform === void 0 ? void 0 : transform.roll) ? 0 : transform.roll;
            const hpr = Cesium.HeadingPitchRoll.fromDegrees(heading, pitch, roll, new Cesium.HeadingPitchRoll());
            const tileset = this.tileset;
            const root = tileset.root;
            root.transform = Cesium.Transforms.headingPitchRollToFixedFrame(origin, hpr);
            let scale = +(transform === null || transform === void 0 ? void 0 : transform.scale);
            if (!scale || scale <= 0) {
                scale = 0.000001;
            }
            const scaleMatrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(scale, scale, scale), new Cesium.Matrix4());
            root.transform = Cesium.Matrix4.multiply(root.transform, scaleMatrix, root.transform);
            // Force matrix to update.
            root.updateTransform();
        }
        /**
         * Applies render settings to the tileset.
         */
        configureTileset() {
            const settings = this.tilesetRecord.settings;
            const tileset = this.tileset;
            const maxScreenSpaceError = settings.maximumScreenSpaceError;
            tileset.maximumScreenSpaceError = maxScreenSpaceError;
        }
        /**
         * Maps tileset features to bruce entities.
         * @param tile
         * @returns
         */
        mapTile(tile) {
            let content = tile.content;
            // The ids to request the data
            let entities = [];
            for (let i = 0; i < content.featuresLength; i++) {
                let feature = content.getFeature(i);
                let meta = this.mapTilesetFeature(feature);
                if (meta != undefined && meta.EntityID() != null) {
                    entities.push(meta);
                    let entity = this.loadedCesiumEntities[meta.EntityID()];
                    this.visualRegister.addVisual(entity, cesium_visual_register_4.VisualType.TILESET_FEATURE, cesium_visual_register_4.VisualType.TILESET_FEATURE, false, this.menuItem.id);
                    this.queueTilesetFeatureStyle(meta, entity);
                }
            }
            if (content.featuresLength) {
                this.processQueue();
                this.viewer.scene.requestRender();
            }
        }
        /**
         * Queues given tileset feature to be styled.
         * @param meta
         * @param entity
         */
        queueTilesetFeatureStyle(meta, entity) {
            let entityId = meta.EntityID();
            if (this.styleMappingLoaded || this.styleMappingsLoaded[meta.entityTypeId] == true) {
                let needsData = this.getTilesetFeatureNeedsFullData(meta);
                if (needsData) {
                    if (this.recordLoadQueue.findIndex(x => x == entityId)) {
                        this.recordLoadQueue.push(entityId);
                    }
                }
                else {
                    this.styleTilesetFeature(entity);
                }
            }
            else {
                this.recordCheckQueue.push(entityId);
            }
        }
        /**
         * Processes queue of tileset features for checking if they need full style data or not.
         */
        processTilesetFeatureCheckQueue() {
            return __awaiter(this, void 0, void 0, function* () {
                return new Promise((res) => {
                    clearInterval(this.queueCheckInterval);
                    this.queueCheckInterval = setInterval(() => {
                        if (this.disposed) {
                            clearInterval(this.queueCheckInterval);
                            res();
                            return;
                        }
                        // Construct batch for loaded styles.
                        let batch = [];
                        if (this.styleMappingLoaded) {
                            batch = this.recordCheckQueue.splice(0, BATCH_CHECK_SIZE);
                        }
                        else {
                            for (let i = 0; i < this.recordCheckQueue.length; i++) {
                                let entityId = this.recordCheckQueue[i];
                                let entity = this.loadedCesiumEntities[entityId];
                                if (entity) {
                                    let entityTypeId = entity.bruceMeta.entityTypeId;
                                    if (entityTypeId) {
                                        if (this.styleMappingsLoaded[entityTypeId] == true) {
                                            batch.push(entityId);
                                        }
                                    }
                                }
                                if (batch.length >= BATCH_CHECK_SIZE) {
                                    break;
                                }
                            }
                            for (let i = 0; i < batch.length; i++) {
                                let entityId = batch[i];
                                let index = this.recordCheckQueue.findIndex(x => x == entityId);
                                if (index > -1) {
                                    this.recordCheckQueue.splice(index, 1);
                                }
                            }
                        }
                        if (batch.length) {
                            for (let i = 0; i < batch.length; i++) {
                                let item = batch[i];
                                let entity = this.loadedCesiumEntities[item];
                                if (entity) {
                                    this.queueTilesetFeatureStyle(entity.bruceMeta, entity);
                                }
                            }
                        }
                        else {
                            clearInterval(this.queueCheckInterval);
                            res();
                        }
                    }, 50);
                });
            });
        }
        /**
         * Locates bruce data within feature to register it.
         * @param feature
         * @returns
         */
        mapTilesetFeature(feature) {
            var _a, _b, _c;
            let version = (_c = (_b = (_a = feature === null || feature === void 0 ? void 0 : feature.tileset) === null || _a === void 0 ? void 0 : _a.extensions) === null || _b === void 0 ? void 0 : _b.modelTree) === null || _c === void 0 ? void 0 : _c.version;
            if (!version) {
                version = 1;
            }
            let meta;
            if (version == 1) {
                let pathStr = feature.getProperty("BrucePath");
                if (pathStr != undefined) {
                    let path = pathStr.split("|");
                    let entityTypeId = this.getEntityTypeByPath(path);
                    meta = new bruce_meta_8.BruceMeta(path, entityTypeId, this.api.clientAccountId);
                }
            }
            else if (version == 2) {
                let geomId = +feature.getProperty("GeomId");
                if (geomId != null && (!!geomId || geomId == 0)) {
                    meta = this.getMetaByGeomId(geomId, feature.tileset);
                }
            }
            else {
                console.log("Unhandled tileset tree version = " + version);
            }
            let entity = null;
            if (meta) {
                entity = new cesium_bruce_entity_6.CesiumBruceEntity(this.viewer, [feature], meta);
                entity.DoOnEntity((cEntity) => {
                    cEntity.show = true;
                });
                this.loadedCesiumEntities[entity.bruceMeta.EntityID()] = entity;
            }
            return entity ? entity.bruceMeta : null;
        }
        getMetaByGeomId(geomId, tileset) {
            var _a;
            let modelTree = (_a = tileset === null || tileset === void 0 ? void 0 : tileset.extensions) === null || _a === void 0 ? void 0 : _a.modelTree;
            return this.digMetaByGeomId(geomId, modelTree, []);
        }
        digMetaByGeomId(geomId, branch, path) {
            path = [].concat(path);
            path.push(branch.id);
            if (branch.geomId == geomId) {
                return new bruce_meta_8.BruceMeta(path, branch.typeId, this.api.clientAccountId);
            }
            else if (branch.children) {
                for (let i = 0; i < branch.children.length; i++) {
                    let meta = this.digMetaByGeomId(geomId, branch.children[i], path);
                    if (meta) {
                        return meta;
                    }
                }
            }
            return null;
        }
        getEntityTypeByPath(path) {
            var _a, _b;
            let modelTree = (_b = (_a = this.tileset) === null || _a === void 0 ? void 0 : _a.extensions) === null || _b === void 0 ? void 0 : _b.modelTree;
            if (modelTree) {
                let data = this.digModelTreeByPath(modelTree, path);
                if (data) {
                    return data.typeId;
                }
            }
            return null;
        }
        digModelTreeByPath(branch, path) {
            // Dereference.
            path = JSON.parse(JSON.stringify(path));
            if (path.length <= 0) {
                return null;
            }
            let pathTop = path.splice(0, 1)[0];
            if (pathTop != branch.id) {
                return null;
            }
            else if (path.length == 0 && pathTop == branch.id) {
                return branch;
            }
            else if (branch.children) {
                for (let i = 0; i < branch.children.length; i++) {
                    let foundPath = this.digModelTreeByPath(branch.children[i], path);
                    if (foundPath) {
                        return foundPath;
                    }
                }
            }
            return null;
        }
        /**
         * Returns if given meta needs full BruceInfo record to style.
         * @param meta
         * @param feature
         */
        getTilesetFeatureNeedsFullData(meta) {
            var _a;
            let style = this.getTilesetFeatureStyle(meta);
            if (!style) {
                return false;
            }
            let fill = (_a = style === null || style === void 0 ? void 0 : style.modelStyle) === null || _a === void 0 ? void 0 : _a.fillColor;
            if (!fill || fill.length <= 0) {
                return false;
            }
            return fill[0].type != 0;
        }
        /**
         * Returns style applicable to given meta.
         * @param meta
         * @param feature
         */
        getTilesetFeatureStyle(meta) {
            var _a;
            // Locate what style is applicable to the feature.
            let style;
            if (meta.entityTypeId) {
                style = (_a = this.styleMapping.find(x => x.EntityTypeID == meta.entityTypeId)) === null || _a === void 0 ? void 0 : _a.Style;
            }
            if (!style) {
                style = this.fallbackStyle;
            }
            if (!style) {
                return null;
            }
            // Customize must be enabled for us to colour.
            if (!style.modelStyle.customize) {
                return null;
            }
            return style;
        }
        /**
         * Styles given tileset feature without entity data.
         * @param entity
         */
        styleTilesetFeature(entity) {
            this.styleTilesetFeatureFullData(entity, null);
        }
        /**
         * Styles given tileset feature using full entity data.
         * @param entity
         * @param bruceInfo
         */
        styleTilesetFeatureFullData(entity, bruceInfo) {
            let style = this.getTilesetFeatureStyle(entity === null || entity === void 0 ? void 0 : entity.bruceMeta);
            if (!style) {
                return;
            }
            let bColor = this.calculator.getColor(this.calculator.calcValues(bruceInfo === null || bruceInfo === void 0 ? void 0 : bruceInfo.JSON, style.modelStyle.fillColor));
            if (bColor != null) {
                let color = cesium_utils_8.CesiumUtils.ColorToCesiumColor(bColor);
                entity.Colorize(color);
            }
        }
        /**
         * Returns entities for next queue process.
         */
        getEntitiesForQueue() {
            let batchEntityIds = this.recordLoadQueue.splice(0, BATCH_SIZE);
            let entities = [];
            for (let i = 0; i < batchEntityIds.length; i++) {
                let entityId = batchEntityIds[i];
                let entity = this.loadedCesiumEntities[entityId];
                if (entity) {
                    entities.push(entity);
                }
            }
            return entities;
        }
        /**
         * Calls to process current queue of entities to style with full data.
         * If a queue is already in progress then calling will do nothing.
         * Queue will automatically keep calling itself until no mappings are left.
         * @returns
         */
        processQueue() {
            return __awaiter(this, void 0, void 0, function* () {
                if (this.runningQueues >= MAX_BATCHES) {
                    return;
                }
                else if (this.disposed) {
                    return;
                }
                this.runningQueues += 1;
                let batch = [];
                let rerun = false;
                try {
                    batch = this.getEntitiesForQueue();
                    let entityIds = batch.map(x => x.bruceMeta.EntityID());
                    if (entityIds.length > 0) {
                        let entities = yield bruce_info_4.BruceInfo.GetEntitiesByList(this.api, entityIds);
                        for (let i = 0; i < entities.length; i++) {
                            let bruceInfo = entities[i];
                            let feature = batch.find(x => { var _a, _b, _c; return ((_b = (_a = x === null || x === void 0 ? void 0 : x.bruceMeta) === null || _a === void 0 ? void 0 : _a.EntityID) === null || _b === void 0 ? void 0 : _b.call(_a)) == ((_c = bruceInfo === null || bruceInfo === void 0 ? void 0 : bruceInfo.Bruce) === null || _c === void 0 ? void 0 : _c.ID); });
                            if (feature) {
                                this.styleTilesetFeatureFullData(feature, bruceInfo);
                            }
                        }
                        this.viewer.scene.requestRender();
                        rerun = batch.length > 0;
                    }
                }
                finally {
                    setTimeout(() => {
                        this.runningQueues -= 1;
                        if (rerun) {
                            this.processQueue();
                        }
                    }, BATCH_DELAY);
                }
            });
        }
        UpdateEntity(data) {
            var _a;
            const id = (_a = data === null || data === void 0 ? void 0 : data.Bruce) === null || _a === void 0 ? void 0 : _a.ID;
            let entity = this.loadedCesiumEntities[id];
            if (entity) {
                this.styleTilesetFeatureFullData(entity, data);
                this.viewer.scene.requestRender();
            }
        }
    }
    exports.CesiumMenuItemModelTilesetExtended = CesiumMenuItemModelTilesetExtended;
});
define("entry-points/cesium/menu-items/cesium-menu-item-manager", ["require", "exports", "bruce-models/common/entity-filter", "bruce-models/common/sort-order", "bruce-models/menu-item/menu-item-base", "entry-points/cesium/menu-items/cesium-menu-item-bruce-entities-extended", "entry-points/cesium/getters/cesium-entities-getter-pages", "entry-points/cesium/menu-items/cesium-menu-item-arbitrary-tileset-extended", "entry-points/cesium/menu-items/cesium-menu-item-loaded-bruce-entities-extended", "entry-points/common/entity-preloaded-getter", "utils/bruce-event", "entry-points/cesium/menu-items/cesium-menu-item-unknown", "entry-points/cesium/menu-items/cesium-menu-item-model-tileset-extended"], function (require, exports, entity_filter_1, sort_order_3, menu_item_base_7, cesium_menu_item_bruce_entities_extended_1, cesium_entities_getter_pages_1, cesium_menu_item_arbitrary_tileset_extended_1, cesium_menu_item_loaded_bruce_entities_extended_1, entity_preloaded_getter_1, bruce_event_9, cesium_menu_item_unknown_1, cesium_menu_item_model_tileset_extended_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumMenuItemManager = exports.MIN_ZOOM_VERSION = void 0;
    // This is the minimum version of the code to support zoom control.
    exports.MIN_ZOOM_VERSION = 513;
    class CesiumMenuItemManager {
        /**
         * Instantiates manager using given menu items.
         * @param viewer
         * @param viewMonitor
         * @param menuItems
         */
        constructor(api, viewer, viewMonitor, loadManager, visualRegister, menuItems) {
            // The array of menu items this manager is working with.
            this.menuItems = [];
            // Array of all enabled menu items.
            this.enabledItems = [];
            this.api = api;
            this.viewer = viewer;
            this.menuItems = menuItems;
            this.viewMonitor = viewMonitor;
            this.loadManager = loadManager;
            this.visualRegister = visualRegister;
            this.menuItemStateChangedEvent = new bruce_event_9.BruceEvent();
        }
        /**
         * Creates and returns an extended menu item for a given menu item.
         * If a given menu item has already been extended then enabled then the enabled item is returned.
         * If the menu item's type is unsupported then NULL is returned.
         * @param menuItem
         */
        CreateExtendedItem(menuItem) {
            return __awaiter(this, void 0, void 0, function* () {
                let id = menuItem === null || menuItem === void 0 ? void 0 : menuItem.id;
                let item = this.enabledItems.find(x => x.menuItem.id == id);
                if (item) {
                    return item;
                }
                else {
                    switch (menuItem.Type) {
                        case menu_item_base_7.MenuItemType.BruceEntity:
                            var newExtendedBruceItem = new cesium_menu_item_bruce_entities_extended_1.CesiumMenuItemBruceEntitiesExtended(this.api, this.viewer, this.visualRegister, menuItem, this.CreateEntitiesPagesGetter(menuItem));
                            return newExtendedBruceItem;
                        case menu_item_base_7.MenuItemType.SingleEntity:
                            var newExtendedSingleBruceItem = new cesium_menu_item_bruce_entities_extended_1.CesiumMenuItemBruceEntitiesExtended(this.api, this.viewer, this.visualRegister, menuItem, this.CreateEntityGetter(menuItem));
                            return newExtendedSingleBruceItem;
                        case menu_item_base_7.MenuItemType.LoadedBruceEntity:
                            var newLoadedBruceEntityItem = new cesium_menu_item_loaded_bruce_entities_extended_1.CesiumMenuItemLoadedBruceEntitiesExtended(this.api, this.viewer, this.visualRegister, menuItem, this.CreateLoadedEntitiesGetter(menuItem));
                            return newLoadedBruceEntityItem;
                        case menu_item_base_7.MenuItemType.ArbitraryTileset:
                            var newExtendedArbTilesetItem = new cesium_menu_item_arbitrary_tileset_extended_1.CesiumMenuItemArbitraryTilesetExtended(this.api, this.viewer, this.visualRegister, menuItem);
                            return newExtendedArbTilesetItem;
                        case menu_item_base_7.MenuItemType.ModelTileset:
                            var newExtendedModelTilesetItem = new cesium_menu_item_model_tileset_extended_1.CesiumMenuItemModelTilesetExtended(this.api, this.viewer, this.visualRegister, menuItem);
                            return newExtendedModelTilesetItem;
                        default:
                            var newUnknownItem = new cesium_menu_item_unknown_1.CesiumMenuItemUnknown(menuItem);
                            return newUnknownItem;
                    }
                }
            });
        }
        /**
         * Enables a given extended menu item.
         * @param extendedItem
         */
        EnableExtendedMenuItem(extendedItem) {
            var _a, _b;
            return __awaiter(this, void 0, void 0, function* () {
                let id = (_a = extendedItem === null || extendedItem === void 0 ? void 0 : extendedItem.menuItem) === null || _a === void 0 ? void 0 : _a.id;
                let item = this.enabledItems.find(x => x.menuItem.id == id);
                if (item) {
                    // Already enabled.
                    return;
                }
                if (extendedItem) {
                    switch (extendedItem.menuItem.Type) {
                        case menu_item_base_7.MenuItemType.BruceEntity:
                            yield extendedItem.Init();
                            extendedItem.Start();
                            break;
                        case menu_item_base_7.MenuItemType.SingleEntity:
                            yield extendedItem.Init();
                            extendedItem.Start();
                            break;
                        case menu_item_base_7.MenuItemType.LoadedBruceEntity:
                            yield extendedItem.Init();
                            extendedItem.Start();
                            break;
                        case menu_item_base_7.MenuItemType.ArbitraryTileset:
                            yield extendedItem.Init();
                            extendedItem.Start();
                            break;
                        case menu_item_base_7.MenuItemType.ModelTileset:
                            yield extendedItem.Init();
                            extendedItem.Start();
                            break;
                        case menu_item_base_7.MenuItemType.Custom:
                            yield extendedItem.Init();
                            extendedItem.Start();
                            break;
                        default:
                            if (extendedItem.Init) {
                                yield extendedItem.Init();
                            }
                            if (extendedItem.Start) {
                                extendedItem.Start();
                            }
                            break;
                    }
                    if (extendedItem.menuItem) {
                        extendedItem.menuItem.enabled = true;
                    }
                    this.enabledItems.push(extendedItem);
                    this.menuItemStateChangedEvent.Trigger({ menuItemId: (_b = extendedItem.menuItem) === null || _b === void 0 ? void 0 : _b.id, state: true });
                }
            });
        }
        /**
         * Enables a given menu item.
         * @param menuItem
         */
        EnableMenuItem(menuItem) {
            return __awaiter(this, void 0, void 0, function* () {
                let id = menuItem === null || menuItem === void 0 ? void 0 : menuItem.id;
                let item = this.enabledItems.find(x => x.menuItem.id == id);
                if (item) {
                    // Already enabled.
                    return;
                }
                let extendedItem = yield this.CreateExtendedItem(menuItem);
                yield this.EnableExtendedMenuItem(extendedItem);
                return extendedItem;
            });
        }
        /**
         * Disables a given menu item.
         * @param menuItem
         * @deprecated Please use DisableMenuItem().
         */
        disableMenuItem(enabledItem) {
            this.DisableMenuItem(enabledItem);
        }
        /**
         * Disables a given menu item.
         * @param enabledItem
         */
        DisableMenuItem(enabledItem) {
            var _a, _b;
            let id = (_a = enabledItem === null || enabledItem === void 0 ? void 0 : enabledItem.menuItem) === null || _a === void 0 ? void 0 : _a.id;
            let itemIndex = this.enabledItems.findIndex(x => x.menuItem.id == id);
            if (itemIndex > -1) {
                let item = this.enabledItems[itemIndex];
                if (item.menuItem) {
                    item.menuItem.enabled = false;
                }
                item.dispose();
                this.enabledItems.splice(itemIndex, 1);
                this.menuItemStateChangedEvent.Trigger({ menuItemId: (_b = item.menuItem) === null || _b === void 0 ? void 0 : _b.id, state: false });
            }
        }
        /**
         * Disables all enabled menu items.
         */
        DisableAll() {
            var _a;
            let enabledItems = this.enabledItems;
            for (let i = 0; i < enabledItems.length; i++) {
                let item = enabledItems[i];
                if (item.menuItem) {
                    item.menuItem.enabled = false;
                }
                item.dispose();
                this.menuItemStateChangedEvent.Trigger({ menuItemId: (_a = item.menuItem) === null || _a === void 0 ? void 0 : _a.id, state: false });
            }
            this.enabledItems = [];
        }
        /**
         * Returns entities pages getter for a given menu item.
         * @param menuItem
         */
        CreateEntitiesPagesGetter(menuItem) {
            let filter = new entity_filter_1.EntityFilter({
                pageSize: null,
                pageIndex: null,
                entityTypeId: menuItem.entityTypeId,
                layerIds: menuItem.tagIds,
                bounds: null,
                lodCategoryId: menuItem.lodCategoryId,
                orderBy: null,
                sortOrder: sort_order_3.SortOrder.Asc,
                entityTypeConditions: null
            });
            let entitiesGetter = new cesium_entities_getter_pages_1.CesiumEntitiesGetterPages(this.api, this.viewMonitor, this.loadManager, filter);
            return entitiesGetter;
        }
        /**
         * Returns entities pagination getter for a given menu item.
         * @param menuItem
         */
        CreateLoadedEntitiesGetter(menuItem) {
            let getter = new entity_preloaded_getter_1.EntityPreloadedGetter(menuItem.BruceEntity.Entities);
            return getter;
        }
        /**
         * Returns entity getter for a given menu item.
         * @param menuItem
         */
        CreateEntityGetter(menuItem) {
            let filter = new entity_filter_1.EntityFilter({
                pageSize: null,
                pageIndex: null,
                entityTypeId: menuItem.entityTypeId,
                layerIds: [],
                bounds: null,
                lodCategoryId: menuItem.lodCategoryId,
                orderBy: null,
                sortOrder: sort_order_3.SortOrder.Asc,
                entityTypeConditions: { "ID": { "equals": menuItem.BruceEntity.EntityId } }
            });
            let entitiesGetter = new cesium_entities_getter_pages_1.CesiumEntitiesGetterPages(this.api, this.viewMonitor, this.loadManager, filter);
            return entitiesGetter;
        }
        /**
         * Returns menu item corresponding to given id from list of menu items in manager.
         * It will check child items of menu items too.
         * Warning: This does not check enabled items.
         */
        GetMenuItemByID(id) {
            function findItem(menuItemId, items) {
                for (let i = 0; i < items.length; i++) {
                    let item = items[i];
                    if (item.id == menuItemId) {
                        return item;
                    }
                    let children = item.Children;
                    if (children) {
                        let foundItem = findItem(menuItemId, children);
                        if (foundItem) {
                            return foundItem;
                        }
                    }
                }
                return null;
            }
            return findItem(id, this.menuItems);
        }
        /**
         * Returns menu item to enable for a given menu item id.
         * Warning: This does not check enabled items.
         * @param id
         */
        GetMenuItemBranchByID(id) {
            function findItem(menuItemId, items) {
                for (let i = 0; i < items.length; i++) {
                    let item = items[i];
                    if (item.id == menuItemId) {
                        return item;
                    }
                    let children = item.Children;
                    if (children) {
                        let foundItem = findItem(menuItemId, children);
                        if (foundItem) {
                            if (children.length == 1) {
                                return item;
                            }
                            return foundItem;
                        }
                    }
                }
                return null;
            }
            return findItem(id, this.menuItems);
        }
        /**
         * Returns if a menu item is currently enabled by its id.
         * @param id
         */
        GetMenuItemEnabled(id) {
            return !!this.enabledItems.find(x => { var _a; return ((_a = x.menuItem) === null || _a === void 0 ? void 0 : _a.id) == id; });
        }
        /**
         * Populates bookmark settings to represent what menu items are currently enabled.
         * This also populates hidden entities using the visual register.
         *
         * Warning: Project view must contain the menu items.
         * @param projectView
         * @param bookmark
         */
        PopulateBookmarkMenuItems(projectView, bookmark) {
            let items = projectView.Settings.MenuItems;
            let enabledItemIds = [];
            /**
             * Crawls down a menu item and its children to find the last enabled nodes.
             *
             * a
             *  - b
             *  - c
             *    - d
             *      - e
             *    - f
             *
             * If a, b, c, d and e were enabled. It would return e.
             * If f was also enabled then it would return e and f for menu item a.
             *
             * @param manager
             * @param branch
             */
            function crawl(manager, branch) {
                let enabledIds = [];
                let isEnabled = manager.GetMenuItemEnabled(branch.id);
                if (isEnabled) {
                    let children = branch.Children == null ? [] : branch.Children;
                    for (let i = 0; i < children.length; i++) {
                        let child = children[i];
                        enabledIds = enabledIds.concat(crawl(manager, child));
                    }
                    if (enabledIds.length <= 0) {
                        enabledIds.push(branch.id);
                    }
                }
                return enabledIds;
            }
            for (let i = 0; i < items.length; i++) {
                let item = items[i];
                let itemIds = crawl(this, item);
                for (let j = 0; j < itemIds.length; j++) {
                    let id = itemIds[j];
                    if (!enabledItemIds.includes(id)) {
                        enabledItemIds.push(id);
                    }
                }
            }
            let settings = bookmark.Settings;
            settings.selectedItemIds = enabledItemIds;
            // What entities to hide.
            settings.hidden = this.visualRegister.getHidden();
        }
        /**
         * Runs through enabled menu items and updates them using given bruce info.
         * If entity exists in items it will refresh it.
         * @param bruceInfo
         */
        UpdateMenuItemsByInfo(bruceInfo) {
            let enabledItems = this.enabledItems;
            for (let i = 0; i < enabledItems.length; i++) {
                let item = enabledItems[i];
                if (item.UpdateEntity) {
                    item.UpdateEntity(bruceInfo);
                }
            }
        }
    }
    exports.CesiumMenuItemManager = CesiumMenuItemManager;
    // Counter to help differentiate created entity parents.
    CesiumMenuItemManager.counter = 0;
});
define("entry-points/cesium/viewer/cesium-camera-handler", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumCameraHandler = void 0;
    /**
     * Handles provided cesium view camera.
     * Allows for manipulating camera state.
     */
    class CesiumCameraHandler {
        constructor(viewer) {
            // Frozen state.
            this._frozen = false;
            if (!viewer) {
                throw (">>Error: Cannot instantiate camera handler without cesium viewer.");
            }
            this.viewer = viewer;
        }
        // Returns the current frozen state.
        get isFrozen() {
            return this._frozen;
        }
        // Sets frozen state.
        set isFrozen(state) {
            if (state) {
                this.freeze();
            }
            else {
                this.unfreeze();
            }
        }
        /**
         * Stops camera movement events.
         */
        freeze() {
            if (!this.isFrozen) {
                this._frozen = true;
                let scene = this.viewer.scene;
                scene.screenSpaceCameraController.enableRotate = false;
                scene.screenSpaceCameraController.enableTranslate = false;
                scene.screenSpaceCameraController.enableTilt = false;
                scene.screenSpaceCameraController.enableLook = false;
                scene.screenSpaceCameraController.enableRotate = false;
            }
        }
        /**
         * Enables camera movement events.
         */
        unfreeze() {
            if (this.isFrozen) {
                this._frozen = false;
                let scene = this.viewer.scene;
                scene.screenSpaceCameraController.enableRotate = true;
                scene.screenSpaceCameraController.enableTranslate = true;
                scene.screenSpaceCameraController.enableTilt = true;
                scene.screenSpaceCameraController.enableLook = true;
                scene.screenSpaceCameraController.enableRotate = true;
            }
        }
    }
    exports.CesiumCameraHandler = CesiumCameraHandler;
});
define("entry-points/cesium/common/cesium-bruce-imagery-provider", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_43) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumBruceImageryLayer = void 0;
    class CesiumBruceImageryLayer {
        constructor(layer, name, id, clientAccountId) {
            this.cesiumLayer = layer;
            this.name = name;
            if (!id) {
                id = object_utils_43.ObjectUtils.UID();
            }
            this._id = id;
            this.clientAccountId = clientAccountId;
        }
        get id() {
            return this._id;
        }
        /**
         * Returns cesium bruce imagery provider associated with given cesium imagery provider.
         * @param imageryLayer
         * @returns
         */
        static FromCesiumImageryLayer(imageryLayer) {
            if (imageryLayer._cesiumBruceImageryLayer) {
                return imageryLayer._cesiumBruceImageryLayer;
            }
            else {
                let provider = new CesiumBruceImageryLayer(imageryLayer, null);
                imageryLayer._cesiumBruceImageryLayer = provider;
                return provider;
            }
        }
        /**
         * Returns cesium bruce imagery providers associated with given cesium imagery providers.
         * @param imageryLayers
         */
        static FromCesiumImageryLayers(imageryLayers) {
            let providers = [];
            for (let i = 0; i < imageryLayers.length; i++) {
                let provider = CesiumBruceImageryLayer.FromCesiumImageryLayer(imageryLayers[i]);
                providers.push(provider);
            }
            return providers;
        }
    }
    exports.CesiumBruceImageryLayer = CesiumBruceImageryLayer;
});
define("entry-points/cesium/common/cesium-imagery-handler", ["require", "exports", "entry-points/cesium/common/cesium-bruce-imagery-provider"], function (require, exports, cesium_bruce_imagery_provider_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumImageryHandler = void 0;
    /**
     * Utility to help with managing imagery layers for a cesium layer collection.
     */
    class CesiumImageryHandler {
        constructor(imageryLayers) {
            this.layers = {};
            if (imageryLayers) {
                this.collection = imageryLayers;
                this.Refresh();
            }
        }
        /**
         * Replaces the collection referenece the handler is made around.
         * This will clear given collection and apply enabled imageries from previous collection to the new one.
         * @param collection
         */
        SetCollection(collection) {
            let enabled = this.GetEnabledLayers();
            this.collection = collection;
            collection.removeAll(false);
            for (let i = 0; i < enabled.length; i++) {
                let layer = enabled[i];
                this.Enable(layer.id);
            }
        }
        /**
         * Adds new imagery layer to the handler (This will not automatically enable the layer).
         * Returns imagery layer reference id.
         */
        AddCesiumLayer(layer) {
            let extended = cesium_bruce_imagery_provider_1.CesiumBruceImageryLayer.FromCesiumImageryLayer(layer);
            this.layers[extended.id] = extended;
            return extended.id;
        }
        /**
         * Adds new imagery layer to the handler.
         * If layer with same id exists. Data is overriden.
         */
        AddLayer(layer) {
            this.layers[layer.id] = layer;
        }
        /**
         * Removes layer from handler.
         * This will also disable it.
         * @param layerId
         */
        RemoveLayerById(layerId) {
            const layer = this.GetLayerById(layerId);
            if (!layer) {
                throw ("Layer with specified id is not registered in the handler.");
            }
            delete this.layers[layerId];
            if (this.collection.contains(layer.cesiumLayer)) {
                this.collection.remove(layer.cesiumLayer, false);
            }
        }
        /**
         * @param layer
         * @returns if a given layer is currently enabled.
         */
        GetIsLayerEnabled(layer) {
            return this.collection.contains(layer.cesiumLayer);
        }
        /**
         * @param layerId
         * @returns if a given layer is currently enabled.
         */
        GetIsLayerEnabledById(layerId) {
            let layer = this.GetLayerById(layerId);
            return this.collection.contains(layer.cesiumLayer);
        }
        /**
         * Returns all currently enabled imagery layers.
         */
        GetEnabledLayers() {
            let layers = [];
            for (let i = 0; i < this.collection.length; i++) {
                let item = this.collection.get(i);
                let layer = cesium_bruce_imagery_provider_1.CesiumBruceImageryLayer.FromCesiumImageryLayer(item);
                layers.push(layer);
            }
            return layers;
        }
        /**
         * Returns all currently disabled imagery layers.
         */
        GetDisabledLayers() {
            let keys = Object.keys(this.layers);
            let layers = [];
            for (let i = 0; i < keys.length; i++) {
                let layer = this.layers[keys[i]];
                if (!this.GetIsLayerEnabled(layer)) {
                    layers.push(layer);
                }
            }
            return layers;
        }
        /**
         * Returns all registered imagery layers.
         * @returns
         */
        GetRegisteredLayers() {
            let keys = Object.keys(this.layers);
            let layers = [];
            for (let i = 0; i < keys.length; i++) {
                let layer = this.layers[keys[i]];
                layers.push(layer);
            }
            return layers;
        }
        /**
         * Adds all enabled layers in Cesium collection to the handler.
         */
        UpdateUsingCesiumEnabled() {
            let layers = this.GetEnabledLayers();
            for (let i = 0; i < layers.length; i++) {
                let layer = layers[i];
                this.layers[layer.id] = layer;
            }
        }
        /**
         * Clears all registered layers and runs an update using Cesium collection.
         */
        Refresh() {
            this.layers = {};
            this.UpdateUsingCesiumEnabled();
        }
        /**
         * Returns registered layer by given layer id.
         * @param layerId
         * @returns
         */
        GetLayerById(layerId) {
            return this.layers[layerId];
        }
        /**
         * Returns a layer's index.
         * -1 means layer is not enabled.
         * @param layerId
         * @returns
         */
        GetLayerIndex(layerId) {
            let layer = this.GetLayerById(layerId);
            if (this.GetIsLayerEnabled(layer)) {
                return this.collection.indexOf(layer.cesiumLayer);
            }
            return -1;
        }
        /**
         * Sets the index for a given layer.
         * If layer was disabled and index set is not -1 then layer is set to be enabled.
         * If layer was enabled and index set is -1 the layer is set to be disabled.
         * @param layerId
         * @param index
         */
        SetLayerIndex(layerId, index) {
            let layer = this.GetLayerById(layerId);
            if (!layer) {
                throw ("Layer with specified id is not registered in the handler.");
            }
            let enabled = this.GetIsLayerEnabled(layer);
            // Enable it.
            if (index != -1 && !enabled) {
                this.collection.add(layer.cesiumLayer, index);
            }
            // Disable it.
            else if (index == -1 && enabled) {
                this.collection.remove(layer.cesiumLayer, false);
            }
            // Update index.
            else {
                this.collection.remove(layer.cesiumLayer, false);
                this.collection.add(layer.cesiumLayer, index);
            }
        }
        /**
         * Enables layer associated with given layer id.
         * @param layerId
         */
        Enable(layerId) {
            let layer = this.GetLayerById(layerId);
            if (!layer) {
                throw ("Layer with specified id is not registered in the handler.");
            }
            if (!this.collection.contains(layer.cesiumLayer)) {
                this.collection.add(layer.cesiumLayer);
            }
        }
        /**
         * Disables layer associated with given layer id.
         * @param layerId
         */
        Disable(layerId) {
            let layer = this.GetLayerById(layerId);
            if (!layer) {
                throw ("Layer with specified id is not registered in the handler.");
            }
            if (this.collection.contains(layer.cesiumLayer)) {
                this.collection.remove(layer.cesiumLayer, false);
            }
        }
        /**
         * Moves layer associated with given id to the top.
         * If layer is disabled it will enable it.
         * @param layerId
         */
        MoveLayerToTop(layerId) {
            let layer = this.GetLayerById(layerId);
            if (!layer) {
                throw ("Layer with specified id is not registered in the handler.");
            }
            let enabled = this.GetIsLayerEnabled(layer);
            if (enabled) {
                this.collection.remove(layer.cesiumLayer, false);
            }
            else {
                this.collection.add(layer.cesiumLayer);
            }
            this.collection.raiseToTop(layer.cesiumLayer);
        }
        /**
         * Moves layer associated with given id to the bottom.
         * If layer is disabled it will enable it.
         * @param layerId
         */
        MoveLayerToBottom(layerId) {
            let layer = this.GetLayerById(layerId);
            if (!layer) {
                throw ("Layer with specified id is not registered in the handler.");
            }
            let enabled = this.GetIsLayerEnabled(layer);
            if (enabled) {
                this.collection.remove(layer.cesiumLayer, false);
            }
            else {
                this.collection.add(layer.cesiumLayer);
            }
            this.collection.lowerToBottom(layer.cesiumLayer);
        }
        /**
         * Clears all imageries registered in the handler.
         * Imageries cleared are disabled.
         */
        Clear() {
            let all = this.GetRegisteredLayers();
            for (let i = 0; i < all.length; i++) {
                let layer = all[i].cesiumLayer;
                if (this.collection.contains(layer)) {
                    this.collection.remove(layer, false);
                }
            }
            this.layers = {};
        }
        /**
         * Disables all registered and enabled layers.
         */
        DisableAll() {
            let all = this.GetRegisteredLayers();
            for (let i = 0; i < all.length; i++) {
                let layer = all[i].cesiumLayer;
                if (this.collection.contains(layer)) {
                    this.collection.remove(layer, false);
                }
            }
        }
        /**
         * Enables all registered layers.
         */
        EnableAll() {
            let all = this.GetRegisteredLayers();
            for (let i = 0; i < all.length; i++) {
                let layer = all[i].cesiumLayer;
                if (!this.collection.contains(layer)) {
                    this.collection.add(layer);
                }
            }
        }
        /**
         * Performs callback on all registered layers.
         * @param callback
         */
        DoOnLayer(callback) {
            let layers = this.GetRegisteredLayers();
            for (let i = 0; i < layers.length; i++) {
                let layer = layers[i];
                callback(layer);
            }
        }
        /**
         * Performs callback on all registered layers.
         * @param callback
         */
        DoOnLayerAsync(callback) {
            return __awaiter(this, void 0, void 0, function* () {
                let layers = this.GetRegisteredLayers();
                for (let i = 0; i < layers.length; i++) {
                    let layer = layers[i];
                    yield callback(layer);
                }
            });
        }
    }
    exports.CesiumImageryHandler = CesiumImageryHandler;
});
define("entry-points/cesium/common/cesium-shadow-handler", ["require", "exports", "bruce-models/project-view/project-view-settings-shadows"], function (require, exports, project_view_settings_shadows_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumShadowHandler = exports.ECesiumShadowHandlerState = void 0;
    var ECesiumShadowHandlerState;
    (function (ECesiumShadowHandlerState) {
        ECesiumShadowHandlerState[ECesiumShadowHandlerState["Moving"] = 0] = "Moving";
        ECesiumShadowHandlerState[ECesiumShadowHandlerState["Static"] = 1] = "Static";
        ECesiumShadowHandlerState[ECesiumShadowHandlerState["Disabled"] = 2] = "Disabled";
    })(ECesiumShadowHandlerState = exports.ECesiumShadowHandlerState || (exports.ECesiumShadowHandlerState = {}));
    /**
     * Applies settings to Cesium viewer.
     * To manually update state call 'Update'.
     * Alternatively call 'EnableEventListening' to detect camera movements automatically and apply states for you.
     *
     * Warning: The tool starts disabled by default. Update state once before enabling events.
     */
    class CesiumShadowHandler {
        constructor(viewer, settings, state = ECesiumShadowHandlerState.Disabled) {
            this._state = ECesiumShadowHandlerState.Disabled;
            // Millisecond delay for swapping to static shadows after move stop event.
            this.stateSwapDelay = 1000;
            this.viewer = viewer;
            if (settings === null || settings === void 0 ? void 0 : settings.Shadow) {
                this.settings = settings.Shadow.Clone();
            }
            else {
                this.settings = new project_view_settings_shadows_2.ProjectViewSettingsShadows(null);
            }
            this.Update(state);
        }
        get state() {
            return this._state;
        }
        get disabled() {
            return this._state == ECesiumShadowHandlerState.Disabled;
        }
        /**
         * Applies project view settings to Cesium viewer shadows.
         * @param settings
         */
        ApplyViewSettings(settings) {
            if (settings.Shadow) {
                this.settings = settings.Shadow.Clone();
                let state = this.state == ECesiumShadowHandlerState.Moving ? ECesiumShadowHandlerState.Static : this.state;
                this.Update(state);
            }
        }
        /**
         * Updates state and applies settings to Cesium Viewer to match it.
         * @param state
         */
        Update(state) {
            switch (state) {
                case ECesiumShadowHandlerState.Disabled:
                    clearTimeout(this.stateSwapTimeout);
                    this.disableShadows();
                    break;
                case ECesiumShadowHandlerState.Moving:
                    this.enableSettings(this.settings.MovingCamera);
                    break;
                case ECesiumShadowHandlerState.Static:
                    this.enableSettings(this.settings.StaticCamera);
                    break;
            }
        }
        enableSettings(settings) {
            let viewer = this.viewer;
            viewer.shadows = settings.IsShadowEnabled;
            if (settings.IsShadowEnabled) {
                viewer.shadowMap.enabled = settings.IsShadowEnabled;
                viewer.shadows = settings.IsShadowEnabled;
                viewer.shadowMap.softShadows = settings.IsShadowSoft;
                viewer.shadowMap.size = settings.ShadowSampleSize;
                this.viewer.scene.requestRender();
            }
        }
        disableShadows() {
            let viewer = this.viewer;
            if (viewer.shadows || viewer.shadowMap) {
                viewer.shadows = false;
                viewer.shadowMap.enabled = false;
                this.viewer.scene.requestRender();
            }
        }
        /**
         * Starts listening for Cesium camera movements to automatically apply states.
         * Warning: If in disabled state, movements are ignored.
         */
        EnableEventListening() {
            if (!this.moveStartEventCallback) {
                this.moveStartEventCallback = this.viewer.camera.moveStart.addEventListener(() => {
                    if (!this.disabled) {
                        clearTimeout(this.stateSwapTimeout);
                        this.Update(ECesiumShadowHandlerState.Moving);
                    }
                });
            }
            if (!this.moveStopEventCallback) {
                this.moveStopEventCallback = this.viewer.camera.moveEnd.addEventListener(() => {
                    if (!this.disabled) {
                        clearTimeout(this.stateSwapTimeout);
                        this.stateSwapTimeout = setTimeout(() => {
                            this.Update(ECesiumShadowHandlerState.Static);
                        }, this.stateSwapDelay);
                    }
                });
            }
        }
        /**
         * Stops listening for camera movements.
         */
        DisableEventListening() {
            var _a, _b;
            clearTimeout(this.stateSwapTimeout);
            (_a = this.moveStartEventCallback) === null || _a === void 0 ? void 0 : _a.call(this);
            this.moveStartEventCallback = null;
            (_b = this.moveStopEventCallback) === null || _b === void 0 ? void 0 : _b.call(this);
            this.moveStopEventCallback = null;
        }
    }
    exports.CesiumShadowHandler = CesiumShadowHandler;
});
define("entry-points/cesium/common/cesium-ambient-occlusion-handler", ["require", "exports", "bruce-models/project-view/project-view-settings-ambient-occlusion"], function (require, exports, project_view_settings_ambient_occlusion_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumAmbientOcclusionHandler = exports.ECesiumAmbientOcclusionHandlerState = void 0;
    var ECesiumAmbientOcclusionHandlerState;
    (function (ECesiumAmbientOcclusionHandlerState) {
        ECesiumAmbientOcclusionHandlerState[ECesiumAmbientOcclusionHandlerState["Enabled"] = 0] = "Enabled";
        ECesiumAmbientOcclusionHandlerState[ECesiumAmbientOcclusionHandlerState["Disabled"] = 1] = "Disabled";
    })(ECesiumAmbientOcclusionHandlerState = exports.ECesiumAmbientOcclusionHandlerState || (exports.ECesiumAmbientOcclusionHandlerState = {}));
    class CesiumAmbientOcclusionHandler {
        constructor(viewer, settings, state = ECesiumAmbientOcclusionHandlerState.Disabled) {
            this._state = ECesiumAmbientOcclusionHandlerState.Disabled;
            this.viewer = viewer;
            if (settings === null || settings === void 0 ? void 0 : settings.OASettings) {
                this.settings = settings.OASettings.Clone();
            }
            else {
                this.settings = new project_view_settings_ambient_occlusion_2.ProjectViewSettingsAmbientOcclusion(null);
            }
            this.Update(state);
        }
        get state() {
            return this._state;
        }
        get disabled() {
            return this._state == ECesiumAmbientOcclusionHandlerState.Disabled;
        }
        /**
         * Applies project view settings to Cesium viewer ambient occlusion.
         * @param settings
         */
        ApplyViewSettings(settings) {
            if (settings.OASettings) {
                this.settings = settings.OASettings.Clone();
                this.Update(this.state);
            }
        }
        /**
         * Updates state and applies settings to Cesium Viewer to match it.
         * @param state
         */
        Update(state) {
            switch (state) {
                case ECesiumAmbientOcclusionHandlerState.Disabled:
                    this.disableAO();
                    break;
                case ECesiumAmbientOcclusionHandlerState.Enabled:
                    this.enableSettings(this.settings);
                    break;
            }
        }
        enableSettings(settings) {
            let viewer = this.viewer;
            let ao = viewer.scene.postProcessStages.ambientOcclusion;
            if (settings.Enabled) {
                ao.enabled = true;
                ao.uniforms.ambientOcclusionOnly = false;
                ao.uniforms.intensity = settings.Intensity;
                ao.uniforms.lengthCap = settings.LengthCap;
                ao.uniforms.stepSize = settings.StepSize;
                ao.uniforms.bias = settings.Bias;
                ao.uniforms.blurStepSize = settings.BlurStep;
                this.viewer.scene.requestRender();
            }
            else {
                this.disableAO();
            }
        }
        disableAO() {
            let viewer = this.viewer;
            if (viewer) {
                let ao = viewer.scene.postProcessStages.ambientOcclusion;
                if (ao) {
                    ao.enabled = false;
                    this.viewer.scene.requestRender();
                }
            }
        }
    }
    exports.CesiumAmbientOcclusionHandler = CesiumAmbientOcclusionHandler;
});
define("entry-points/cesium/common/cesium-bruce-terrain-provider", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_44) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumBruceTerrainProvider = void 0;
    class CesiumBruceTerrainProvider {
        constructor(provider, name, id, clientAccountId) {
            this.cesiumProvider = provider;
            this.name = name;
            if (!id) {
                id = object_utils_44.ObjectUtils.UID();
            }
            this._id = id;
            this.clientAccountId = clientAccountId;
        }
        get id() {
            return this._id;
        }
        /**
         * Returns cesium bruce terrain provider associated with given cesium terrain provider.
         * @param imageryLayer
         * @returns
         */
        static FromCesiumTerrainProvider(terrainProvider) {
            if (terrainProvider._cesiumBruceTerrain) {
                return terrainProvider._cesiumBruceTerrain;
            }
            else {
                let provider = new CesiumBruceTerrainProvider(terrainProvider, null);
                terrainProvider._cesiumBruceTerrain = provider;
                return provider;
            }
        }
        /**
         * Returns cesium bruce terrain providers associated with given cesium terrain providers.
         * @param imageryLayers
         */
        static FromCesiumTerrainProviders(terrainProviders) {
            let providers = [];
            for (let i = 0; i < terrainProviders.length; i++) {
                let provider = CesiumBruceTerrainProvider.FromCesiumTerrainProvider(terrainProviders[i]);
                providers.push(provider);
            }
            return providers;
        }
    }
    exports.CesiumBruceTerrainProvider = CesiumBruceTerrainProvider;
});
define("entry-points/cesium/common/cesium-terrain-handler", ["require", "exports", "entry-points/cesium/common/cesium-bruce-terrain-provider"], function (require, exports, cesium_bruce_terrain_provider_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumTerrainHandler = void 0;
    class CesiumTerrainHandler {
        constructor(viewer) {
            this.providers = {};
            if (!viewer) {
                throw (">>Error: Cannot instantiate terrain handler without Cesium viewer.");
            }
            this.viewer = viewer;
        }
        /**
         * Adds new terrain provider to the handler (This will not automatically enable the provider).
         * Returns provider reference id.
         */
        AddCesiumProvider(provider) {
            let extended = cesium_bruce_terrain_provider_1.CesiumBruceTerrainProvider.FromCesiumTerrainProvider(provider);
            this.providers[extended.id] = extended;
            return extended.id;
        }
        /**
         * Adds new terrain provider to the handler.
         * If provider with same id exists. Data is overriden.
         */
        AddProvider(provider) {
            this.providers[provider.id] = provider;
        }
        /**
         * Removes provider from handler.
         * Cannot remove provider that is currently enabled.
         * @param providerId
         */
        RemoveProviderById(providerId) {
            let provider = this.GetProviderById(providerId);
            if (!provider) {
                throw ("Terrain provider with specified id is not registered in the handler.");
            }
            if (this.GetIsProviderEnabledById(providerId)) {
                throw ("Cannot remove terrain provider that is currently enabled.");
            }
            delete this.providers[providerId];
        }
        /**
         * @param provider
         * @returns if a given provider is currently enabled.
         */
        GetIsProviderEnabled(provider) {
            let enabled = this.GetEnabledProvider();
            return (enabled === null || enabled === void 0 ? void 0 : enabled.id) == (provider === null || provider === void 0 ? void 0 : provider.id);
        }
        /**
         * @param providerId
         * @returns if a given provider is currently enabled.
         */
        GetIsProviderEnabledById(providerId) {
            let enabled = this.GetEnabledProvider();
            return providerId == (enabled === null || enabled === void 0 ? void 0 : enabled.id);
        }
        /**
         * Returns currently enabled terrain provider.
         */
        GetEnabledProvider() {
            let provider = this.viewer.terrainProvider;
            if (provider) {
                return cesium_bruce_terrain_provider_1.CesiumBruceTerrainProvider.FromCesiumTerrainProvider(provider);
            }
            return null;
        }
        /**
         * Returns all currently disabled terrain providers.
         */
        GetDisabledProviders() {
            let keys = Object.keys(this.providers);
            let providers = [];
            for (let i = 0; i < keys.length; i++) {
                let provider = this.providers[keys[i]];
                if (!this.GetIsProviderEnabled(provider)) {
                    providers.push(provider);
                }
            }
            return providers;
        }
        /**
         * Returns all registered terrain providers.
         * @returns
         */
        GetRegisteredProviders() {
            let keys = Object.keys(this.providers);
            let providers = [];
            for (let i = 0; i < keys.length; i++) {
                let provider = this.providers[keys[i]];
                providers.push(provider);
            }
            return providers;
        }
        /**
         * Adds enabled Cesium provider to the handler.
         */
        UpdateUsingCesiumEnabled() {
            let provider = this.GetEnabledProvider();
            if (provider) {
                this.providers[provider.id] = provider;
            }
        }
        /**
         * Clears all registered providers and runs an update using Cesium enabled provider.
         */
        Refresh() {
            this.providers = {};
            this.UpdateUsingCesiumEnabled();
        }
        /**
         * Returns registered provider by given provider id.
         * @param providerId
         */
        GetProviderById(providerId) {
            return this.providers[providerId];
        }
        /**
         * Enables provider associated with given provider id.
         * @param providerId
         */
        Enable(providerId) {
            let provider = this.GetProviderById(providerId);
            if (!provider) {
                throw ("Terrain provider with specified id is not registered in the handler.");
            }
            this.viewer.terrainProvider = provider.cesiumProvider;
        }
        /**
         * Performs callback on all registered providers.
         * @param callback
         */
        DoOnProvider(callback) {
            let providers = this.GetRegisteredProviders();
            for (let i = 0; i < providers.length; i++) {
                let provider = providers[i];
                callback(provider);
            }
        }
        /**
         * Performs callback on all registered providers.
         * @param callback
         */
        DoOnProviderAsync(callback) {
            return __awaiter(this, void 0, void 0, function* () {
                let providers = this.GetRegisteredProviders();
                for (let i = 0; i < providers.length; i++) {
                    let provider = providers[i];
                    yield callback(provider);
                }
            });
        }
    }
    exports.CesiumTerrainHandler = CesiumTerrainHandler;
});
define("utils/console-utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleUtils = exports.EConsoleColor = void 0;
    var EConsoleColor;
    (function (EConsoleColor) {
        EConsoleColor["Red"] = "#c93836";
        EConsoleColor["Green"] = "#62c936";
        EConsoleColor["Blue"] = "#368cc9";
        EConsoleColor["Pink"] = "#c93671";
        EConsoleColor["Yellow"] = "#e8ef23";
        EConsoleColor["Orange"] = "#f7733b";
        EConsoleColor["Black"] = "#0f0f0f";
    })(EConsoleColor = exports.EConsoleColor || (exports.EConsoleColor = {}));
    class ConsoleUtils {
        static Log(text, color) {
            console.log(`%c${text}`, `color: ${color};`);
        }
        static LogObj(text, obj, color) {
            console.log(`%c${text}`, `color: ${color};`, obj);
        }
        static Error(text) {
            console.log(`%c>>Error: ${text}`, `color: ${EConsoleColor.Red};`);
        }
        static ErrorObj(text, obj) {
            console.log(`%c>>Error: ${text}`, `color: ${EConsoleColor.Red};`, obj);
        }
    }
    exports.ConsoleUtils = ConsoleUtils;
});
define("utils/console-stack", ["require", "exports", "utils/console-utils", "utils/limited-cache-control", "utils/storage-utils"], function (require, exports, console_utils_1, limited_cache_control_2, storage_utils_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConsoleStack = void 0;
    /**
     * Utility for logging information without printing it until requested.
     */
    class ConsoleStack {
        /**
         * Warning: To create or get instance use "getInstance". Don't create your own instances.
         * @param stackId
         */
        constructor(stackId) {
            this.stackId = stackId;
            this.data = new limited_cache_control_2.LimitedCacheControl(storage_utils_2.EStorageUnit.MB * 300, storage_utils_2.EStorageUnit.B * 300);
        }
        /**
         *
         * @param stackId
         * @returns: existing or new instance corresponding to given stack id.
         */
        static getInstance(stackId) {
            let instance = ConsoleStack.instances[stackId];
            if (instance) {
                return instance;
            }
            instance = ConsoleStack.instances[stackId] = new ConsoleStack(stackId);
            return instance;
        }
        /**
         * Returns total amount of logs recorded.
         */
        get logCount() {
            return this.data.getKeys().length;
        }
        /**
         * Disposes stack.
         */
        Dispose() {
            ConsoleStack.instances[this.stackId] = null;
            delete ConsoleStack.instances[this.stackId];
        }
        Log(text, color = console_utils_1.EConsoleColor.Black) {
            this.recordLog({
                color: color,
                text: text
            });
        }
        LogObj(text, obj, color = console_utils_1.EConsoleColor.Black) {
            this.recordLog({
                color: color,
                text: text,
                object: obj
            });
        }
        Error(text) {
            this.recordLog({
                color: console_utils_1.EConsoleColor.Red,
                text: text
            });
        }
        ErrorObj(text, obj) {
            this.recordLog({
                color: console_utils_1.EConsoleColor.Red,
                text: text,
                object: obj
            });
        }
        Warning(text) {
            this.recordLog({
                color: console_utils_1.EConsoleColor.Orange,
                text: text
            });
        }
        WarningObj(text, obj) {
            this.recordLog({
                color: console_utils_1.EConsoleColor.Orange,
                text: text,
                object: obj
            });
        }
        recordLog(log) {
            log.timestamp = Date.now();
            this.data.Set(this.data.getKeys().length + "", log);
        }
        PrintByIndex(index) {
            let log = this.data.Get(index + "");
            this.printLog(log);
        }
        /**
         * @param startingIndex: inclusive starting point.
         * @param amount: amount inclusive of the starting point.
         */
        PrintGroup(startingIndex, amount) {
            for (let i = 0; i < amount; i++) {
                this.PrintByIndex(startingIndex + i);
            }
        }
        PrintAll() {
            let keys = this.data.getKeys();
            for (let i = 0; i < keys.length; i++) {
                let log = this.data.Get(keys[i]);
                this.printLog(log);
            }
        }
        printLog(log) {
            if (log) {
                let tmp = log.text;
                let date = new Date(log.timestamp);
                tmp = date.toLocaleString() + " | " + tmp;
                if (log.object) {
                    console_utils_1.ConsoleUtils.LogObj(tmp, log.object, log.color);
                }
                else {
                    console_utils_1.ConsoleUtils.Log(tmp, log.color);
                }
            }
        }
    }
    exports.ConsoleStack = ConsoleStack;
    ConsoleStack.instances = {};
});
define("entry-points/cesium/bruce-cesium", ["require", "exports", "cesium", "api/bruce-api", "api/session-api", "bruce-models/menu-item/menu-item-base", "bruce-models/menu-item/menu-item-bruce-entities", "bruce-models/menu-item/menu-item-single-entity", "bruce-models/project-view/project-view", "bruce-models/project-view/project-view-settings", "bruce-models/session/idm-session", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/viewer/cesium-view-monitor", "entry-points/cesium/viewer/cesium-load-manager", "entry-points/cesium/menu-items/cesium-menu-item-manager", "entry-points/cesium/menu-items/cesium-visual-register", "utils/object-utils", "entry-points/cesium/visuals/cesium-bruce-entity", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-entity-utils", "entry-points/cesium/common/cesium-measure-handler", "entry-points/cesium/common/cesium-tileset-utils", "entry-points/cesium/common/cesium-utils", "entry-points/cesium/getters/cesium-entities-getter-pages", "entry-points/cesium/menu-items/cesium-menu-item-arbitrary-tileset-extended", "entry-points/cesium/menu-items/cesium-menu-item-bruce-entities-extended", "entry-points/cesium/visuals/cesium-generator-geometry", "entry-points/cesium/visuals/cesium-generator-model", "entry-points/cesium/visuals/cesium-generator-tileset", "entry-points/cesium/viewer/cesium-camera-handler", "bruce-models/menu-item/menu-item-loaded-entities", "bruce-models/common/camera-zoom-control", "entry-points/cesium/common/cesium-imagery-handler", "entry-points/cesium/common/cesium-shadow-handler", "entry-points/cesium/common/cesium-ambient-occlusion-handler", "entry-points/cesium/common/cesium-terrain-handler", "utils/console-utils", "utils/console-stack", "bruce-models/common/camera-frustum", "entry-points/common/bruce-meta", "entry-points/cesium/common/cesium-bruce-terrain-provider", "bruce-models/menu-item/menu-item-model-tileset"], function (require, exports, Cesium, bruce_api_2, session_api_1, menu_item_base_8, menu_item_bruce_entities_2, menu_item_single_entity_2, project_view_2, project_view_settings_2, idm_session_3, cesium_mouse_events_1, cesium_view_monitor_1, cesium_load_manager_1, cesium_menu_item_manager_5, cesium_visual_register_5, object_utils_45, cesium_bruce_entity_7, cesium_drawing_utils_3, cesium_entity_utils_6, cesium_measure_handler_2, cesium_tileset_utils_2, cesium_utils_9, cesium_entities_getter_pages_2, cesium_menu_item_arbitrary_tileset_extended_2, cesium_menu_item_bruce_entities_extended_2, cesium_generator_geometry_3, cesium_generator_model_3, cesium_generator_tileset_2, cesium_camera_handler_1, menu_item_loaded_entities_1, camera_zoom_control_6, cesium_imagery_handler_1, cesium_shadow_handler_1, cesium_ambient_occlusion_handler_1, cesium_terrain_handler_1, console_utils_2, console_stack_1, camera_frustum_1, bruce_meta_9, cesium_bruce_terrain_provider_2, menu_item_model_tileset_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceCesium = void 0;
    Cesium = __importStar(Cesium);
    var BruceCesium;
    (function (BruceCesium) {
        /**
         * Exports for all the cesium related classes.
         * (Currently not used in new classes. Deprecated?)
         */
        BruceCesium.DrawingUtils = cesium_drawing_utils_3.CesiumDrawingUtils;
        BruceCesium.EntityUtils = cesium_entity_utils_6.CesiumEntityUtils;
        BruceCesium.MeasureHandler = cesium_measure_handler_2.CesiumMeasureHandler;
        BruceCesium.MouseEvents = cesium_mouse_events_1.CesiumMouseEvents;
        BruceCesium.TilesetUtils = cesium_tileset_utils_2.CesiumTilesetUtils;
        BruceCesium.Utils = cesium_utils_9.CesiumUtils;
        BruceCesium.EntitiesGetterPages = cesium_entities_getter_pages_2.CesiumEntitiesGetterPages;
        BruceCesium.MenuItemArbitraryTilesetExtended = cesium_menu_item_arbitrary_tileset_extended_2.CesiumMenuItemArbitraryTilesetExtended;
        BruceCesium.MenuItemBruceEntitiesExtended = cesium_menu_item_bruce_entities_extended_2.CesiumMenuItemBruceEntitiesExtended;
        BruceCesium.VisualRegister = cesium_visual_register_5.CesiumVisualRegister;
        BruceCesium.ViewMonitor = cesium_view_monitor_1.CesiumViewMonitor;
        BruceCesium.BruceEntity = cesium_bruce_entity_7.CesiumBruceEntity;
        BruceCesium.GeneratorGeometry = cesium_generator_geometry_3.CesiumGeneratorGeometry;
        BruceCesium.GeneratorModel = cesium_generator_model_3.CesiumGeneratorModel;
        BruceCesium.GeneratorTileset = cesium_generator_tileset_2.CesiumGeneratorTileset;
        class Viewer {
            constructor() {
                // Unique id for this viewer.
                this.id = object_utils_45.ObjectUtils.UID();
                // If initialize has been called successfully for this viewer.
                this._initialized = false;
            }
            /**
             * @returns: if the viewer has been successfully initialized.
             */
            get hasInitialized() {
                return this._initialized;
            }
            /**
             * Returns the container the cesium viewer is in.
             */
            get Container() {
                return this._container;
            }
            /**
             * Returns the cesium viewer.
             */
            get CesiumViewer() {
                return this._viewer;
            }
            /**
             * Returns console stack corresponding to this viewer instance.
             */
            get ConsoleStack() {
                return console_stack_1.ConsoleStack.getInstance(this.id);
            }
            // Returns the currently set client account.
            get clientAccount() {
                return this._clientAccount;
            }
            // Sets client account if hasn't been set yet.
            set clientAccount(value) {
                if (this._clientAccount != null) {
                    throw ("Cannot change already set client account. Please create new instance of BruceMaps.");
                }
                this._clientAccount = value;
            }
            // Returns the currently set client account.
            get environment() {
                return this._environment;
            }
            // Sets environment if hasn't been set yet.
            set environment(value) {
                if (this._environment != null) {
                    throw ("Cannot change already set environment. Please create new instance of BruceMaps.");
                }
                this._environment = value;
            }
            get enabledBookmarkId() {
                return this._enabledBookmarkId;
            }
            /**
             * Initializes BruceMaps widget for a given HTML container.
             * @param container
             * @param clientAccount
             * @param environment
             * @param viewer
             * @deprecated: Please use Init or InitUsingCesiumViewer methods instead.
             */
            Initialize(container, clientAccount, environment, viewer) {
                this.ConsoleStack.Log("Calling BruceCesium Initialize.", console_utils_2.EConsoleColor.Blue);
                if (!container) {
                    throw ("Please provide a valid HTML container for the Cesium viewer.");
                }
                if (clientAccount == null) {
                    throw ("Please provide a client account.");
                }
                if (environment == null) {
                    throw ("Please provide an environment type.");
                }
                this._container = container;
                this.clientAccount = clientAccount;
                this.environment = environment;
                if (viewer) {
                    this._viewer = viewer;
                }
                // No viewer is provided let's create our own.
                else {
                    this.ConsoleStack.Log("BruceCesium Initialize was not provided a viewer, creating new Cesium instance.", console_utils_2.EConsoleColor.Orange);
                    this.createCesiumViewer();
                }
                this.initializeCesium();
            }
            /**
             * Creates Cesium viewer and initializes Cesium helpers.
             * Warning: Cannot call Init again for the same viewer.
             *
             * @param container: the root container which will have Cesium viewer and other components put inside.
             * @param clientAccount: client account to link to.
             * @param environment: environment to determine what API version to link to.
             */
            Init(container, clientAccount, environment) {
                this.ConsoleStack.Log("Calling BruceCesium Init.", console_utils_2.EConsoleColor.Blue);
                if (this.hasInitialized) {
                    throw ("Viewer has already been initialized.");
                }
                if (!container) {
                    throw ("Please provide a valid HTML container for the Cesium viewer.");
                }
                if (clientAccount == null) {
                    throw ("Please provide a client account.");
                }
                if (environment == null) {
                    throw ("Please provide an environment type.");
                }
                this._container = container;
                this.clientAccount = clientAccount;
                this.environment = environment;
                this.createCesiumViewer();
                this.initializeCesium();
                this.markCesiumViewer();
                this.markHTMLContainer();
                this._initialized = true;
            }
            /**
             * Uses provided Cesium viewer to initialize.
             * Use this instead of Init method to re-use an existing Cesium viewer / container.
             *
             * Warning: Cannot call Init again for the same viewer.
             *
             * @param cViewer
             * @param clientAccount
             * @param environment
             */
            InitUsingCesiumViewer(cViewer, clientAccount, environment) {
                this.ConsoleStack.Log("Calling BruceCesium InitUsingCesiumViewer.", console_utils_2.EConsoleColor.Blue);
                if (this.hasInitialized) {
                    throw ("Viewer has already been initialized.");
                }
                if (!cViewer) {
                    throw ("Please provide a Cesium viewer.");
                }
                if (clientAccount == null) {
                    throw ("Please provide a client account.");
                }
                if (environment == null) {
                    throw ("Please provide an environment type.");
                }
                this._container = cViewer.container;
                this._viewer = cViewer;
                this.clientAccount = clientAccount;
                this.environment = environment;
                this.initializeCesium();
                this.markCesiumViewer();
                this.markHTMLContainer();
                this._initialized = true;
            }
            /**
             * Disposes viewer.
             * - Removes all HTML elements from container that were added.
             * - Disposes any handlers.
             * - Stops rendering any menu items.
             * Warning: This does not dispose API cache as it is shared between viewers.
             * Warning: If Cesium viewer's container was moved outside of viewer container then it will not be removed.
             * Warning: If there are multiple Bruce Viewer's active for a Cesium viewer then Cesium viewer will not be disposed.
             * Warning: Please dispose of returned ConsoleStack yourself if you do not need it.
             */
            Dispose() {
                var _a, _b, _c, _d, _e;
                (_a = this.viewMonitor) === null || _a === void 0 ? void 0 : _a.Dispose();
                (_b = this.loadManager) === null || _b === void 0 ? void 0 : _b.Dispose();
                (_c = this.mouseEventHandler) === null || _c === void 0 ? void 0 : _c.Dispose();
                (_d = this.shadowHandler) === null || _d === void 0 ? void 0 : _d.DisableEventListening();
                (_e = this.menuItemManager) === null || _e === void 0 ? void 0 : _e.DisableAll();
                this.removeCesiumContainers(false);
                this.unmarkHTMLContainer();
                delete this.viewMonitor;
                delete this.mouseEventHandler;
                delete this.shadowHandler;
                delete this.menuItemManager;
                delete this.loadManager;
                return this.ConsoleStack;
            }
            /**
            * Initializes the created Cesium viewer.
            */
            initializeCesium() {
                let viewer = this.CesiumViewer;
                // Initialize the view monitor.
                if (!this.viewMonitor) {
                    this.viewMonitor = new cesium_view_monitor_1.CesiumViewMonitor(viewer);
                }
                // Initialize mouse listeners.
                if (!this.mouseEventHandler) {
                    this.mouseEventHandler = new cesium_mouse_events_1.CesiumMouseEvents(viewer);
                }
                // Initialize imagery handler.
                if (!this.imageryHandler) {
                    this.imageryHandler = new cesium_imagery_handler_1.CesiumImageryHandler(viewer === null || viewer === void 0 ? void 0 : viewer.imageryLayers);
                }
                // Initialize terrain handler.
                if (!this.terrainHandler) {
                    this.terrainHandler = new cesium_terrain_handler_1.CesiumTerrainHandler(viewer);
                }
                // Initialize shadow handler.
                if (!this.shadowHandler) {
                    this.shadowHandler = new cesium_shadow_handler_1.CesiumShadowHandler(viewer, null, cesium_shadow_handler_1.ECesiumShadowHandlerState.Disabled);
                }
                // Initialize ambient occlusion handler.
                if (!this.ambientOcclusionHandler) {
                    this.ambientOcclusionHandler = new cesium_ambient_occlusion_handler_1.CesiumAmbientOcclusionHandler(viewer, null, cesium_ambient_occlusion_handler_1.ECesiumAmbientOcclusionHandlerState.Disabled);
                }
                // First render.
                viewer.scene.requestRender();
            }
            /**
            * Creates Cesium viewer for the current container.
            */
            createCesiumViewer() {
                let container = this._container;
                let viewer = this._viewer = new Cesium.Viewer(container, {
                    useDefaultRenderLoop: true,
                    imageryProvider: new Cesium.ArcGisMapServerImageryProvider({
                        url: "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer",
                        enablePickFeatures: false
                    })
                });
                // Causes camera based events to not trigger on miniscule changes
                viewer.camera.percentageChanged = 0.05;
                // Start camera handler.
                this.cameraHandler = new cesium_camera_handler_1.CesiumCameraHandler(viewer);
                // Remove the double click camera zoom-in-on-entity default action.
                viewer.cesiumWidget.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
                this.destroyCesiumWidget(viewer.timeline);
                this.destroyCesiumWidget(viewer.vrButton);
                this.destroyCesiumWidget(viewer.sceneModePicker);
                this.destroyCesiumWidget(viewer.homeButton);
                this.destroyCesiumWidget(viewer.fullscreenButton);
                this.destroyCesiumWidget(viewer.baseLayerPicker);
                this.styleCesiumContainers();
            }
            /**
            * Destroys a given Cesium widget.
            * @param widget
            */
            destroyCesiumWidget(widget) {
                if (widget && !widget.isDestroyed) {
                    widget.destroy();
                }
            }
            /**
            * Returns a list of all available project views.
            */
            GetProjectViews() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.clientAccount == null || this.environment == null) {
                        throw ("Client account or environment not set, please initialize first.");
                    }
                    let api = bruce_api_2.BruceAPI.getInstance(this.environment, this.clientAccount);
                    let views = yield project_view_2.ProjectView.GetList(api);
                    return views;
                });
            }
            /**
            * Loads project view corresponding to given view id.
            * @param viewId
            */
            LoadProjectView(viewId) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.clientAccount == null || this.environment == null) {
                        throw ("Client account or environment not set, please initialize first.");
                    }
                    let api = bruce_api_2.BruceAPI.getInstance(this.environment, this.clientAccount);
                    let view = yield project_view_2.ProjectView.GetByID(api, viewId);
                    this.applyProjectViewSettings(view);
                    // Initialize the menu item manager.
                    this.loadManager = new cesium_load_manager_1.CesiumLoadManager(this._viewer);
                    this.visualRegister = new cesium_visual_register_5.CesiumVisualRegister(this._viewer);
                    this.menuItemManager = new cesium_menu_item_manager_5.CesiumMenuItemManager(api, this._viewer, this.viewMonitor, this.loadManager, this.visualRegister, view.Settings.MenuItems);
                    this.projectView = view;
                    return view;
                });
            }
            /**
            * Loads an empty project view to let developers programatically create their own menu items.
            */
            LoadEmptyProjectView() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.clientAccount == null || this.environment == null) {
                        throw ("Client account or environment not set, please initialize first.");
                    }
                    let api = bruce_api_2.BruceAPI.getInstance(this.environment, this.clientAccount);
                    let view = new project_view_2.ProjectView(null);
                    view.Name = "Empty View";
                    view.Settings = new project_view_settings_2.ProjectViewSettings(null);
                    this.applyProjectViewSettings(view);
                    // Initialize the menu item manager.
                    this.loadManager = new cesium_load_manager_1.CesiumLoadManager(this._viewer);
                    this.visualRegister = new cesium_visual_register_5.CesiumVisualRegister(this._viewer);
                    this.menuItemManager = new cesium_menu_item_manager_5.CesiumMenuItemManager(api, this._viewer, this.viewMonitor, this.loadManager, this.visualRegister, view.Settings.MenuItems);
                    this.projectView = view;
                    return view;
                });
            }
            /**
            * Enables a given bookmark.
            * Promise will resolve when camera flies to bookmark location.
            * @param bookmark
            */
            EnableBookmark(bookmark) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.clientAccount == null || this.environment == null) {
                        throw ("Client account or environment not set, please initialize first.");
                    }
                    if (!this.menuItemManager) {
                        throw ("No menu item manager. Please load project view first.");
                    }
                    this._enabledBookmarkId = bookmark.ID;
                    this.ConsoleStack.Log("Enabling bookmark: " + bookmark.ID, console_utils_2.EConsoleColor.Blue);
                    return new Promise((res, rej) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        let duration = (_a = this.projectView.Settings) === null || _a === void 0 ? void 0 : _a.BookmarkTransitionSpeed;
                        if (duration == null) {
                            duration = 2000;
                        }
                        if (duration > 0) {
                            duration /= 1000;
                        }
                        let cViewer = this.CesiumViewer;
                        let applyFrustum = () => {
                            let camera = cViewer.scene.camera;
                            if (bookmark.Settings.cameraFrustum == camera_frustum_1.ECameraFrustum.Orthographic) {
                                camera.switchToOrthographicFrustum();
                            }
                            else {
                                camera.switchToPerspectiveFrustum();
                            }
                        };
                        cViewer.camera.cancelFlight();
                        if (bookmark.Camera) {
                            this.ConsoleStack.Log("Bookmark flying camera", console_utils_2.EConsoleColor.Blue);
                            cViewer.camera.flyTo({
                                destination: Cesium.Cartesian3.fromDegrees(bookmark.Camera.position.longitude, bookmark.Camera.position.latitude, bookmark.Camera.position.height),
                                duration: duration,
                                orientation: {
                                    heading: bookmark.Camera.heading,
                                    pitch: bookmark.Camera.pitch,
                                    roll: bookmark.Camera.roll
                                },
                                cancel: () => {
                                    rej(null);
                                },
                                complete: () => {
                                    applyFrustum();
                                    res(null);
                                }
                            });
                        }
                        else {
                            res(null);
                        }
                        this.applyBookmarkTiles(bookmark);
                        let shadowsEnabled = bookmark.Settings.shadows;
                        if (shadowsEnabled == null) {
                            shadowsEnabled = false;
                        }
                        this.shadowHandler.Update(shadowsEnabled ? cesium_shadow_handler_1.ECesiumShadowHandlerState.Static : cesium_shadow_handler_1.ECesiumShadowHandlerState.Disabled);
                        let ambientOcclusionEnabled = bookmark.Settings.ambientOcclusion;
                        if (ambientOcclusionEnabled == null) {
                            ambientOcclusionEnabled = false;
                        }
                        this.ambientOcclusionHandler.Update(ambientOcclusionEnabled ? cesium_ambient_occlusion_handler_1.ECesiumAmbientOcclusionHandlerState.Enabled : cesium_ambient_occlusion_handler_1.ECesiumAmbientOcclusionHandlerState.Disabled);
                        let groundOcclusion = bookmark.Settings.groundOcclusion;
                        if (groundOcclusion == null) {
                            groundOcclusion = false;
                        }
                        cViewer.scene.globe.depthTestAgainstTerrain = groundOcclusion;
                        cViewer.scene.requestRender();
                        this.ConsoleStack.Log("Bookmark finished enabling settings", console_utils_2.EConsoleColor.Blue);
                        // Now to enable / disable menu items.
                        let menuItems = bookmark.Settings.selectedItemIds;
                        if (!menuItems) {
                            menuItems = [];
                        }
                        let enabledBranchIds = [];
                        for (let i = 0; i < menuItems.length; i++) {
                            let menuItemId = menuItems[i];
                            let menuItem = this.menuItemManager.GetMenuItemBranchByID(menuItemId);
                            if (menuItem) {
                                let ids = yield this.EnableMenuItemHierarchy(menuItem);
                                enabledBranchIds = enabledBranchIds.concat(ids);
                            }
                        }
                        let enabledItemIds = this.menuItemManager.enabledItems.map(x => { var _a; return (_a = x.menuItem) === null || _a === void 0 ? void 0 : _a.id; });
                        for (let i = 0; i < enabledItemIds.length; i++) {
                            let enabledItemId = enabledItemIds[i];
                            if (enabledBranchIds.findIndex(x => x == enabledItemId) <= -1) {
                                let enabledItem = this.menuItemManager.enabledItems.find(x => x.menuItem.id == enabledItemId);
                                this.menuItemManager.DisableMenuItem(enabledItem);
                            }
                        }
                        this.ConsoleStack.LogObj("Bookmark finished enabling menu items", menuItems, console_utils_2.EConsoleColor.Blue);
                        // Unhide / hide entities.
                        this.visualRegister.UnhideAll();
                        let hiddenEntities = bookmark.Settings.hidden;
                        if (hiddenEntities) {
                            let regExp = /[a-zA-Z]/g;
                            for (let i = 0; i < hiddenEntities.length; i++) {
                                let hidden = hiddenEntities[i];
                                // We now store the correctly hashed paths.
                                // We used to store them just combined plainly.
                                // We somehow need to identify old paths and fix them.
                                if (regExp.test(hidden)) {
                                    let d = "dc849fa2-2886-42c7-ac59-43bb6e4779c7";
                                    let isStandardLength = (hidden.length / d.length) % 2 == 1;
                                    if (isStandardLength) {
                                        let splits = hidden.match(new RegExp(".{1," + d.length + "}", "g"));
                                        let hash = bruce_meta_9.BruceMeta.HashPath(splits);
                                        this.visualRegister.HideByHashPath(hash);
                                    }
                                    // Pray other cases aren't CAD tree paths and would be hashed again fine.
                                    else {
                                        this.visualRegister.HideByPath([hidden]);
                                    }
                                }
                                else {
                                    this.visualRegister.HideByHashPath(hidden);
                                }
                            }
                        }
                        this.ConsoleStack.Log("Bookmark finished hiding entities", console_utils_2.EConsoleColor.Blue);
                    }));
                });
            }
            /**
             * Enables bookmark terrain and imagery.
             */
            applyBookmarkTiles(bookmark) {
                var _a;
                let enableTerrain = (terrainId) => {
                    terrainId = terrainId.replace(/ /g, "");
                    switch (terrainId) {
                        case "CesiumWorldTerrain":
                            break;
                        case "LINZ":
                            break;
                        default:
                            terrainId = "FlatTerrain";
                            break;
                    }
                    const provider = this.terrainHandler.GetProviderById(terrainId);
                    if (!provider) {
                        let newCProvider = null;
                        switch (terrainId) {
                            case "CesiumWorldTerrain":
                                newCProvider = Cesium.createWorldTerrain();
                                Cesium.Ion.defaultAccessToken = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJqdGkiOiI4ZTc2OTYzZC0yNzQ0LTQwYzMtYTQwZS0zYTJjZjQ4ZTY0ZDQiLCJpZCI6NDIsImlhdCI6MTQ4NjE1MzU2MX0.LCyOepn649Bk7z9rIe-ivzw9ML-SI8R3PSV2ArSUg90";
                                break;
                            case "LINZ":
                                newCProvider = new Cesium.CesiumTerrainProvider({
                                    url: "https://s3-ap-southeast-2.amazonaws.com/digitalnewzealand/PROD/Tilesets/nz-dem",
                                    requestVertexNormals: true
                                });
                                break;
                            default:
                                newCProvider = new Cesium.EllipsoidTerrainProvider({});
                                break;
                        }
                        const newProvider = new cesium_bruce_terrain_provider_2.CesiumBruceTerrainProvider(newCProvider, terrainId, terrainId);
                        this.terrainHandler.AddProvider(newProvider);
                    }
                    this.terrainHandler.Enable(terrainId);
                };
                const terrain = (_a = bookmark.Settings) === null || _a === void 0 ? void 0 : _a.terrain;
                if (terrain && typeof terrain == "string") {
                    enableTerrain(terrain);
                }
                else {
                    enableTerrain("FlatTerrain");
                }
            }
            /**
            * Applies settings in project view to Cesium viewer.
            * @param view
            */
            applyProjectViewSettings(view) {
                let settings = view === null || view === void 0 ? void 0 : view.Settings;
                if (settings == null) {
                    this.ConsoleStack.Log("Applying null project view settings. This may mean project view was failed to be found by id.", console_utils_2.EConsoleColor.Orange);
                    settings = new project_view_settings_2.ProjectViewSettings(null);
                }
                let cViewer = this._viewer;
                let scene = cViewer.scene;
                let globe = scene.globe;
                let globeColor = settings.GlobeColor;
                if (globeColor) {
                    let cGlobeColor = Cesium.Color.fromCssColorString(globeColor);
                    globe.baseColor = cGlobeColor;
                    globe.translucency.enabled = true;
                    globe.translucency.frontFaceAlphaByDistance = new Cesium.NearFarScalar(400.0, 0.0, 800.0, 1.0);
                    globe.translucency.frontFaceAlphaByDistance.nearValue = cGlobeColor.alpha;
                    globe.translucency.frontFaceAlphaByDistance.farValue = 1;
                }
                if (settings.PostProcessFXAA) {
                    scene.postProcessStages.fxaa.enabled = true;
                }
                this.shadowHandler.ApplyViewSettings(view.Settings);
                this.ambientOcclusionHandler.ApplyViewSettings(view.Settings);
            }
            /**
            * Enables a given menu item.
            * @param menuItem
            */
            EnableMenuItem(menuItem) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (!this.menuItemManager) {
                        throw ("No menu item manager. Please load project view first.");
                    }
                    let enabledItem = yield this.menuItemManager.EnableMenuItem(menuItem);
                    return enabledItem;
                });
            }
            /**
            * Enables a given menu item and all its children.
            * Returns an array of all enabled menu item ids.
            * @param menuItem
            */
            EnableMenuItemHierarchy(menuItem) {
                return __awaiter(this, void 0, void 0, function* () {
                    let ids = [];
                    function enableItem(manager, item) {
                        return new Promise((res) => __awaiter(this, void 0, void 0, function* () {
                            yield manager.EnableMenuItem(item);
                            let itemIds = [item.id];
                            let children = item.Children;
                            if (children) {
                                for (let i = 0; i < children.length; i++) {
                                    let child = children[i];
                                    let childIds = yield enableItem(manager, child);
                                    itemIds = itemIds.concat(childIds);
                                }
                            }
                            res(itemIds);
                        }));
                    }
                    ids = yield enableItem(this.menuItemManager, menuItem);
                    return ids;
                });
            }
            /**
            * Disables a given enabled menu item.
            * @param enabledMenuItem
            */
            DisableMenuItem(enabledMenuItem) {
                if (!this.menuItemManager) {
                    throw ("No menu item manager. Please load project view first.");
                }
                this.menuItemManager.DisableMenuItem(enabledMenuItem);
            }
            /**
             * Disables one or many menu items corresponding to given ids.
             * @param ids
             */
            DisableMenuItemsByIds(ids) {
                if (!this.menuItemManager) {
                    throw ("No menu item manager. Please load project view first.");
                }
                for (let i = 0; i < ids.length; i++) {
                    const id = ids[i];
                    const item = this.menuItemManager.enabledItems.find(x => { var _a; return ((_a = x.menuItem) === null || _a === void 0 ? void 0 : _a.id) == id; });
                    if (item) {
                        this.menuItemManager.DisableMenuItem(item);
                    }
                }
            }
            /**
            * Generates a menu item for a provided entity type id.
            * @param entityTypeId
            */
            CreateMenuItemFromEntityTypeId(entityTypeId, displayType = camera_zoom_control_6.ECameraZoomControlDisplayType.Geometry) {
                let newMenuItem = new menu_item_bruce_entities_2.MenuItemBruceEntities({
                    id: object_utils_45.ObjectUtils.UID(),
                    Type: menu_item_base_8.MenuItemType.BruceEntity,
                    BruceEntity: {
                        "EntityType.ID": entityTypeId
                    },
                    CameraZoomSettings: [
                        {
                            DisplayType: displayType,
                            MaxZoom: 8000,
                            MinZoom: 0
                        }
                    ]
                });
                return newMenuItem;
            }
            /**
            * Generates a menu item for a single entity.
            * @param entityTypeId
            * @param entityId
            * @param displayType
            */
            CreateMenuItemFromEntityId(entityTypeId, entityId, displayType = camera_zoom_control_6.ECameraZoomControlDisplayType.Geometry) {
                let newMenuItem = new menu_item_single_entity_2.MenuItemSingleEntity({
                    id: object_utils_45.ObjectUtils.UID(),
                    Type: menu_item_base_8.MenuItemType.SingleEntity,
                    BruceEntity: {
                        "EntityType.ID": entityTypeId,
                        EntityId: entityId
                    },
                    CameraZoomSettings: [
                        {
                            DisplayType: displayType,
                            MaxZoom: 8000,
                            MinZoom: 0
                        }
                    ]
                });
                return newMenuItem;
            }
            /**
            * Generates a menu item for an array of loaded entities.
            * @param entities
            * @param displayType
            * @param styleId
            * @returns
            */
            CreateMenuItemFromLoadedEntities(entities, styleId, displayType = camera_zoom_control_6.ECameraZoomControlDisplayType.Geometry) {
                let newMenuItem = new menu_item_loaded_entities_1.MenuItemLoadedEntities({
                    id: object_utils_45.ObjectUtils.UID(),
                    Type: menu_item_base_8.MenuItemType.LoadedBruceEntity,
                    BruceEntity: {
                        "EntityType.ID": null,
                        Entities: entities
                    },
                    DisplayType: displayType,
                    StyleID: styleId
                });
                return newMenuItem;
            }
            /**
             * Generates a menu item from a CAD tileset id.
             * @param tilesetId
             * @param styleId: Default style id to apply to all tileset features.
             */
            CreateMenuItemFromCADTilesetId(tilesetId, styleId) {
                let newMenuItem = new menu_item_model_tileset_2.MenuItemModelTileset({
                    id: object_utils_45.ObjectUtils.UID(),
                    Type: menu_item_base_8.MenuItemType.ModelTileset,
                    FlyTo: false,
                    StyleMapping: [],
                    styleId: styleId,
                    tileset: {
                        ClientAccountID: null,
                        TilesetID: tilesetId
                    }
                });
                return newMenuItem;
            }
            /**
            * Drills entities at given mouse position.
            * Only returns entities from this initialized instance.
            * If a viewer is shared between two instances of bruce maps, it will only return entities from this one.
            * @param mousePos
            * @param limit How many entities to limit the drill to.
            */
            DigEntitiesFromMouse(mousePos, limit = 5) {
                if (this.visualRegister == null) {
                    throw ("Visual register not created, please load project view first.");
                }
                let viewer = this.CesiumViewer;
                // Drill picked list of cesium entities
                let pickedObjects = viewer.scene.drillPick(mousePos, limit);
                // Located bruce entities
                let entities = [];
                for (let i = 0; i < pickedObjects.length; i++) {
                    let object = pickedObjects[i];
                    let entity = object && object.id && object.id instanceof Cesium.Entity ? object.id : object;
                    let bruceEntity = cesium_utils_9.CesiumUtils.GetRealEntity(entity);
                    if (bruceEntity && this.visualRegister.DoesExist(bruceEntity.bruceMeta)) {
                        entities.push(bruceEntity);
                    }
                }
                return entities;
            }
            /**
            * Hides unnecessary Cesium elements and applies Cesium default styling.
            * We apply styling in here to avoid having to import Cesium's style file.
            */
            styleCesiumContainers() {
                var _a;
                // Hide the junk that is around the viewer.
                let container = this._container;
                let generatedContainer = (_a = container.getElementsByClassName("cesium-viewer")) === null || _a === void 0 ? void 0 : _a[0];
                if (generatedContainer) {
                    let children = generatedContainer.children;
                    for (let i = 0; i < children.length; i++) {
                        let child = children[i];
                        if (!child.classList.contains("cesium-viewer-cesiumWidgetContainer")) {
                            child.style.display = "none";
                        }
                    }
                }
                // Apply Cesium's default styling for the different containers.
                let canvas = this._viewer.canvas;
                canvas.style.width = "100%";
                canvas.style.height = "100%";
                let widget = canvas.parentElement;
                widget.style.width = "100%";
                widget.style.height = "100%";
                widget.style.touchAction = "none";
                let widgetContainer = widget.parentElement;
                widgetContainer.style.width = "100%";
                widgetContainer.style.height = "100%";
                let viewerContainer = widgetContainer.parentElement;
                viewerContainer.style.fontFamily = "sans-serif";
                viewerContainer.style.fontSize = "16px";
                viewerContainer.style.overflow = "hidden";
                viewerContainer.style.display = "block";
                viewerContainer.style.position = "relative";
                viewerContainer.style.top = "0";
                viewerContainer.style.left = "0";
                viewerContainer.style.width = "100%";
                viewerContainer.style.height = "100%";
            }
            /**
            * Marks the Cesium viewer's element with this viewer's ID.
            */
            markCesiumViewer() {
                var _a;
                let container = this.Container;
                if (container) {
                    let cViewerContainer = (_a = container.getElementsByClassName("cesium-viewer")) === null || _a === void 0 ? void 0 : _a[0];
                    if (cViewerContainer) {
                        if (cViewerContainer._attachedBMViewers == null) {
                            cViewerContainer._attachedBMViewers = [];
                        }
                        let index = cViewerContainer._attachedBMViewers.findIndex(x => x == this.id);
                        if (index <= -1) {
                            cViewerContainer._attachedBMViewers.push(this.id);
                            this.ConsoleStack.Log("Marking Cesium container with viewer: " + this.id, console_utils_2.EConsoleColor.Blue);
                        }
                    }
                }
                else {
                    this.ConsoleStack.Error("Failed to mark Cesium container as it was null");
                }
            }
            /**
            * Unmarks the Cesium viewer's element with this viewer's ID.
            */
            unmarkCesiumViewer() {
                var _a;
                let container = this.Container;
                if (container) {
                    let cViewerContainer = (_a = container.getElementsByClassName("cesium-viewer")) === null || _a === void 0 ? void 0 : _a[0];
                    if (cViewerContainer) {
                        if (cViewerContainer._attachedBMViewers) {
                            let index = cViewerContainer._attachedBMViewers.findIndex(x => x == this.id);
                            if (index > -1) {
                                cViewerContainer._attachedBMViewers.splice(index, 1);
                                this.ConsoleStack.Log("Unmarking Cesium container with viewer: " + this.id, console_utils_2.EConsoleColor.Blue);
                            }
                        }
                    }
                }
                else {
                    this.ConsoleStack.Error("Failed to unmark Cesium container as it was null");
                }
            }
            /**
            * Returns the amount of marks on the Cesium viewer element.
            * This indicates how many Bruce Viewer instances are active in it.
            */
            getCesiumViewerMarkCount() {
                var _a;
                let container = this.Container;
                if (container) {
                    let cViewerContainer = (_a = container.getElementsByClassName("cesium-viewer")) === null || _a === void 0 ? void 0 : _a[0];
                    if (cViewerContainer) {
                        if (cViewerContainer._attachedBMViewers) {
                            return cViewerContainer._attachedBMViewers.length;
                        }
                    }
                }
                return 0;
            }
            /**
            * Mark's the Bruce viewer's container element with this viewer instance.
            */
            markHTMLContainer() {
                if (this._container) {
                    let marks = this.getBruceViewerMarks();
                    let index = marks.findIndex(x => x.id == this.id);
                    if (index <= -1) {
                        marks.push(this);
                        this._container._bmInstances = marks;
                        this.ConsoleStack.Log("Marking HTML container with viewer: " + this.id, console_utils_2.EConsoleColor.Blue);
                    }
                }
                else {
                    this.ConsoleStack.Error("Failed to mark container as it was null");
                }
            }
            /**
            * Unmark's the Bruce viewer's container element.
            */
            unmarkHTMLContainer() {
                if (this._container) {
                    let marks = this.getBruceViewerMarks();
                    let index = marks.findIndex(x => x.id == this.id);
                    if (index > -1) {
                        marks.splice(index, 1);
                        this._container._bmInstances = marks;
                        this.ConsoleStack.Log("Unmarking HTML container with viewer: " + this.id, console_utils_2.EConsoleColor.Blue);
                    }
                }
                else {
                    this.ConsoleStack.Error("Failed to unmark container as it was null");
                }
            }
            /**
            * Returns a list of Bruce viewer's that have marked the current container.
            */
            getBruceViewerMarks() {
                var _a;
                let instances = (_a = this._container) === null || _a === void 0 ? void 0 : _a._bmInstances;
                return instances == null ? [] : instances;
            }
            /**
            * Removes any added Cesium containers for this viewer instance.
            * @param force: if the amount of Bruce Viewer's attached to the Cesium viewer should be ignored.
            */
            removeCesiumContainers(force) {
                var _a;
                this.unmarkCesiumViewer();
                let marks = this.getCesiumViewerMarkCount();
                if (marks <= 0 || force) {
                    let container = this._container;
                    let cesiumContainer = (_a = container.getElementsByClassName(this.id)) === null || _a === void 0 ? void 0 : _a[0];
                    if (cesiumContainer && container.contains(cesiumContainer)) {
                        container.removeChild(cesiumContainer);
                    }
                    this.CesiumViewer.destroy();
                }
            }
            /**
            * Clears API cached information.
            */
            ClearAPICache() {
                if (this.clientAccount == null || this.environment == null) {
                    throw ("Client account or environment not set, please initialize first.");
                }
                let api = bruce_api_2.BruceAPI.getInstance(this.environment, this.clientAccount);
                api.ClearCache();
            }
            /**
            * Loads / creates session for given credentials.
            * Does not apply session, call 'SetSession' after.
            * @param login
            * @param pass
            */
            LoadSession(login, pass) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.clientAccount == null || this.environment == null) {
                        throw ("Client account or environment not set, please initialize first.");
                    }
                    let api = session_api_1.SessionAPI.getInstance(this.environment);
                    let data = yield idm_session_3.IDMSession.Login(api, this.clientAccount, login, pass);
                    return data;
                });
            }
            /**
            * Logs out of current session (if exists).
            */
            LogoutSession() {
                return __awaiter(this, void 0, void 0, function* () {
                    if (this.clientAccount == null || this.environment == null) {
                        throw ("Client account or environment not set, please initialize first.");
                    }
                    session_api_1.SessionAPI.Session = new idm_session_3.IDMSession(null);
                });
            }
            /**
            * Sets the loaded session.
            * @param sessionId
            */
            SetSession(sessionId) {
                session_api_1.SessionAPI.Session.ID = sessionId;
            }
            /**
            * Returns API instance for the currently set enviornment.
            */
            GetAPIInstance() {
                if (this.clientAccount == null || this.environment == null) {
                    throw ("Client account or environment not set, please initialize first.");
                }
                let api = bruce_api_2.BruceAPI.getInstance(this.environment, this.clientAccount);
                return api;
            }
            /**
            * Returns BruceCesium viewers from given HTML container.
            * If the HTML container was used to initialize a viewer then it will return that viewer's instance.
            * A viewer that was disposed will not be returned.
            * @param container
            */
            static ViewersFromHTMLContainer(container) {
                var _a;
                let instances = (_a = container) === null || _a === void 0 ? void 0 : _a._bmInstances;
                return instances == null ? [] : instances;
            }
        }
        BruceCesium.Viewer = Viewer;
    })(BruceCesium = exports.BruceCesium || (exports.BruceCesium = {}));
});
define("entry-points/cesium/common/cesium-bruce-info-utils", ["require", "exports", "cesium", "bruce-models/common/geometry", "bruce-models/common/polygon", "utils/object-utils", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, geometry_6, polygon_5, object_utils_46, cesium_drawing_utils_4, cesium_utils_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumBruceInfoUtils = void 0;
    Cesium = __importStar(Cesium);
    /**
     * Utilities directly working with bruceinfo model or related models.
     */
    class CesiumBruceInfoUtils {
        /**
         * Parses bruce info geometry arbitrary data into geometry instance.
         * @param bruceInfo
         * @deprecated BruceInfo now has own parser to clean it's own data.
         * @returns
         */
        static ParseGeometry(bruceInfo) {
            let geometry = bruceInfo.geometry;
            if (geometry) {
                if (typeof geometry == "string") {
                    let geometryParsed = (geometry || "").split(";");
                    let positions = [];
                    // Parse the weird split up string into an array of positions
                    for (let i = 0; i < geometryParsed.length; i++) {
                        let data = geometryParsed[i];
                        let points = cesium_utils_10.CesiumUtils.ParsePoints(data);
                        if (points && points.length > 0) {
                            positions = positions.concat(points);
                        }
                    }
                    // Remove duplicates that are "in a row".
                    positions = object_utils_46.ObjectUtils.CleanPolylinePoints(positions);
                    let cesiumPositions = cesium_utils_10.CesiumUtils.ICartesian3ToCartesian3(positions);
                    let newGeometry = new geometry_6.Geometry(null);
                    if (cesiumPositions.length > 0) {
                        newGeometry.Point = cesiumPositions[0].toString();
                        if (cesiumPositions.length > 1) {
                            newGeometry.LineString = cesium_drawing_utils_4.CesiumDrawingUtils.PolylineGeometryFromCartesianArray(cesiumPositions);
                        }
                        if (cesiumPositions.length > 2) {
                            cesiumPositions = cesium_drawing_utils_4.CesiumDrawingUtils.ClosePolygon(cesiumPositions);
                            newGeometry.Polygon = cesium_drawing_utils_4.CesiumDrawingUtils.PolygonGeometryFromCartesianArray(cesiumPositions);
                        }
                    }
                    return newGeometry;
                }
                else {
                    return geometry;
                }
            }
            else {
                return new geometry_6.Geometry(null);
            }
        }
        /**
         * Returns a bruce info geometry object for a given cartesian3 position array
         * @param posses
         */
        static PolygonGeometryFromCartesianArray(posses) {
            if (posses.length < 3) {
                return [];
            }
            let carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(posses[0]);
            let latitude = Cesium.Math.toDegrees(carto.latitude);
            let longitude = Cesium.Math.toDegrees(carto.longitude);
            let ringString = longitude + "," + latitude + "," + carto.height;
            for (let i = 1; i < posses.length; i++) {
                carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(posses[i]);
                latitude = Cesium.Math.toDegrees(carto.latitude);
                longitude = Cesium.Math.toDegrees(carto.longitude);
                ringString += " " + longitude + "," + latitude + "," + carto.height;
            }
            let geometry = [
                new polygon_5.Polygon({
                    Facing: polygon_5.PolygonFacing.out,
                    LinearRing: ringString
                })
            ];
            return geometry;
        }
        /**
         * Returns a bruce info geometry object for a given cartesian 3 position array.
         * @param posses
         */
        static PolylineGeometryFromCartesianArray(posses) {
            if (posses.length < 2) {
                return "";
            }
            let carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(posses[0]);
            let latitude = Cesium.Math.toDegrees(carto.latitude);
            let longitude = Cesium.Math.toDegrees(carto.longitude);
            let lineString = longitude + "," + latitude + "," + carto.height;
            for (let i = 1; i < posses.length; i++) {
                carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(posses[i]);
                latitude = Cesium.Math.toDegrees(carto.latitude);
                longitude = Cesium.Math.toDegrees(carto.longitude);
                lineString += " " + longitude + "," + latitude + "," + carto.height;
            }
            return lineString;
        }
    }
    exports.CesiumBruceInfoUtils = CesiumBruceInfoUtils;
});
define("utils/delay-queue", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DelayQueue = void 0;
    /**
     * Utility to help manage updates that are being called often but shouldn't run often.
     *
     * For example we have app-visuals-tree, we want to update the tree everytime an entity is loaded or unloaded.
     * Except if we updated it that often for an IFC tileset, browser would crash.
     *
     * This utlity will help manage that.
     */
    class DelayQueue {
        /**
         * Initializes delay queue for a given method.
         * @param callback
         * @param delay in milliseconds.
         */
        constructor(callback, delay = 200) {
            // Millisecond delay.
            this.delay = 200;
            this.callback = callback;
            this.delay = delay;
        }
        /**
         * Queues a call to the method.
         * @param force If queue should be cut and a call forced.
         */
        Call(force = false) {
            if (this.lastCallTime == null) {
                force = true;
            }
            if (force) {
                let endDate = new Date().getTime();
                this.doCall(endDate);
            }
            else {
                let endDate = new Date().getTime();
                let seconds = (endDate - this.lastCallTime) / 1000;
                let delay = this.delay / 1000;
                if (seconds > delay) {
                    this.doCall(endDate);
                }
                else if (this.delayTimeout == null) {
                    let diff = (delay - seconds) * 1000;
                    this.delayTimeout = setTimeout(() => {
                        this.delayTimeout = null;
                        this.Call();
                    }, diff + 0.02);
                }
            }
        }
        /**
         * Calls callback and records given last call date.
         * @param endDate
         */
        doCall(endDate) {
            if (this.delayTimeout != null) {
                clearTimeout(this.delayTimeout);
                this.delayTimeout = null;
            }
            this.lastCallTime = endDate;
            this.callback();
        }
        /**
         * Disposes the utility.
         */
        Dispose() {
            if (this.delayTimeout != null) {
                clearTimeout(this.delayTimeout);
                this.delayTimeout = null;
            }
        }
    }
    exports.DelayQueue = DelayQueue;
});
define("entry-points/cesium/common/cesium-cached-picking-height-util", ["require", "exports", "cesium"], function (require, exports, Cesium) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumCachedPickingHeightUtil = void 0;
    Cesium = __importStar(Cesium);
    /**
     * Sampling heights can be expensive.
     * This utility tries to cache height samples.
     */
    class CesiumCachedPickingHeightUtil {
        /**
         * @param viewer
         * @param proximity: default is 5 meters.
         */
        constructor(viewer, proximity = 5) {
            // Allowed proximity from existing cache record in meters.
            this.proximity = 5;
            // All positions that have been picked in the cache tool.
            this.pickedPositions = [];
            // When it hits this limit it will remove the first half of added positions.
            this.pickedCacheLimit = 1000;
            this.viewer = viewer;
            if (proximity) {
                this.proximity = proximity;
            }
            this.terrainChangeSub = viewer.scene.terrainProviderChanged.addEventListener(() => {
                this.Clear();
            });
        }
        /**
         * @param pos: in radians.
         */
        Pick(pos) {
            let nearest = this.findNearestPos(pos);
            if (nearest) {
                return nearest.height;
            }
            return this.createPick(pos);
        }
        createPick(pos) {
            let tmp = pos;
            if (pos.height) {
                tmp = tmp.clone(new Cesium.Cartographic());
                tmp.height = 0;
            }
            let height = this.viewer.scene.globe.getHeight(tmp);
            this.pickedPositions.push({
                height: height ? height : 0,
                pos: pos
            });
            if (this.pickedPositions.length >= this.pickedCacheLimit) {
                this.cull();
            }
            return height | 0;
        }
        cull() {
            this.pickedPositions.splice(0, Math.floor(this.pickedCacheLimit / 2));
        }
        findNearestPos(pos) {
            for (let i = 0; i < this.pickedPositions.length; i++) {
                let picked = this.pickedPositions[i];
                if (this.distance(pos, picked.pos) <= this.proximity) {
                    return picked;
                }
            }
            return null;
        }
        distance(a, b) {
            let aPos = Cesium.Cartesian3.fromRadians(a.longitude, a.latitude, 0);
            let bPos = Cesium.Cartesian3.fromRadians(b.longitude, b.latitude, 0);
            return Cesium.Cartesian3.distance(aPos, bPos);
        }
        Clear() {
            this.pickedPositions = [];
        }
        Dispose() {
            this.Clear();
            this === null || this === void 0 ? void 0 : this.terrainChangeSub();
            this.terrainChangeSub = null;
        }
    }
    exports.CesiumCachedPickingHeightUtil = CesiumCachedPickingHeightUtil;
});
define("entry-points/cesium/common/cesium-point-out", ["require", "exports", "cesium", "bruce-models/common/geometry", "utils/delay-queue", "entry-points/cesium/common/cesium-bruce-info-utils", "entry-points/cesium/common/cesium-cached-picking-height-util", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, geometry_7, delay_queue_1, cesium_bruce_info_utils_1, cesium_cached_picking_height_util_1, cesium_utils_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPointOut = void 0;
    Cesium = __importStar(Cesium);
    var CesiumPointOutType;
    (function (CesiumPointOutType) {
        CesiumPointOutType[CesiumPointOutType["Box"] = 0] = "Box";
        CesiumPointOutType[CesiumPointOutType["Icon"] = 1] = "Icon";
    })(CesiumPointOutType || (CesiumPointOutType = {}));
    class CesiumPointOut {
        constructor(viewer, visualRegister, bruceMeta, cssColorString) {
            this.disposed = false;
            this.viewer = viewer;
            this.visualRegister = visualRegister;
            this.bruceMeta = bruceMeta;
            this.picker = new cesium_cached_picking_height_util_1.CesiumCachedPickingHeightUtil(this.viewer);
            this.cssColorString = cssColorString;
            if (!this.cssColorString) {
                cssColorString = "white";
            }
            this.updateQueue = new delay_queue_1.DelayQueue(() => {
                this.doUpdate();
            }, 50);
        }
        /**
         * @returns currently shown visual from all visual register visuals matching meta.
         */
        getVisual() {
            let visuals = this.visualRegister.getVisuals(this.bruceMeta);
            let visual = null;
            for (let i = 0; i < visuals.length; i++) {
                let tmp = visuals[i];
                tmp.DoOnEntity((cesiumEntity) => {
                    if (cesiumEntity.show == true) {
                        visual = tmp;
                    }
                });
                if (visual) {
                    break;
                }
            }
            return visual;
        }
        /**
         * Call to queue an update the point out.
         * @param force
         */
        Update(force = false) {
            this.updateQueue.Call(force);
        }
        /**
         * Performs update to point out.
         */
        doUpdate() {
            this.Remove();
            if (!this.disposed) {
                let visual = this.getVisual();
                if (visual) {
                    this.create(visual);
                }
            }
        }
        /**
         * Removes the point out.
         */
        Remove() {
            if (this.element) {
                let parent = this.element.parentElement;
                if (parent) {
                    parent.removeChild(this.element);
                }
                delete this.element;
                this.element = null;
            }
        }
        Dispose() {
            this.disposed = true;
            this.Remove();
            this.picker.Dispose();
        }
        create(visual) {
            let points = this.getPoints(visual);
            if (points.length == 1) {
                let element = this.constructElementBase(CesiumPointOutType.Icon);
                this.element = element;
                this.viewer.canvas.parentElement.appendChild(element);
                this.applyPointElementPosition(element, points[0]);
            }
            else if (points.length > 1) {
                let bounds = this.getBoundaries(points);
                if (bounds) {
                    let element = this.constructElementBase(CesiumPointOutType.Box);
                    this.element = element;
                    this.viewer.canvas.parentElement.appendChild(element);
                    this.applyBoxElementPosition(element, bounds);
                }
            }
        }
        constructElementBase(type) {
            switch (type) {
                case CesiumPointOutType.Box:
                    return this.constructBoxElementBase();
                case CesiumPointOutType.Icon:
                    return this.constructPointElementBase();
            }
        }
        constructPointElementBase() {
            let div = document.createElement("div");
            div.style.position = "absolute";
            div.style.fontSize = "24px";
            div.style.color = this.cssColorString;
            div.style.display = "none";
            div.style.pointerEvents = "none";
            return div;
        }
        constructBoxElementBase() {
            let div = document.createElement("div");
            div.style.position = "absolute";
            div.style.display = "none";
            div.style.pointerEvents = "none";
            return div;
        }
        /**
         * Applies needed styling to point element for given position.
         * @param element
         * @param position
         */
        applyPointElementPosition(element, position) {
            let screenPos = this.getScreenPosition(position);
            if (screenPos && screenPos.x) {
                element.style.left = screenPos.x + "px";
                element.style.top = screenPos.y + "px";
                element.style.display = "block";
                element.innerHTML =
                    `
            <svg xmlns="http://www.w3.org/2000/svg" width="35" height="35" viewBox="0 0 258 462" fill="none">
            <g filter="url(#filter0_d)">
            <path d="M131 454L99 426.459V233H160V426.459L131 454Z" fill="${this.cssColorString}"/>
            <path d="M254 125C254 194.036 198.036 250 129 250C59.9644 250 4 194.036 4 125C4 55.9644 59.9644 0 129 0C198.036 0 254 55.9644 254 125Z" fill="${this.cssColorString}"/>
            </g>
            <defs>
            <filter id="filter0_d" x="0" y="0" width="258" height="462" filterUnits="userSpaceOnUse" color-interpolation-filters="sRGB">
            <feFlood flood-opacity="0" result="BackgroundImageFix"/>
            <feColorMatrix in="SourceAlpha" type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0"/>
            <feOffset dy="4"/>
            <feGaussianBlur stdDeviation="2"/>
            <feColorMatrix type="matrix" values="0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.25 0"/>
            <feBlend mode="normal" in2="BackgroundImageFix" result="effect1_dropShadow"/>
            <feBlend mode="normal" in="SourceGraphic" in2="effect1_dropShadow" result="shape"/>
            </filter>
            </defs>
            </svg>
            `;
            }
            else {
                element.style.display = "none";
            }
        }
        /**
         * Applies needed styling to box element for given bounds.
         * @param element
         * @param bounds
         */
        applyBoxElementPosition(element, bounds) {
            let positions = [];
            let pos1 = Cesium.Cartesian3.fromDegrees(bounds.maxLongitude, bounds.maxLatitude, bounds.maxAltitude);
            let pos2 = Cesium.Cartesian3.fromDegrees(bounds.maxLongitude, bounds.minLatitude, bounds.maxAltitude);
            let pos3 = Cesium.Cartesian3.fromDegrees(bounds.minLongitude, bounds.maxLatitude, bounds.maxAltitude);
            let pos4 = Cesium.Cartesian3.fromDegrees(bounds.minLongitude, bounds.minLatitude, bounds.maxAltitude);
            let screenPos1 = this.getScreenPosition(pos1);
            let screenPos2 = this.getScreenPosition(pos2);
            let screenPos3 = this.getScreenPosition(pos3);
            let screenPos4 = this.getScreenPosition(pos4);
            positions.push(screenPos1);
            positions.push(screenPos2);
            positions.push(screenPos4);
            positions.push(screenPos3);
            positions.push(screenPos1);
            let valid = cesium_utils_11.CesiumUtils.Validate2DPositions(positions);
            if (!valid) {
                return;
            }
            let pathString = "";
            for (let i = 0; i < positions.length; i++) {
                let pos = positions[i];
                if (i == 0) {
                    pathString += "M";
                }
                else {
                    pathString += "L";
                }
                pathString += pos.x + " " + pos.y + " ";
            }
            let canvas = this.viewer.canvas;
            let width = canvas.offsetWidth;
            let height = canvas.offsetHeight;
            element.innerHTML =
                `
        <svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}">
            <g fill="none" stroke="${this.cssColorString}" stroke-width="2">
                <path stroke-dasharray="12" d="${pathString}"/>
            </g>
        </svg>
        `;
            element.style.display = "block";
            element.style.top = "0";
            element.style.left = "0";
        }
        /**
         * Returns screen position for a given 3d position.
         * @param pos
         * @returns
         */
        getScreenPosition(pos) {
            let pos2D = this.viewer.scene.cartesianToCanvasCoordinates(pos);
            if (pos2D && pos2D.x) {
                return pos2D;
            }
            return null;
        }
        /**
         * Returns bruce boundaries from array of points.
         * Returns null if no boundaries can be calculated.
         * @param points
         * @returns
         */
        getBoundaries(points) {
            if (points.length > 0) {
                let polygon = cesium_bruce_info_utils_1.CesiumBruceInfoUtils.PolygonGeometryFromCartesianArray(points);
                let geometry = new geometry_7.Geometry(null);
                geometry.Polygon = polygon;
                let bounds = geometry.CalculateBoundaries();
                return bounds;
            }
            return null;
        }
        /**
         * Returns an array of positions that make up all points for a given visual.
         * @param visual
         * @returns
         */
        getPoints(visual) {
            let points = [];
            visual.DoOnEntity((cesiumEntity) => {
                var _a, _b;
                if (cesiumEntity.polygon) {
                    let hierarchy = this.getCesiumValue(cesiumEntity.polygon.hierarchy);
                    if (hierarchy && hierarchy.positions.length > 0) {
                        let heightRef = cesium_utils_11.CesiumUtils.getCesiumValue(this.viewer, (_a = cesiumEntity.polygon) === null || _a === void 0 ? void 0 : _a.heightReference);
                        let polyPoints = this.processPositions(heightRef, hierarchy.positions);
                        points = points.concat(polyPoints);
                    }
                }
                else if (cesiumEntity.polyline) {
                    let polyPoints = this.getCesiumValue(cesiumEntity.polyline.positions);
                    if (polyPoints && polyPoints.length > 0) {
                        let clamped = cesium_utils_11.CesiumUtils.getCesiumValue(this.viewer, cesiumEntity.polyline.clampToGround);
                        let heightRef = clamped == null ? Cesium.HeightReference.CLAMP_TO_GROUND : clamped ? Cesium.HeightReference.CLAMP_TO_GROUND : Cesium.HeightReference.NONE;
                        polyPoints = this.processPositions(heightRef, polyPoints);
                        points = points.concat(polyPoints);
                    }
                }
                if (points.length <= 0) {
                    let pos = this.getCesiumValue(cesiumEntity.position);
                    if (pos) {
                        let heightRef = cesium_utils_11.CesiumUtils.getCesiumValue(this.viewer, (_b = cesiumEntity.point) === null || _b === void 0 ? void 0 : _b.heightReference);
                        pos = this.processPosition(pos, heightRef);
                        points.push(pos);
                    }
                }
            });
            return points;
        }
        processPositions(heightRef, posses) {
            let newPosses = [];
            for (let i = 0; i < posses.length; i++) {
                let pos = posses[i];
                pos = this.processPosition(heightRef, pos);
                newPosses.push(pos);
            }
            return newPosses;
        }
        processPosition(heightRef, pos) {
            if (heightRef == null) {
                heightRef = Cesium.HeightReference.CLAMP_TO_GROUND;
            }
            let carto = Cesium.Cartographic.fromCartesian(pos);
            if (heightRef == Cesium.HeightReference.CLAMP_TO_GROUND) {
                if (carto.height == 0) {
                    carto.height = this.picker.Pick(carto);
                    pos = Cesium.Cartesian3.fromRadians(carto.longitude, carto.latitude, carto.height);
                }
                return pos;
            }
            else if (heightRef == Cesium.HeightReference.RELATIVE_TO_GROUND) {
            }
            else if (heightRef == Cesium.HeightReference.NONE) {
            }
            return pos;
        }
        /**
         * Returns cesium arbitrary value from arbitrary property.
         * @param value
         * @returns
         */
        getCesiumValue(value) {
            if (value) {
                if (value.getValue) {
                    return value.getValue(this.viewer.scene.lastRenderTime);
                }
                else {
                    return value;
                }
            }
            else {
                return null;
            }
        }
    }
    exports.CesiumPointOut = CesiumPointOut;
});
define("entry-points/cesium/common/cesium-render-listener", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_47) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumRenderListener = void 0;
    class CesiumRenderListener {
        constructor(viewer) {
            this.renderCallbacks = [];
            this.viewer = viewer;
        }
        /**
         * Starts listening for cesium renders.
         */
        Start() {
            if (!this.renderHandler) {
                this.renderHandler = this.viewer.scene.preRender.addEventListener(() => {
                    for (let i = 0; i < this.renderCallbacks.length; i++) {
                        this.renderCallbacks[i].callback();
                    }
                });
            }
        }
        /**
         * Disposes render listener.
         */
        Stop() {
            if (this.renderHandler) {
                this.renderHandler();
                this.renderHandler = null;
            }
        }
        /**
         * Adds a given callback to call on render.
         * @param callback
         * @param refId Optional id to reference for removing callback. Will generate one if not provided.
         */
        AddCallback(callback, refId = null) {
            if (!refId) {
                refId = object_utils_47.ObjectUtils.UID();
            }
            let exists = this.CallbackExists(refId);
            if (!exists) {
                this.renderCallbacks.push({ id: refId, callback: callback });
            }
            return refId;
        }
        RemoveCallback(refId) {
            let index = this.renderCallbacks.findIndex(x => x.id == refId);
            if (index > -1) {
                this.renderCallbacks.splice(index, 1);
            }
        }
        /**
         * Returns if a callback exists with a given refId.
         * @param refId
         */
        CallbackExists(refId) {
            return this.renderCallbacks.findIndex(x => x.id == refId) > -1;
        }
    }
    exports.CesiumRenderListener = CesiumRenderListener;
});
define("entry-points/cesium/common/cesium-position-map", ["require", "exports", "cesium", "utils/object-utils", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, object_utils_48, cesium_drawing_utils_5, cesium_utils_12) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPositionMap = void 0;
    Cesium = __importStar(Cesium);
    /**
     * Utility to map an array of positions into IDs while maintaining their order.
     * Allows for adding and removing points at any index.
     * This is useful for managing positions when making editing tools.
     */
    class CesiumPositionMap {
        constructor(positions) {
            this.order = [];
            this.data = {};
            if (positions) {
                for (let i = 0; i < positions.length; i++) {
                    let pos = positions[i];
                    this.Add(pos);
                }
            }
        }
        /**
         * Adds new position at end and returns position reference id.
         * @param position
         * @returns
         */
        Add(position) {
            let id = object_utils_48.ObjectUtils.UID();
            this.data[id] = position;
            this.order.push(id);
            return id;
        }
        /**
         * Updates position value using position reference id.
         * @param id
         * @param position
         */
        Update(id, position) {
            if (this.data[id]) {
                this.data[id] = position;
            }
            else {
                throw ("Cannot update non existant position.");
            }
        }
        /**
         * Updates position value at given index.
         * @param index
         * @param position
         */
        UpdateAtIndex(index, position) {
            let posId = this.order[index];
            if (posId) {
                this.data[posId] = position;
            }
        }
        /**
         * Returns position value using position reference id.
         * @param id
         * @returns
         */
        Get(id) {
            return this.data[id];
        }
        /**
         * Returns all position reference ids.
         * @returns
         */
        GetIds() {
            return Object.keys(this.data);
        }
        /**
         * Adds a new position at a given inde and returns its reference id.
         * @param position
         * @param index
         * @returns
         */
        Insert(position, index) {
            let id = object_utils_48.ObjectUtils.UID();
            this.data[id] = position;
            this.order.splice(index, 0, id);
            return id;
        }
        /**
         * Updates the index of a position using position reference id.
         * @param id
         * @param index
         */
        UpdateIndex(id, index) {
            this.Remove(id);
            this.order.splice(index, 0, id);
        }
        /**
         * Returns position's order index.
         * @param id
         */
        GetIndex(id) {
            return this.order.findIndex(x => x == id);
        }
        /**
         * Removes position using reference id.
         * @param id
         */
        Remove(id) {
            if (this.data[id]) {
                delete this.data[id];
            }
            let index = this.order.findIndex(x => x == id);
            if (index > -1) {
                this.order.splice(index, 1);
            }
        }
        /**
         * Clears all positions from the map.
         */
        Clear() {
            this.order = [];
            this.data = {};
        }
        /**
         * Returns all positions.
         * @param close
         * @returns
         */
        getPositions(close = false) {
            let posses = [];
            for (let i = 0; i < this.order.length; i++) {
                let id = this.order[i];
                posses.push(this.data[id]);
            }
            if (close) {
                posses = cesium_drawing_utils_5.CesiumDrawingUtils.ClosePolygon(posses);
            }
            return posses;
        }
        /**
         * Returns closest insert index for a position.
         * @param position
         * @param closedShape
         * @returns
        */
        GetInsertIndex(position) {
            let distance;
            let index = -1;
            let positions = this.getPositions();
            if (positions) {
                for (let j = 0; j < positions.length; j++) {
                    let pos1 = positions[j];
                    let pos2;
                    let pos2Index = -1;
                    if (j >= positions.length - 1) {
                        pos2 = null;
                        pos2Index = null;
                    }
                    else {
                        pos2 = positions[j + 1];
                        pos2Index = j + 1;
                    }
                    if (cesium_utils_12.CesiumUtils.ValidatePositions([pos1, pos2])) {
                        let length = this.avgDistanceFromPointPair(position, pos1, pos2);
                        if (index == -1 || length < distance) {
                            if (j == 0) {
                                // In the case of 0 index we test if we are closer to line or to index 0.
                                let dot1Dis = this.avgDistanceFromPointPair(position, pos1, pos1);
                                let dot2Dis = this.avgDistanceFromPointPair(position, pos1, pos2);
                                if (dot1Dis <= dot2Dis) {
                                    index = 0;
                                }
                                else {
                                    index = 1;
                                }
                            }
                            else {
                                index = j + 1;
                            }
                            distance = length;
                        }
                    }
                    else if (cesium_utils_12.CesiumUtils.ValidatePositions([pos1])) {
                        let length = this.avgDistanceFromPointPair(position, pos1, pos1);
                        if (index == -1 || length <= distance) {
                            index = j + 1;
                            distance = length;
                        }
                    }
                }
            }
            return index;
        }
        /**
         * Returns distance between point and line.
         * This value is not real, it is only used for internal use.
         * This value does not represent a real amount in any known value type.
         * @param refPoint
         * @param pos1
         * @param pos2
         * @returns
         */
        avgDistanceFromPointPair(refPoint, pos1, pos2) {
            let carto1 = Cesium.Cartographic.fromCartesian(refPoint);
            let carto2 = Cesium.Cartographic.fromCartesian(pos1);
            let carto3 = Cesium.Cartographic.fromCartesian(pos2);
            let x1 = carto1.longitude;
            let y1 = carto1.latitude;
            let x2 = carto2.longitude;
            let y2 = carto2.latitude;
            let x3 = carto3.longitude;
            let y3 = carto3.latitude;
            let A = x1 - x2;
            let B = y1 - y2;
            let C = x3 - x2;
            let D = y3 - y2;
            let dot = A * C + B * D;
            let len_sq = C * C + D * D;
            let param = dot / len_sq;
            let xx;
            let yy;
            if (param < 0 || x2 == x3 && y2 == y3) {
                xx = x2;
                yy = y2;
            }
            else if (param > 1) {
                xx = x3;
                yy = y3;
            }
            else {
                xx = x2 + param * C;
                yy = y2 + param * D;
            }
            let dx = x1 - xx;
            let dy = y1 - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
    }
    exports.CesiumPositionMap = CesiumPositionMap;
});
define("entry-points/cesium/common/cesium-polygon-hierarchy-map", ["require", "exports", "cesium", "bruce-models/common/polygon", "utils/object-utils", "entry-points/cesium/common/cesium-bruce-info-utils", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-position-map", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, polygon_6, object_utils_49, cesium_bruce_info_utils_2, cesium_drawing_utils_6, cesium_position_map_1, cesium_utils_13) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPolygonHierarchyMap = void 0;
    Cesium = __importStar(Cesium);
    class CesiumPolygonHierarchyMap {
        constructor(hierarchy) {
            this.data = {};
            if (hierarchy) {
                this.updateUsingCesiumHierarchy(hierarchy);
            }
        }
        /**
         * Updates the map using given Cesium hierarchy.
         * @param hierarchy
         */
        updateUsingCesiumHierarchy(hierarchy) {
            this.updateOuterUsingCesiumHierarchy(hierarchy);
            if (hierarchy.holes) {
                for (let i = 0; i < hierarchy.holes.length; i++) {
                    let hole = hierarchy.holes[i];
                    let holeId = hole._bruceHierarchyMapRefId;
                    if (!holeId || !this.data[holeId]) {
                        let inPosses = cesium_drawing_utils_6.CesiumDrawingUtils.Unclose(hole.positions);
                        let holePositions = new cesium_position_map_1.CesiumPositionMap(inPosses);
                        let inFacing = {
                            facing: polygon_6.PolygonFacing.in,
                            positions: holePositions
                        };
                        holeId = object_utils_49.ObjectUtils.UID();
                        this.data[holeId] = inFacing;
                        hole._bruceHierarchyMapRefId = holeId;
                    }
                }
            }
        }
        /**
         * Updates the outer map using given Cesium hierarchy.
         * @param hierarchy
         */
        updateOuterUsingCesiumHierarchy(hierarchy) {
            let id = hierarchy._bruceHierarchyMapRefId;
            if (!id || !this.data[id]) {
                let outPosses = cesium_drawing_utils_6.CesiumDrawingUtils.Unclose(hierarchy.positions);
                let positionsMap = new cesium_position_map_1.CesiumPositionMap(outPosses);
                let outFacing = {
                    facing: polygon_6.PolygonFacing.out,
                    positions: positionsMap
                };
                id = object_utils_49.ObjectUtils.UID();
                this.data[id] = outFacing;
                hierarchy._bruceHierarchyMapRefId = id;
            }
        }
        /**
         * Updates the outer map using given cesium polyline.
         * @param viewer
         * @param positions
         */
        updateOuterUsingCesiumPolyline(viewer, entity) {
            let id = entity._bruceHierarchyMapRefId;
            if (!id || !this.data[id]) {
                let positions = cesium_utils_13.CesiumUtils.getCesiumValue(viewer, entity.polyline.positions);
                let outPosses = cesium_drawing_utils_6.CesiumDrawingUtils.Unclose(positions);
                let positionsMap = new cesium_position_map_1.CesiumPositionMap(outPosses);
                let outFacing = {
                    facing: polygon_6.PolygonFacing.out,
                    positions: positionsMap
                };
                id = object_utils_49.ObjectUtils.UID();
                this.data[id] = outFacing;
                entity._bruceHierarchyMapRefId = id;
            }
        }
        /**
         * Updates the inner map using given Cesium entities.
         * @param viewer
         * @param entities
         */
        updateInnerUsingCesiumEntities(viewer, entities) {
            for (let i = 0; i < entities.length; i++) {
                let entity = entities[i];
                let polyline = entity === null || entity === void 0 ? void 0 : entity.polyline;
                if (polyline) {
                    let holeId = entity._bruceHierarchyMapRefId;
                    if (!holeId || !this.data[holeId]) {
                        let positions = cesium_utils_13.CesiumUtils.getCesiumValue(viewer, polyline.positions);
                        let inPosses = cesium_drawing_utils_6.CesiumDrawingUtils.Unclose(positions);
                        let inFacing = {
                            facing: polygon_6.PolygonFacing.in,
                            positions: new cesium_position_map_1.CesiumPositionMap(inPosses)
                        };
                        holeId = object_utils_49.ObjectUtils.UID();
                        this.data[holeId] = inFacing;
                        entity._bruceHierarchyMapRefId = holeId;
                    }
                }
            }
        }
        /**
         * Updates the inner and outer maps using given Bruce polygon.
         * @param polygon
         */
        updateUsingPolygon(polygon) {
            for (let i = 0; i < polygon.length; i++) {
                let piece = polygon[i];
                let cartos = piece.getParsedCartographicPositions();
                let posses = cesium_utils_13.CesiumUtils.ICartographicArrayToCartesian3(cartos);
                posses = cesium_drawing_utils_6.CesiumDrawingUtils.Unclose(posses);
                let possesMap = new cesium_position_map_1.CesiumPositionMap(posses);
                let facingMap = {
                    facing: piece.Facing,
                    positions: possesMap
                };
                let id = object_utils_49.ObjectUtils.UID();
                this.data[id] = facingMap;
            }
        }
        /**
         * Removes hierarchy branch using hierarchy reference id.
         * @param hierarchyId
         */
        RemoveHierarchyBranch(hierarchyId) {
            if (this.data[hierarchyId]) {
                delete this.data[hierarchyId];
            }
        }
        /**
         * Clears all mapped hierarchies.
         */
        Clear() {
            this.data = {};
        }
        /**
         * Clears all inner facing maps.
         */
        ClearInner() {
            let ids = this.GetMapIds();
            for (let i = 0; i < ids.length; i++) {
                let id = ids[i];
                let map = this.data[id];
                if (map.facing == polygon_6.PolygonFacing.in) {
                    delete this.data[id];
                }
            }
        }
        /**
         * @param hierarchyId
         * @returns positions map for a given hierarchy refererence id.
         */
        GetPositionsMap(hierarchyId) {
            let hierarchy = this.data[hierarchyId];
            return hierarchy === null || hierarchy === void 0 ? void 0 : hierarchy.positions;
        }
        /**
         * Returns hierarchy map by hierarchy id.
         * @param hierarchyId
         */
        GetMap(hierarchyId) {
            return this.data[hierarchyId];
        }
        /**
         * @returns all hierarchy map ids.
         */
        GetMapIds() {
            return Object.keys(this.data);
        }
        /**
         * @returns all hierarchy map ids excluding outer ring.
         */
        GetInnerMapIds() {
            let outerId = this.GetOutMapId();
            return Object.keys(this.data).filter(x => x != outerId);
        }
        /**
         * @returns all position ids from all positions maps.
         */
        GetAllPositionIds() {
            let ids = [];
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                let map = this.data[key];
                ids = ids.concat(map.positions.GetIds());
            }
            return ids;
        }
        /**
         * @returns all position ids from all position maps grouped by hierarchy id.
         */
        GetAllPositionIdsWithHierarchyId() {
            let ids = [];
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                let map = this.data[key];
                ids = ids.concat({ hierarchyId: key, positionIds: map.positions.GetIds(), facing: map.facing });
            }
            return ids;
        }
        /**
         * @returns all position maps.
         */
        GetMaps() {
            let maps = [];
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                let map = this.data[key];
                maps = maps.concat({ hierarchyId: key, positions: map.positions, facing: map.facing });
            }
            return maps;
        }
        /**
         * @param posId
         * @returns position value by given position reference id.
         */
        GetPositionById(posId) {
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                let map = this.data[key];
                let pos = map.positions.Get(posId);
                if (pos) {
                    return pos;
                }
            }
            return null;
        }
        /**
         * Constructs Cesium polygon hierarchy from current state of map.
         * @returns
         */
        ConstructCesiumHierarchy() {
            let hierarchy = new Cesium.PolygonHierarchy([], []);
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let branch = this.data[keys[i]];
                if (branch.positions.GetIds().length > 0) {
                    if (branch.facing == "out") {
                        hierarchy.positions = branch.positions.getPositions(true);
                    }
                    else {
                        hierarchy.holes.push(new Cesium.PolygonHierarchy(branch.positions.getPositions(true), []));
                    }
                }
            }
            return hierarchy;
        }
        /**
         * Constructs and returns Bruce polygon geometry from current state of map.
         */
        ConstructBrucePolygon() {
            let polygon = [];
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let map = this.data[keys[i]];
                let positions = map.positions.getPositions(true);
                if (positions.length > 0) {
                    /*
                    let cartos: Cesium.Cartographic[] = [];
                    for (let j = 0; j < positions.length; j++)
                    {
                        let carto = Cesium.Cartographic.fromCartesian(positions[j]);
                        carto = CesiumUtils.toDegrees(carto);
                        cartos.push(carto);
                    }
                    let part = new Polygon(null);
                    part.Facing = map.facing;
                    part.LinearRing = Geometry.LineStringFromCartographicPoints(<ICartographic[]><any>cartos);
                    polygon.push(part);
                    */
                    let part = new polygon_6.Polygon(null);
                    part.Facing = map.facing;
                    part.LinearRing = cesium_bruce_info_utils_2.CesiumBruceInfoUtils.PolylineGeometryFromCartesianArray(positions);
                    polygon.push(part);
                }
            }
            return polygon;
        }
        /**
         * Adds new branch to the map.
         * @param facing
         * @returns hierarchy reference id.
         */
        AddMap(facing) {
            let id = object_utils_49.ObjectUtils.UID();
            this.data[id] =
                {
                    facing: facing,
                    positions: new cesium_position_map_1.CesiumPositionMap()
                };
            return id;
        }
        /**
         * @returns the outer facing hierarchy positions map.
         */
        GetOutMap() {
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                let map = this.data[key];
                if (map.facing == polygon_6.PolygonFacing.out) {
                    return map.positions;
                }
            }
            return null;
        }
        /**
         * @returns the outer facing hierarchy reference id.
         */
        GetOutMapId() {
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                let map = this.data[key];
                if (map.facing == polygon_6.PolygonFacing.out) {
                    return key;
                }
            }
            return null;
        }
        /**
         * @returns: all inner facing position maps.
         */
        GetInnerMaps() {
            let maps = [];
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                let map = this.data[key];
                if (map.facing == polygon_6.PolygonFacing.in) {
                    maps.push(map.positions);
                }
            }
            return maps;
        }
        /**
         * @returns if the outer facing hierarchy exists.
         */
        GetOutExists() {
            let keys = Object.keys(this.data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                let map = this.data[key];
                if (map.facing == polygon_6.PolygonFacing.out) {
                    return true;
                }
            }
            return false;
        }
        /**
         * Returns map id for map that has less than 3 positions.
         */
        GetUnfinishedMapId() {
            let mapped = this.GetAllPositionIdsWithHierarchyId();
            for (let i = 0; i < mapped.length; i++) {
                let map = mapped[i];
                if (map.positionIds.length < 3) {
                    return map.hierarchyId;
                }
            }
            return null;
        }
        /**
         * Returns inner map that has less than 3 positions.
         */
        GetUnfinishedHoleId() {
            let mapped = this.GetAllPositionIdsWithHierarchyId();
            for (let i = 0; i < mapped.length; i++) {
                let map = mapped[i];
                if (map.facing == polygon_6.PolygonFacing.in && map.positionIds.length < 3) {
                    return map.hierarchyId;
                }
            }
            return null;
        }
        GetClosestHoleId(position, onlyFinished) {
            let closestDistance;
            let closestMapId;
            let mapIds = this.GetMapIds();
            for (let i = 0; i < mapIds.length; i++) {
                let mapId = mapIds[i];
                let map = this.GetMap(mapId);
                if (map.facing == polygon_6.PolygonFacing.in) {
                    let positions = map.positions.getPositions();
                    if (positions && (!onlyFinished || positions.length > 2)) {
                        for (let j = 0; j < positions.length; j++) {
                            let pos1 = positions[j];
                            let pos2;
                            let pos2Index = -1;
                            if (j >= positions.length - 1) {
                                pos2 = positions[0];
                                pos2Index = 0;
                            }
                            else {
                                pos2 = positions[j + 1];
                                pos2Index = j + 1;
                            }
                            if (cesium_utils_13.CesiumUtils.ValidatePositions([pos1, pos2])) {
                                let length = this.avgDistanceFromPointPair(position, pos1, pos2);
                                if (!closestMapId || length < closestDistance) {
                                    closestMapId = mapId;
                                    closestDistance = length;
                                }
                            }
                        }
                    }
                }
            }
            return closestMapId;
        }
        /**
         * Returns closest insert index for a position in a given hierarchy.
         * @param position
         * @returns
         */
        GetInsertIndex(hierarchyId, position) {
            let distance;
            let index = -1;
            let map = this.data[hierarchyId];
            if (map) {
                let positions = map.positions.getPositions();
                if (positions) {
                    for (let j = 0; j < positions.length; j++) {
                        let pos1 = positions[j];
                        let pos2;
                        let pos2Index = -1;
                        if (j >= positions.length - 1) {
                            pos2 = positions[0];
                            pos2Index = 0;
                        }
                        else {
                            pos2 = positions[j + 1];
                            pos2Index = j + 1;
                        }
                        if (cesium_utils_13.CesiumUtils.ValidatePositions([pos1, pos2])) {
                            let length = this.avgDistanceFromPointPair(position, pos1, pos2);
                            if (index == -1 || length < distance) {
                                let insertIndex = pos2Index == 0 ? 0 : j > pos2Index ? j : pos2Index;
                                index = insertIndex;
                                distance = length;
                            }
                        }
                    }
                }
            }
            return index;
        }
        /**
         * Returns distance between point and line.
         * This value is not real, it is only used for internal use.
         * This value does not represent a real amount in any known value type.
         * @param refPoint
         * @param pos1
         * @param pos2
         * @returns
         */
        avgDistanceFromPointPair(refPoint, pos1, pos2) {
            let carto1 = Cesium.Cartographic.fromCartesian(refPoint);
            let carto2 = Cesium.Cartographic.fromCartesian(pos1);
            let carto3 = Cesium.Cartographic.fromCartesian(pos2);
            let x1 = carto1.longitude;
            let y1 = carto1.latitude;
            let x2 = carto2.longitude;
            let y2 = carto2.latitude;
            let x3 = carto3.longitude;
            let y3 = carto3.latitude;
            let A = x1 - x2;
            let B = y1 - y2;
            let C = x3 - x2;
            let D = y3 - y2;
            let dot = A * C + B * D;
            let len_sq = C * C + D * D;
            let param = dot / len_sq;
            let xx;
            let yy;
            if (param < 0 || x2 == x3 && y2 == y3) {
                xx = x2;
                yy = y2;
            }
            else if (param > 1) {
                xx = x3;
                yy = y3;
            }
            else {
                xx = x2 + param * C;
                yy = y2 + param * D;
            }
            let dx = x1 - xx;
            let dy = y1 - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
    }
    exports.CesiumPolygonHierarchyMap = CesiumPolygonHierarchyMap;
});
define("entry-points/cesium/common/cesium-geometry-editor-point", ["require", "exports", "cesium", "utils/object-utils", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, object_utils_50, cesium_utils_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumGeometryEditorPoint = void 0;
    Cesium = __importStar(Cesium);
    class CesiumGeometryEditorPoint {
        constructor(params) {
            // If this editor is active.
            this._active = false;
            // Height reference to apply to the point entity.
            this.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
            // Reference to the editor Cesium entities.
            this._entities = [];
            // The last retrieved 3D position.
            this._lastPosition = new Cesium.Cartesian3();
            this._posId = params.posId;
            this.positionCallback = params.getPosition;
            this.updatePositionCallback = params.updatePosition;
            this.showCallback = params.showCallback;
            this.viewer = params.viewer;
            if (params.heightReference != null) {
                this.heightReference = params.heightReference;
            }
            this.color = params.color;
            this.pixelSize = params.pixelSize;
        }
        get posId() {
            return this._posId;
        }
        get active() {
            return this._active;
        }
        get entities() {
            return this._entities;
        }
        get lastPosition() {
            return this._lastPosition;
        }
        /**
         * Creates the editor Cesium entity.
         */
        CreateEntity() {
            if (this._entities.length <= 0) {
                let pointEntity = new Cesium.Entity({
                    id: object_utils_50.ObjectUtils.taggedUID("EDITOR_POINT"),
                    point: {
                        color: this.color ? cesium_utils_14.CesiumUtils.ColorToCesiumColor(this.color) : Cesium.Color.WHITE,
                        pixelSize: this.pixelSize ? this.pixelSize : 8,
                        scaleByDistance: new Cesium.NearFarScalar(1.5e2, 1, 8.0e6, 0.0),
                        heightReference: this.heightReference,
                        show: new Cesium.CallbackProperty(() => {
                            if (this.showCallback) {
                                return this.showCallback();
                            }
                            else {
                                return true;
                            }
                        }, false)
                    },
                    position: new Cesium.CallbackProperty(() => this.getPosition(), false)
                });
                pointEntity._cesiumGeometryEditorPointId = this.posId;
                this.viewer.entities.add(pointEntity);
                this._entities.push(pointEntity);
                this.viewer.scene.requestRender();
                this._active = true;
            }
        }
        /**
         * Retrieves the editor's position.
         * @returns
         */
        getPosition() {
            let updatedPos = this.positionCallback();
            if (cesium_utils_14.CesiumUtils.ValidatePosition(updatedPos)) {
                this._lastPosition = updatedPos;
            }
            return this._lastPosition;
        }
        /**
         * Notifies callback to update the editor position.
         * @param pos
         */
        updatePosition(pos) {
            this.updatePositionCallback(pos);
        }
        /**
         * Removes the editor point.
         */
        DestroyEntity() {
            if (this._entities.length > 0) {
                for (let i = 0; i < this._entities.length; i++) {
                    this.viewer.entities.remove(this._entities[i]);
                }
                this._entities = [];
                this.viewer.scene.requestRender();
                this._active = false;
            }
        }
    }
    exports.CesiumGeometryEditorPoint = CesiumGeometryEditorPoint;
});
define("entry-points/cesium/common/cesium-polygon-geometry-editor", ["require", "exports", "cesium", "bruce-models/common/line", "bruce-models/common/polygon", "utils/delay-queue", "utils/drawing-utils", "entry-points/cesium/common/cesium-cached-picking-height-util", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-entity-utils", "entry-points/cesium/common/cesium-geometry-editor-point", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-polygon-hierarchy-map", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, line_1, polygon_7, delay_queue_2, drawing_utils_2, cesium_cached_picking_height_util_2, cesium_drawing_utils_7, cesium_entity_utils_7, cesium_geometry_editor_point_1, cesium_mouse_events_2, cesium_polygon_hierarchy_map_1, cesium_utils_15) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPolygonGeometryEditor = void 0;
    Cesium = __importStar(Cesium);
    class CesiumGeometryPolygonEditorPoint extends cesium_geometry_editor_point_1.CesiumGeometryEditorPoint {
        constructor(posId, getPosition, showCallback, updatePosition, viewer, hierarchyId, isOuter) {
            super({
                posId: posId,
                getPosition: getPosition,
                showCallback: showCallback,
                updatePosition: updatePosition,
                viewer: viewer
            });
            this.hierarchyId = hierarchyId;
            this.isOuter = isOuter;
        }
    }
    /**
     * Helper class for editing Cesium Polygon entities.
     * Instantiate with an entity that has Polygon geometry and call 'Start' method.
     */
    class CesiumPolygonGeometryEditor {
        constructor(viewer, entity, params) {
            // If the editor has been disposed.
            this._disposed = false;
            // Editor points created for map positions.
            this.editorPoints = [];
            // Clicked offset from the editor point's center point.
            this.mouseOffset = new Cesium.Cartesian2(0, 0);
            // If only editing of inner points is allowed.
            this.outerLocked = false;
            this.viewer = viewer;
            this._entity = entity;
            this.mappedHierarchy = new cesium_polygon_hierarchy_map_1.CesiumPolygonHierarchyMap();
            this.params = params;
            this.updateQueue = new delay_queue_2.DelayQueue(() => {
                this.updateGeometry();
            }, 50);
            this.heightSampler = new cesium_cached_picking_height_util_2.CesiumCachedPickingHeightUtil(this.viewer.CesiumViewer);
        }
        get disposed() {
            return this._disposed;
        }
        get entity() {
            return this._entity;
        }
        get active() {
            return this._active;
        }
        /**
         * Attempts to construct needed styling params for the editor from a given entity.
         * @param viewer
         * @param entity
         */
        static ConstructParamsFromEntity(viewer, entity) {
            let outlineColor = null;
            let outlineWidth = null;
            let entities = cesium_entity_utils_7.CesiumEntityUtils.getAllEntities(entity);
            let inner = entities.find(x => cesium_entity_utils_7.CesiumEntityUtils.isInnerEntity(x));
            if (inner) {
                if (inner.polyline) {
                    outlineColor = cesium_utils_15.CesiumUtils.getCesiumValue(viewer, inner.polyline.material);
                    outlineWidth = cesium_utils_15.CesiumUtils.getCesiumValue(viewer, inner.polyline.width);
                }
            }
            if (outlineWidth || outlineColor) {
                let params = {
                    outlineColor: outlineColor,
                    outlineWidth: outlineWidth
                };
                return params;
            }
            return null;
        }
        /**
         * Starts listening for Cesium mouse events.
         */
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_2.CesiumMouseEvents(this.viewer.CesiumViewer);
                this.mouseHandler.LeftDownEvent.Subscribe((data) => {
                    this.doLeftDown(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.LeftUpEvent.Subscribe((data) => {
                    this.doLeftUp();
                });
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.RightClickEvent.Subscribe((data) => {
                    this.doMouseRightClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.MiddleClickEvent.Subscribe((data) => {
                    this.doMiddleClick(data.position);
                });
                this.mouseHandler.EnableEventHandling();
            }
        }
        /**
         * Returns editing point from this editor from given screen position.
         * @param screenPos
         * @returns
         */
        getEditorPointFromMouse(screenPos) {
            if (cesium_utils_15.CesiumUtils.Validate2DPosition(screenPos)) {
                let viewer = this.viewer.CesiumViewer;
                let pickedObjects = viewer.scene.drillPick(screenPos, 5);
                for (let i = 0; i < pickedObjects.length; i++) {
                    let pickedObject = pickedObjects[i];
                    if (pickedObject.id instanceof Cesium.Entity) {
                        pickedObject = pickedObject.id;
                    }
                    if (pickedObject && pickedObject._cesiumGeometryEditorPointId) {
                        let point = this.editorPoints.find(x => x.posId == pickedObject._cesiumGeometryEditorPointId);
                        if (point) {
                            return point;
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Handles left mouse down event for given screen position.
         * @param screenPos
         */
        doLeftDown(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.activePoint = point;
                    this.updateOffset(screenPos);
                    this.setGrabCursor();
                    this.viewer.cameraHandler.isFrozen = true;
                }
            }
        }
        /**
         * Updates the clicked offset from the entity's position.
         * @param screenPos
         */
        updateOffset(screenPos) {
            if (this.activePoint) {
                let position = this.activePoint.lastPosition;
                let grounded = Cesium.Cartographic.fromCartesian(position);
                let height = this.heightSampler.Pick(grounded);
                position = Cesium.Cartesian3.fromRadians(grounded.longitude, grounded.latitude, height);
                if (cesium_utils_15.CesiumUtils.ValidatePosition(position)) {
                    let entityScreenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.CesiumViewer.scene, position);
                    if (cesium_utils_15.CesiumUtils.Validate2DPosition(entityScreenPos)) {
                        this.mouseOffset.x = entityScreenPos.x - screenPos.x;
                        this.mouseOffset.y = entityScreenPos.y - screenPos.y;
                    }
                }
            }
        }
        /**
         * Handles mouse click event for given screen position.
         * @param screenPos
         */
        doClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = cesium_drawing_utils_7.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer.CesiumViewer, screenPos);
                    if (cesium_utils_15.CesiumUtils.ValidatePosition(pos3d)) {
                        this.addPosition(pos3d);
                    }
                }
            }
        }
        /**
         * Adds point to the map.
         * Point will be added to the closest point branch.
         * If no closest branch is found then it will be added to outer branch.
         * @param position
         */
        addPosition(position) {
            let unfinished = this.mappedHierarchy.GetUnfinishedMapId();
            if (unfinished) {
                this.createAndRegisterEditorPoint(unfinished, position);
            }
            else {
                let excluded = [];
                if (this.outerLocked) {
                    if (this.isWithinOuter(position)) {
                        let outerId = this.mappedHierarchy.GetOutMapId();
                        if (outerId) {
                            excluded.push(outerId);
                        }
                    }
                    else {
                        return;
                    }
                }
                let shortest = this.getInsertPositionInfo(position, excluded);
                if (shortest) {
                    this.createAndRegisterEditorPoint(shortest.hierarchyId, position, shortest.insertIndex);
                }
                else if (this.outerLocked) {
                    this.createNewBranch(polygon_7.PolygonFacing.in, position);
                }
                else {
                    let outMapId = this.mappedHierarchy.GetOutMapId();
                    if (outMapId) {
                        this.createAndRegisterEditorPoint(outMapId, position);
                    }
                    else {
                        this.createNewBranch(polygon_7.PolygonFacing.out, position);
                    }
                }
            }
        }
        /**
         * Returns information about the closest position insert for a given point.
         * @param position
         * @returns
         */
        getInsertPositionInfo(position, excludingHierarchyIds = []) {
            let shortest;
            let branches = this.mappedHierarchy.GetAllPositionIdsWithHierarchyId();
            for (let i = 0; i < branches.length; i++) {
                let branch = branches[i];
                let map = this.mappedHierarchy.GetPositionsMap(branch.hierarchyId);
                if (excludingHierarchyIds.includes(branch.hierarchyId)) {
                    continue;
                }
                let positions = map.getPositions();
                for (let j = 0; j < positions.length; j++) {
                    let pos1 = positions[j];
                    let pos2;
                    let pos2Index = -1;
                    if (j >= positions.length - 1) {
                        pos2 = positions[0];
                        pos2Index = 0;
                    }
                    else {
                        pos2 = positions[j + 1];
                        pos2Index = j + 1;
                    }
                    if (cesium_utils_15.CesiumUtils.ValidatePositions([pos1, pos2])) {
                        let length = this.avgDistanceFromPointPair(position, pos1, pos2);
                        if (!shortest || shortest.length > length) {
                            let insertIndex = pos2Index == 0 ? 0 : j > pos2Index ? j : pos2Index;
                            shortest =
                                {
                                    insertIndex: insertIndex,
                                    length: length,
                                    hierarchyId: branch.hierarchyId,
                                    pos1,
                                    pos2
                                };
                        }
                    }
                }
            }
            return shortest;
        }
        /**
         * Returns distance between point and line.
         * This value is not real, it is only used for internal use in this editor.
         * This value does not represent a real amount in any known value type.
         * @param refPoint
         * @param pos1
         * @param pos2
         * @returns
         */
        avgDistanceFromPointPair(refPoint, pos1, pos2) {
            let carto1 = Cesium.Cartographic.fromCartesian(refPoint);
            let carto2 = Cesium.Cartographic.fromCartesian(pos1);
            let carto3 = Cesium.Cartographic.fromCartesian(pos2);
            let x1 = carto1.longitude;
            let y1 = carto1.latitude;
            let x2 = carto2.longitude;
            let y2 = carto2.latitude;
            let x3 = carto3.longitude;
            let y3 = carto3.latitude;
            let A = x1 - x2;
            let B = y1 - y2;
            let C = x3 - x2;
            let D = y3 - y2;
            let dot = A * C + B * D;
            let len_sq = C * C + D * D;
            let param = dot / len_sq;
            let xx;
            let yy;
            if (param < 0 || x2 == x3 && y2 == y3) {
                xx = x2;
                yy = y2;
            }
            else if (param > 1) {
                xx = x3;
                yy = y3;
            }
            else {
                xx = x2 + param * C;
                yy = y2 + param * D;
            }
            let dx = x1 - xx;
            let dy = y1 - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        /**
         * Returns x,y position from 3d position.
         * @param pos
         */
        getPointFromPos(pos) {
            let carto = Cesium.Cartographic.fromCartesian(pos);
            return { x: carto.longitude, y: carto.latitude };
        }
        /**
         * Handles middle mouse click at a given screen position.
         * For this to pass the position has to be within outer branch and outer branch has to have at least 3 positions.
         * @param screenPos
         */
        doMiddleClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = cesium_drawing_utils_7.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer.CesiumViewer, screenPos);
                    if (cesium_utils_15.CesiumUtils.ValidatePosition(pos3d)) {
                        let outMap = this.mappedHierarchy.GetOutMap();
                        let posIds = outMap ? outMap.GetIds() : [];
                        if (posIds.length >= 3) {
                            // Let's not check it's within outer ring and outside inner rings.
                            if (this.isWithinOuter(pos3d) && this.isOutsideInners(pos3d)) {
                                this.createNewBranch(polygon_7.PolygonFacing.in, pos3d);
                            }
                        }
                    }
                }
            }
        }
        /**
         * Returns if given position is within outer polygon branch.
         * @param position
         */
        isWithinOuter(position) {
            let outMap = this.mappedHierarchy.GetOutMap();
            if (!outMap) {
                return false;
            }
            let cartos = cesium_utils_15.CesiumUtils.toRadiansCartographicArray(outMap.getPositions());
            let carto = cesium_utils_15.CesiumUtils.toRadiansCartographic(position);
            return cesium_utils_15.CesiumUtils.getIsPointInPolygon(cartos, carto);
        }
        /**
         * Returns if given position is outside inner polygon branches.
         * @param position
         * @param excludingHierarchyIds
         */
        isOutsideInners(position, excludingHierarchyIds = []) {
            let outerMapId = this.mappedHierarchy.GetOutMapId();
            let maps = this.mappedHierarchy.GetAllPositionIdsWithHierarchyId();
            for (let i = 0; i < maps.length; i++) {
                let mapId = maps[i].hierarchyId;
                if (mapId != outerMapId && (excludingHierarchyIds.length <= 0 || !excludingHierarchyIds.includes(mapId))) {
                    let map = this.mappedHierarchy.GetPositionsMap(mapId);
                    let posses = map.getPositions();
                    let cartos = cesium_utils_15.CesiumUtils.toRadiansCartographicArray(posses);
                    let carto = cesium_utils_15.CesiumUtils.toRadiansCartographic(position);
                    if (cesium_utils_15.CesiumUtils.getIsPointInPolygon(cartos, carto)) {
                        return false;
                    }
                }
            }
            return true;
        }
        /**
         * Creates a new branch with a given starting position.
         * @param startingPosition
         */
        createNewBranch(facing, startingPosition) {
            let mapId = this.mappedHierarchy.AddMap(facing);
            this.createAndRegisterEditorPoint(mapId, startingPosition);
        }
        /**
         * Handles left mouse up event.
         */
        doLeftUp() {
            if (this.activePoint) {
                this.activePoint = null;
                this.viewer.cameraHandler.isFrozen = false;
            }
        }
        /**
         * Handles mouse movement event at a given screen position.
         * @param screenPos
         */
        doMouseMove(screenPos) {
            let updatePos = true;
            if (cesium_utils_15.CesiumUtils.Validate2DPosition(screenPos)) {
                screenPos.x += this.mouseOffset.x;
                screenPos.y += this.mouseOffset.y;
                let pos3d = cesium_drawing_utils_7.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer.CesiumViewer, screenPos);
                if (cesium_utils_15.CesiumUtils.ValidatePosition(pos3d)) {
                    this.lastCursorPos = pos3d;
                    if (this.activePoint) {
                        updatePos = false;
                        this.activePoint.updatePosition(pos3d);
                        this.fixLeakingPoints();
                        this.updateQueue.Call(false);
                    }
                }
            }
            if (updatePos) {
                this.setPointerCursor(screenPos);
            }
        }
        /**
         * Runs through all points and makes sure they aren't inside other branch polygons.
         * Checks if all inner points are within the outer ring.
         * Any found leaked points will be moved.
         */
        fixLeakingPoints() {
            let outerId = this.mappedHierarchy.GetOutMapId();
            let maps = this.mappedHierarchy.GetAllPositionIdsWithHierarchyId();
            for (let i = 0; i < maps.length; i++) {
                let id = maps[i].hierarchyId;
                if (id != outerId) {
                    let map = this.mappedHierarchy.GetPositionsMap(id);
                    let posses = map.getPositions();
                    for (let j = 0; j < posses.length; j++) {
                        let pos = posses[j];
                        if (posses.length > 1) {
                            let prevPoint = j == 0 ? posses[posses.length - 1] : posses[j - 1];
                            let nextPoint = j >= posses.length - 1 ? posses[0] : posses[j + 1];
                            let leakCount = 0;
                            if (!this.isWithinOuter(pos) || !this.isOutsideInners(pos, [id])) {
                                leakCount += 1;
                            }
                            if (!this.isWithinOuter(prevPoint) || !this.isOutsideInners(prevPoint, [id])) {
                                leakCount += 1;
                            }
                            if (!this.isWithinOuter(nextPoint) || !this.isOutsideInners(nextPoint, [id])) {
                                leakCount += 1;
                            }
                            if (leakCount <= 1) {
                                let intersectionPos = this.findClosestDoubleIntersection(id, [prevPoint, pos, nextPoint]);
                                if (cesium_utils_15.CesiumUtils.ValidatePosition(intersectionPos)) {
                                    map.UpdateAtIndex(j, intersectionPos);
                                    continue;
                                }
                            }
                            else if (leakCount > 1) {
                                let intersectionPos = this.findSingleIntersection(id, [prevPoint, pos, nextPoint]);
                                if (cesium_utils_15.CesiumUtils.ValidatePosition(intersectionPos)) {
                                    map.UpdateAtIndex(j, intersectionPos);
                                    continue;
                                }
                            }
                        }
                    }
                }
            }
        }
        /**
         * Finds two intersecting lines from a given triangle and returns closest position for pointer to be without intersections.
         * @param mapId
         * @param posses[] // The triangle, pointer at index 1.
         */
        findClosestDoubleIntersection(mapId, posses) {
            if (!cesium_utils_15.CesiumUtils.ValidatePositions(posses)) {
                return null;
            }
            let intPos1;
            let intPos2;
            let maps = this.mappedHierarchy.GetMaps();
            for (let i = 0; i < 2; i++) {
                let pos1;
                let pos2;
                if (i == 0) {
                    pos1 = posses[0];
                }
                else if (i == 1) {
                    pos1 = posses[2];
                }
                pos2 = posses[1];
                let carto1 = Cesium.Cartographic.fromCartesian(pos1);
                let carto2 = Cesium.Cartographic.fromCartesian(pos2);
                let line1 = {
                    start: {
                        x: carto1.longitude,
                        y: carto1.latitude
                    },
                    end: {
                        x: carto2.longitude,
                        y: carto2.latitude
                    }
                };
                let lineInt;
                let lineIntDistance;
                for (let j = 0; j < maps.length; j++) {
                    let testMap = maps[j];
                    if (testMap.hierarchyId == mapId) {
                        continue;
                    }
                    let testPosses = testMap.positions.getPositions(true);
                    for (let k = 0; k < testPosses.length; k++) {
                        let testPos1 = testPosses[k];
                        let testPos2 = testPosses[k + 1];
                        if (testPos2 == null) {
                            break;
                        }
                        let carto1 = Cesium.Cartographic.fromCartesian(testPos1);
                        let carto2 = Cesium.Cartographic.fromCartesian(testPos2);
                        let line2 = {
                            start: {
                                x: carto1.longitude,
                                y: carto1.latitude
                            },
                            end: {
                                x: carto2.longitude,
                                y: carto2.latitude
                            }
                        };
                        if (drawing_utils_2.DrawingUtils.GetIfLinesIntersect(line1, line2)) {
                            let eq1 = drawing_utils_2.DrawingUtils.GetEquationFromLine(line1);
                            let eq2 = drawing_utils_2.DrawingUtils.GetEquationFromLine(line2);
                            let intersection = drawing_utils_2.DrawingUtils.GetLineIntersection(eq1, eq2);
                            if (cesium_utils_15.CesiumUtils.Validate2DPosition(intersection)) {
                                let tmpPos = Cesium.Cartesian3.fromRadians(intersection.x, intersection.y, carto1.height);
                                if (!lineInt) {
                                    lineInt = tmpPos;
                                    lineIntDistance = Cesium.Cartesian3.distance(pos1, tmpPos);
                                }
                                else {
                                    let distance = Cesium.Cartesian3.distance(pos1, tmpPos);
                                    if (distance < lineIntDistance) {
                                        lineIntDistance = distance;
                                        lineInt = tmpPos;
                                    }
                                }
                            }
                        }
                    }
                }
                if (lineInt) {
                    if (i == 0) {
                        intPos1 = lineInt;
                    }
                    else {
                        intPos2 = lineInt;
                    }
                }
                else {
                    return null;
                }
            }
            if (cesium_utils_15.CesiumUtils.ValidatePositions([intPos1, intPos2])) {
                let line = line_1.Line2D.LineFromPoints(this.getPointFromPos(intPos1), this.getPointFromPos(intPos2));
                let point = this.getPointFromPos(posses[1]);
                let closest = drawing_utils_2.DrawingUtils.GetClosestPointToLine(line, point);
                let carto = Cesium.Cartographic.fromCartesian(posses[1]);
                let pos = Cesium.Cartesian3.fromRadians(closest.x, closest.y, carto.height);
                let bearing = drawing_utils_2.DrawingUtils.GetLineBearingInDegrees(line_1.Line2D.LineFromPoints(this.getPointFromPos(pos), this.getPointFromPos(posses[1])));
                carto = cesium_utils_15.CesiumUtils.toCartographic(pos);
                let newPos = cesium_drawing_utils_7.CesiumDrawingUtils.OffsetPoint(carto, -0.3, bearing);
                let cartesian = Cesium.Cartesian3.fromDegrees(newPos.longitude, newPos.latitude, newPos.height);
                return cartesian;
            }
            else {
                return null;
            }
        }
        /**
         * Finds one intersecting line from a given triangle and returns it.
         * If multiple intersections are found from two different lines in the triangle, nothing is returned.
         * If multiple intersections are found from one line in the triangle, the closest intersection is returned.
         * @param mapId
         * @param posses
         * @returns
         */
        findSingleIntersection(mapId, posses) {
            if (!cesium_utils_15.CesiumUtils.ValidatePositions(posses)) {
                return null;
            }
            let intPos1;
            let intPos2;
            let maps = this.mappedHierarchy.GetMaps();
            for (let i = 0; i < 2; i++) {
                let pos1;
                let pos2;
                if (i == 0) {
                    pos1 = posses[0];
                }
                else if (i == 1) {
                    pos1 = posses[2];
                }
                pos2 = posses[1];
                let carto1 = Cesium.Cartographic.fromCartesian(pos1);
                let carto2 = Cesium.Cartographic.fromCartesian(pos2);
                let line1 = {
                    start: {
                        x: carto1.longitude,
                        y: carto1.latitude
                    },
                    end: {
                        x: carto2.longitude,
                        y: carto2.latitude
                    }
                };
                let lineInt;
                let lineIntDistance;
                for (let j = 0; j < maps.length; j++) {
                    let testMap = maps[j];
                    if (testMap.hierarchyId == mapId) {
                        continue;
                    }
                    let testPosses = testMap.positions.getPositions(true);
                    for (let k = 0; k < testPosses.length; k++) {
                        let testPos1 = testPosses[k];
                        let testPos2 = testPosses[k + 1];
                        if (testPos2 == null) {
                            break;
                        }
                        let carto1 = Cesium.Cartographic.fromCartesian(testPos1);
                        let carto2 = Cesium.Cartographic.fromCartesian(testPos2);
                        let line2 = {
                            start: {
                                x: carto1.longitude,
                                y: carto1.latitude
                            },
                            end: {
                                x: carto2.longitude,
                                y: carto2.latitude
                            }
                        };
                        if (drawing_utils_2.DrawingUtils.GetIfLinesIntersect(line1, line2)) {
                            let eq1 = drawing_utils_2.DrawingUtils.GetEquationFromLine(line1);
                            let eq2 = drawing_utils_2.DrawingUtils.GetEquationFromLine(line2);
                            let intersection = drawing_utils_2.DrawingUtils.GetLineIntersection(eq1, eq2);
                            if (cesium_utils_15.CesiumUtils.Validate2DPosition(intersection)) {
                                let tmpPos = Cesium.Cartesian3.fromRadians(intersection.x, intersection.y, carto1.height);
                                if (!lineInt) {
                                    lineInt = tmpPos;
                                    lineIntDistance = Cesium.Cartesian3.distance(pos1, tmpPos);
                                }
                                else {
                                    let distance = Cesium.Cartesian3.distance(pos1, tmpPos);
                                    if (distance < lineIntDistance) {
                                        lineIntDistance = distance;
                                        lineInt = tmpPos;
                                    }
                                }
                            }
                        }
                    }
                }
                if (lineInt) {
                    if (i == 0) {
                        intPos1 = lineInt;
                    }
                    else {
                        intPos2 = lineInt;
                    }
                }
            }
            if (cesium_utils_15.CesiumUtils.ValidatePositions([intPos1, intPos2])) {
                return null;
            }
            let pos;
            if (intPos1) {
                pos = intPos1;
            }
            else {
                pos = intPos2;
            }
            if (!pos) {
                return null;
            }
            let bearing = drawing_utils_2.DrawingUtils.GetLineBearingInDegrees(line_1.Line2D.LineFromPoints(this.getPointFromPos(pos), this.getPointFromPos(posses[1])));
            let carto = cesium_utils_15.CesiumUtils.toCartographic(pos);
            let newPos = cesium_drawing_utils_7.CesiumDrawingUtils.OffsetPoint(carto, -0.3, bearing);
            let cartesian = Cesium.Cartesian3.fromDegrees(newPos.longitude, newPos.latitude, newPos.height);
            return cartesian;
        }
        /**
         * Handles right click mouse event at a given screen position.
         * @param screenPos
         */
        doMouseRightClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    let index = this.editorPoints.findIndex(x => x.posId == point.posId);
                    this.editorPoints.splice(index, 1);
                    point.DestroyEntity();
                    let maps = this.mappedHierarchy.GetAllPositionIdsWithHierarchyId();
                    for (let i = 0; i < maps.length; i++) {
                        let map = maps[i];
                        let mapPosIndex = map.positionIds.findIndex(x => x == point.posId);
                        if (mapPosIndex > -1) {
                            let hierarchy = this.mappedHierarchy.GetPositionsMap(map.hierarchyId);
                            hierarchy === null || hierarchy === void 0 ? void 0 : hierarchy.Remove(point.posId);
                            let pointsLeft = hierarchy.GetIds().length;
                            // Remove if this was the last position in the branch.
                            if (pointsLeft <= 0) {
                                this.mappedHierarchy.RemoveHierarchyBranch(map.hierarchyId);
                            }
                            // If there are less than 3 points (valid amount to draw polygon) then remove all inner points.
                            else if (pointsLeft < 3) {
                                let hMap = this.mappedHierarchy.GetMap(map.hierarchyId);
                                if (hMap.facing == polygon_7.PolygonFacing.out) {
                                    this.removeInnerEditorPoints();
                                    this.mappedHierarchy.ClearInner();
                                }
                            }
                            this.fixLeakingPoints();
                            this.updateQueue.Call(true);
                            break;
                        }
                    }
                }
            }
        }
        /**
         * Stops listening to Cesium mouse events.
         */
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.dispose();
                this.mouseHandler = null;
            }
        }
        /**
         * Disposes the editor.
         * This removes editor entities, listeners and stops it from being started again.
         */
        Dispose() {
            var _a;
            this.Stop();
            this.editorPoints = [];
            this.mappedHierarchy = null;
            this._disposed = true;
            (_a = this.heightSampler) === null || _a === void 0 ? void 0 : _a.Dispose();
        }
        /**
         * Prepares the editing entity.
         * @returns
         */
        prepareEntity() {
            if (this._disposed) {
                return;
            }
            let entity = this.entity;
            if (entity === null || entity === void 0 ? void 0 : entity.polygon) {
                let hierarchy = cesium_utils_15.CesiumUtils.getCesiumValue(this.viewer.CesiumViewer, entity.polygon.hierarchy);
                if (hierarchy) {
                    this.mappedHierarchy.updateOuterUsingCesiumHierarchy(hierarchy);
                }
                let entities = cesium_entity_utils_7.CesiumEntityUtils.getAllEntities(entity).filter(x => cesium_entity_utils_7.CesiumEntityUtils.isInnerEntity(x));
                this.mappedHierarchy.updateInnerUsingCesiumEntities(this.viewer.CesiumViewer, entities);
            }
            let maps = this.mappedHierarchy.GetAllPositionIdsWithHierarchyId();
            for (let i = 0; i < maps.length; i++) {
                let map = maps[i];
                for (let j = 0; j < map.positionIds.length; j++) {
                    let pos = map.positionIds[j];
                    let index = this.editorPoints.findIndex(x => x.posId == pos);
                    if (index <= -1) {
                        this.createEditorPoint(pos, map.hierarchyId);
                    }
                    else {
                        this.editorPoints[index].CreateEntity();
                    }
                }
            }
        }
        /**
         * Creates an editor point for a given point id at a given branch id.
         * @param posId
         * @param hierarchyId
         */
        createEditorPoint(posId, hierarchyId) {
            let outerId = this.mappedHierarchy.GetOutMapId();
            let point = new CesiumGeometryPolygonEditorPoint(posId, () => this.getEditorPointPosition(posId, hierarchyId), () => this.isPointVisible(posId, hierarchyId), (position) => {
                this.updateEditorPointPosition(posId, hierarchyId, position);
            }, this.viewer.CesiumViewer, hierarchyId, outerId == hierarchyId);
            point.CreateEntity();
            this.editorPoints.push(point);
        }
        /**
         * Returns if a given point should be visible.
         * @param posId
         * @param hierarchyId
         */
        isPointVisible(posId, hierarchyId) {
            if (this.outerLocked) {
                let outerId = this.mappedHierarchy.GetOutMapId();
                if (hierarchyId == outerId) {
                    return false;
                }
            }
            return true;
            /*
            if (posId == this.activePoint?.posId) {
                return true;
            }
    
            let unfinishedId = this.mappedHierarchy.GetUnfinishedMapId();
            if (hierarchyId == unfinishedId) {
                return true;
            }
    
            if (this.outerLocked) {
                let outerId = this.mappedHierarchy.GetOutMapId();
                if (hierarchyId == outerId) {
                    return false;
                }
            }
    
            if (CesiumUtils.ValidatePosition(this.lastCursorPos)) {
                let map = this.mappedHierarchy.GetPositionsMap(hierarchyId);
                let pos = map?.Get(posId);
                if (pos) {
                    let distance = this.getTerrainDistance(pos, this.lastCursorPos);
                    return distance <= 25;
                }
                else {
                    return false;
                }
            }
            return false;
            */
        }
        getTerrainDistance(posA, posB) {
            let carto1 = Cesium.Cartographic.fromCartesian(posA);
            let carto2 = Cesium.Cartographic.fromCartesian(posB);
            posA = Cesium.Cartesian3.fromRadians(carto1.longitude, carto1.latitude, 0);
            posB = Cesium.Cartesian3.fromRadians(carto2.longitude, carto2.latitude, 0);
            return Cesium.Cartesian3.distance(posA, posB);
        }
        /**
         * Creates a new editor point at a given position and calls to update geometry.
         * @param hierarchyId
         * @param position
         * @param insertIndex
         */
        createAndRegisterEditorPoint(hierarchyId, position, insertIndex = -1) {
            let map = this.mappedHierarchy.GetPositionsMap(hierarchyId);
            let pointId;
            if (insertIndex != null && insertIndex > -1) {
                pointId = map.Insert(position, insertIndex);
            }
            else {
                pointId = map.Add(position);
            }
            this.createEditorPoint(pointId, hierarchyId);
            this.updateQueue.Call(true);
        }
        /**
         * Returns editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @returns
         */
        getEditorPointPosition(posId, hierarchyId) {
            let hierarchyMap = this.mappedHierarchy.GetPositionsMap(hierarchyId);
            return hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Get(posId);
        }
        /**
         * Updates editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @param position
         */
        updateEditorPointPosition(posId, hierarchyId, position) {
            let hierarchyMap = this.mappedHierarchy.GetPositionsMap(hierarchyId);
            hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Update(posId, position);
        }
        /**
         * Starts the editing tool.
         * @returns
         */
        Start() {
            if (this._disposed) {
                return;
            }
            this._active = true;
            this.startMouseListeners();
            this.prepareEntity();
        }
        /**
         * Stops the editing tool.
         */
        Stop() {
            this.stopMouseListeners();
            this.removeEditorPoints(false);
            this.removeCursor();
            this._active = false;
        }
        /**
         * Removes editing point visuals.
         * @param emptyArray If array of editor points should be cleared.
         */
        removeEditorPoints(emptyArray) {
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                point.DestroyEntity();
            }
            if (emptyArray) {
                this.editorPoints = [];
            }
        }
        /**
         * Removes all editor points for inner facing hierarchies.
         */
        removeInnerEditorPoints() {
            let forRemoval = [];
            let innerMapIds = this.mappedHierarchy.GetInnerMapIds();
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                if (innerMapIds.includes(point.hierarchyId)) {
                    point.DestroyEntity();
                    forRemoval.push(point);
                }
            }
            for (let i = 0; i < forRemoval.length; i++) {
                let point = forRemoval[i];
                let index = this.editorPoints.findIndex(x => x.posId == point.posId);
                if (index > -1) {
                    this.editorPoints.splice(index, 1);
                }
            }
        }
        /**
         * Constructs and returns Bruce polygon geometry from current state of editor.
         */
        ConstructBrucePolygon() {
            return this.mappedHierarchy.ConstructBrucePolygon();
        }
        /**
         * Updates the Cesium 3D visual using the current state of the hierarchy map.
         */
        updateGeometry() {
            let change = false;
            let root = this._entity;
            if (root === null || root === void 0 ? void 0 : root.polygon) {
                let polygonHierarchy = this.mappedHierarchy.ConstructCesiumHierarchy();
                // First cover outer loop.
                if (root.polygon) {
                    root.polygon.hierarchy = polygonHierarchy;
                    change = true;
                    if (root.polyline) {
                        root.polyline.positions = polygonHierarchy.positions;
                    }
                }
                // Now process holes.
                let entities = cesium_entity_utils_7.CesiumEntityUtils.getAllEntities(root);
                let holeIndex = 0;
                for (let i = 0; i < entities.length; i++) {
                    let entity = entities[i];
                    if (cesium_entity_utils_7.CesiumEntityUtils.isInnerEntity(entity)) {
                        if (entity.polyline) {
                            let hole = polygonHierarchy.holes[holeIndex];
                            if (hole) {
                                entity.polyline.positions = hole.positions;
                                holeIndex += 1;
                            }
                            else {
                                cesium_entity_utils_7.CesiumEntityUtils.removeInnerEntity(root, entity);
                                this.viewer.CesiumViewer.entities.remove(entity);
                            }
                            change = true;
                        }
                    }
                }
                // Create missing holes.
                if (this.params && this.params.outlineWidth != null && this.params.outlineWidth > 0) {
                    entities = cesium_entity_utils_7.CesiumEntityUtils.getAllEntities(root);
                    let holeIds = this.mappedHierarchy.GetInnerMapIds();
                    for (let i = 0; i < holeIds.length; i++) {
                        let holeId = holeIds[i];
                        let index = entities.findIndex(x => x._bruceHierarchyMapRefId == holeId);
                        if (index <= -1) {
                            let map = this.mappedHierarchy.GetMap(holeId);
                            let posses = map.positions.getPositions();
                            let color = this.params.outlineColor;
                            if (typeof color == "string") {
                                color = Cesium.Color.fromCssColorString(color);
                            }
                            let holeEntity = new Cesium.Entity({
                                polyline: {
                                    positions: posses,
                                    clampToGround: true,
                                    material: color,
                                    width: this.params.outlineWidth,
                                    classificationType: Cesium.ClassificationType.TERRAIN,
                                    arcType: Cesium.ArcType.GEODESIC
                                },
                                parent: root
                            });
                            cesium_entity_utils_7.CesiumEntityUtils.MarkarkAsInner(holeEntity);
                            holeEntity._bruceHierarchyMapRefId = holeId;
                            this.viewer.CesiumViewer.entities.add(holeEntity);
                            this.viewer.CesiumViewer.scene.requestRender();
                        }
                    }
                }
            }
            if (change) {
                this.viewer.CesiumViewer.scene.requestRender();
            }
        }
        /**
         * Updates cursor styling depending on if editing point is found underneath.
         * @param screenPos
         */
        setPointerCursor(screenPos) {
            let point = this.getEditorPointFromMouse(screenPos);
            if (point) {
                document.body.style.cursor = "pointer";
            }
            else {
                document.body.style.removeProperty("cursor");
            }
        }
        /**
         * Updates the screen cursor styling to be grabbing.
         */
        setGrabCursor() {
            document.body.style.cursor = "grabbing";
        }
        /**
         * Removes cursor styling.
         */
        removeCursor() {
            document.body.style.removeProperty("cursor");
        }
    }
    exports.CesiumPolygonGeometryEditor = CesiumPolygonGeometryEditor;
});
define("entry-points/cesium/common/cesium-polygon-geometry-editor2", ["require", "exports", "cesium", "bruce-models/common/bruce-info", "bruce-models/common/polygon", "utils/delay-queue", "entry-points/cesium/common/cesium-cached-picking-height-util", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-entity-utils", "entry-points/cesium/common/cesium-geometry-editor-point", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-polygon-hierarchy-map", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, bruce_info_5, polygon_8, delay_queue_3, cesium_cached_picking_height_util_3, cesium_drawing_utils_8, cesium_entity_utils_8, cesium_geometry_editor_point_2, cesium_mouse_events_3, cesium_polygon_hierarchy_map_2, cesium_utils_16) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPolygonGeometryEditor2 = exports.ECesiumPolygonGeometryEditor2Mode = void 0;
    Cesium = __importStar(Cesium);
    var ECesiumPolygonGeometryEditor2Mode;
    (function (ECesiumPolygonGeometryEditor2Mode) {
        ECesiumPolygonGeometryEditor2Mode[ECesiumPolygonGeometryEditor2Mode["Boundaries"] = 0] = "Boundaries";
        ECesiumPolygonGeometryEditor2Mode[ECesiumPolygonGeometryEditor2Mode["Holes"] = 1] = "Holes";
        ECesiumPolygonGeometryEditor2Mode[ECesiumPolygonGeometryEditor2Mode["All"] = 2] = "All";
    })(ECesiumPolygonGeometryEditor2Mode = exports.ECesiumPolygonGeometryEditor2Mode || (exports.ECesiumPolygonGeometryEditor2Mode = {}));
    class CesiumGeometryEditorPointExtended extends cesium_geometry_editor_point_2.CesiumGeometryEditorPoint {
        constructor(posId, getPosition, showCallback, updatePosition, viewer, hierarchyId) {
            super({
                posId: posId,
                getPosition: getPosition,
                showCallback: showCallback,
                updatePosition: updatePosition,
                viewer: viewer
            });
            this.hierarchyId = hierarchyId;
        }
    }
    class CesiumPolygonGeometryEditor2 {
        constructor(mode, params) {
            this.zIndex = 5;
            this._disposed = false;
            this._started = false;
            // Clicked offset from the editor point's center point.
            this.mouseOffset = new Cesium.Cartesian2(0, 0);
            // Polygon map representing currently editing polygon positions.
            this.editingMap = new cesium_polygon_hierarchy_map_2.CesiumPolygonHierarchyMap();
            this.editingEntitySupplied = false;
            // Editor points created for map positions.
            this.editorPoints = [];
            this.mode = mode;
            this.viewer = params.viewer;
            this.editingInfo = params.entity;
            this.editingEntity = params.visual;
            this.editingEntitySupplied = !!params.visual;
            if (params.fillColor) {
                this.fillColor = params.fillColor;
            }
            else {
                this.fillColor = "white";
            }
            if (params.outlineColor) {
                this.outlineColor = params.outlineColor;
            }
            else {
                this.outlineColor = "grey";
            }
            if (params.outlineWidth == null) {
                this.outlineWidth = 1;
            }
            else {
                this.outlineWidth = params.outlineWidth;
            }
            this.updateGeometriesQueue = new delay_queue_3.DelayQueue(() => {
                this.updateGeometry();
            }, 100);
            this.heightSampler = new cesium_cached_picking_height_util_3.CesiumCachedPickingHeightUtil(this.cViewer);
        }
        get cViewer() {
            var _a;
            return (_a = this.viewer) === null || _a === void 0 ? void 0 : _a.CesiumViewer;
        }
        get disposed() {
            return this._disposed;
        }
        get started() {
            return this._started;
        }
        Start() {
            var _a;
            if (this._disposed) {
                throw (">>Error: Cannot start editor that has been disposed.");
            }
            if (!this._started) {
                let cesiumHierarchy = this.editingEntity ? cesium_utils_16.CesiumUtils.getCesiumValue(this.cViewer, (_a = this.editingEntity.polygon) === null || _a === void 0 ? void 0 : _a.hierarchy) : null;
                if (cesiumHierarchy) {
                    this.editingMap.updateUsingCesiumHierarchy(cesiumHierarchy);
                }
                else {
                    this.editingMap.updateUsingPolygon(this.editingInfo.geometry.Polygon);
                }
                this.refreshEditorPoints();
                this.startMouseListeners();
                this._started = true;
            }
        }
        refreshEditorPoints() {
            let maps = this.editingMap.GetMaps();
            for (let i = 0; i < maps.length; i++) {
                let map = maps[i];
                if ((map.facing == polygon_8.PolygonFacing.out && this.mode != ECesiumPolygonGeometryEditor2Mode.Holes) ||
                    (map.facing == polygon_8.PolygonFacing.in && this.mode != ECesiumPolygonGeometryEditor2Mode.Boundaries)) {
                    this.refreshEditorPointsForHierarchy(map.hierarchyId);
                }
            }
        }
        refreshEditorPointsForHierarchy(hierarchyId) {
            let map = this.editingMap;
            let positionMap = map.GetMap(hierarchyId).positions;
            let posIds = positionMap.GetIds();
            for (let j = 0; j < posIds.length; j++) {
                let pos = posIds[j];
                let index = this.editorPoints.findIndex(x => x.posId == pos);
                if (index <= -1) {
                    this.createEditorPoint(pos, hierarchyId);
                }
                else {
                    this.editorPoints[index].CreateEntity();
                }
            }
        }
        Stop() {
            if (this._disposed) {
                throw (">>Error: Cannot stop editor that has been disposed.");
            }
            if (this._started) {
                this.stopMouseListeners();
                this.clear();
                this.removeCursor();
                this._started = false;
            }
        }
        /**
         * @param api: api reference for disjoint request.
         * @param siblings: what siblings to cut intersections out of.
         * @param boundary
         */
        Finish(api, siblings, boundary) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._disposed || !this._started) {
                    throw (">>Error: Cannot finish editor that has been disposed or stopped.");
                }
                // Prepare data for intersection tests.
                let polygon = this.editingMap.ConstructBrucePolygon();
                if (polygon) {
                    polygon = yield polygon_8.Polygon.TruncateHoles(api, polygon);
                }
                let info = new bruce_info_5.BruceInfo(this.editingInfo.JSON);
                info.geometry.Polygon = polygon;
                if (boundary) {
                    try {
                        info = (yield bruce_info_5.BruceInfo.TruncateEntities(api, [info], boundary))[0];
                    }
                    catch (_a) {
                    }
                }
                let updatedInfos = [];
                for (let i = 0; i < siblings.length; i++) {
                    let sibling = siblings[i];
                    try {
                        let data = yield bruce_info_5.BruceInfo.DisjointEntities(api, [sibling, info]);
                        let updated = data.find(x => x.Bruce.ID == sibling.Bruce.ID);
                        if (updated) {
                            updatedInfos.push(updated);
                        }
                    }
                    catch (_b) {
                    }
                }
                let data = {
                    entity: info,
                    updatedSiblings: updatedInfos
                };
                this.Stop();
                this.editingInfo = data.entity;
                return data;
            });
        }
        Dispose() {
            if (!this._disposed) {
                this.Stop();
                this.heightSampler.Dispose();
                this._disposed = true;
            }
        }
        clear() {
            this.editingMap = new cesium_polygon_hierarchy_map_2.CesiumPolygonHierarchyMap();
            if (!this.editingEntitySupplied) {
                if (this.editingEntity && this.cViewer.entities.contains(this.editingEntity)) {
                    this.cViewer.entities.remove(this.editingEntity);
                }
                this.editingEntity = null;
            }
            this.removeEditorPoints(true);
        }
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_3.CesiumMouseEvents(this.cViewer);
                this.mouseHandler.LeftDownEvent.Subscribe((data) => {
                    this.doMouseLeftDown(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.LeftUpEvent.Subscribe((data) => {
                    this.doMouseLeftUp();
                });
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.RightClickEvent.Subscribe((data) => {
                    this.doMouseRightClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doMouseClick(data === null || data === void 0 ? void 0 : data.position);
                });
                if (this.mode != ECesiumPolygonGeometryEditor2Mode.Boundaries) {
                    this.mouseHandler.MiddleClickEvent.Subscribe((data) => {
                        this.doMiddleClick(data.position);
                    });
                }
                this.mouseHandler.EnableEventHandling();
            }
        }
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.dispose();
                this.mouseHandler = null;
            }
        }
        doMiddleClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = cesium_drawing_utils_8.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.cViewer, screenPos);
                    if (cesium_utils_16.CesiumUtils.ValidatePosition(pos3d)) {
                        this.createHole(pos3d);
                    }
                }
            }
        }
        createHole(position) {
            if (this.isWithinBoundaries(position) && this.isOutsideHoles(position)) {
                let mapId = this.editingMap.AddMap(polygon_8.PolygonFacing.in);
                let map = this.editingMap.GetMap(mapId);
                let posId = map.positions.Add(position);
                this.createEditorPoint(posId, mapId);
            }
        }
        doMouseClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = cesium_drawing_utils_8.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.cViewer, screenPos);
                    if (cesium_utils_16.CesiumUtils.ValidatePosition(pos3d)) {
                        this.addPosition(pos3d);
                    }
                }
            }
        }
        doMouseRightClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.removePoint(point);
                }
            }
        }
        doMouseMove(screenPos) {
            let updatedPos = true;
            if (cesium_utils_16.CesiumUtils.Validate2DPosition(screenPos)) {
                screenPos.x += this.mouseOffset.x;
                screenPos.y += this.mouseOffset.y;
                let pos3d = cesium_drawing_utils_8.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer.CesiumViewer, screenPos);
                if (cesium_utils_16.CesiumUtils.ValidatePosition(pos3d)) {
                    if (this.activePoint) {
                        updatedPos = false;
                        this.activePoint.updatePosition(pos3d);
                        this.updateGeometriesQueue.Call(false);
                    }
                }
            }
            if (updatedPos) {
                this.setPointerCursor(screenPos);
            }
        }
        doMouseLeftUp() {
            if (this.activePoint) {
                this.activePoint = null;
                this.viewer.cameraHandler.isFrozen = false;
            }
        }
        doMouseLeftDown(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.activePoint = point;
                    this.updateOffset(screenPos);
                    this.setGrabCursor();
                    this.viewer.cameraHandler.isFrozen = true;
                }
            }
        }
        /**
         * Removes drawing point and associated map data.
         * @param point
         */
        removePoint(point) {
            let map = this.editingMap;
            if (map) {
                let mapRing = map.GetMap(point.hierarchyId);
                if (mapRing) {
                    let pointsLeft = mapRing.positions.GetIds().length;
                    if (pointsLeft < 4 && mapRing.facing == polygon_8.PolygonFacing.out) {
                        let innerIds = this.editingMap.GetInnerMapIds();
                        for (let i = 0; i < innerIds.length; i++) {
                            this.removeEditorPointsForMap(innerIds[i]);
                            this.editingMap.RemoveHierarchyBranch(innerIds[i]);
                        }
                    }
                    if (pointsLeft > 1) {
                        mapRing.positions.Remove(point.posId);
                        let index = this.editorPoints.findIndex(x => x.posId == point.posId);
                        this.editorPoints.splice(index, 1);
                        point.DestroyEntity();
                    }
                    else if (mapRing.facing == polygon_8.PolygonFacing.in) {
                        this.removeEditorPointsForMap(point.hierarchyId);
                        this.editingMap.RemoveHierarchyBranch(point.hierarchyId);
                    }
                    this.updateGeometriesQueue.Call(true);
                }
            }
        }
        /**
         * Adds new position to nearest outer ring line.
         * @param position
         */
        addPosition(position) {
            if (this.mode == ECesiumPolygonGeometryEditor2Mode.All) {
                this.addPositionComplex(position);
            }
            else if (this.mode == ECesiumPolygonGeometryEditor2Mode.Boundaries) {
                this.addPositionBoundaries(position);
            }
            else {
                if (this.isWithinBoundaries(position)) {
                    this.addPositionToHoles(position, true);
                }
            }
        }
        /**
         * Makes a decision on if position should be added to boundaries or holes and adds it.
         */
        addPositionComplex(position) {
            let mapId = null;
            // If the user clicks within the boundaries it can be assumed they are trying to complete an unfinished hole.
            let isWithinBoundaries = this.isWithinBoundaries(position);
            if (isWithinBoundaries) {
                mapId = this.editingMap.GetUnfinishedHoleId();
            }
            let isOutsideHoles = this.isOutsideHoles(position);
            // If there is an unfinished hole and we haven't clicked an existing hole, then we add to it.
            if (mapId && isOutsideHoles) {
                this.addPositionToMap(mapId, position);
            }
            else {
                // We clicked within boundaries so lets find the closest hole.
                if (isWithinBoundaries) {
                    this.addPositionToHoles(position, false);
                }
                // We clicked outside boundaries so lets find the closest border.
                else {
                    this.addPositionBoundaries(position);
                }
            }
        }
        /**
         * Makes a decision on if position should be added to an existing hole and adds it.
         */
        addPositionToHoles(position, unfinishedInclusive) {
            let mapId;
            if (unfinishedInclusive && this.isOutsideHoles(position)) {
                mapId = this.editingMap.GetUnfinishedHoleId();
            }
            if (!mapId) {
                mapId = this.editingMap.GetClosestHoleId(position, true);
            }
            if (mapId) {
                this.addPositionToMap(mapId, position);
            }
        }
        /**
         * Makes a decision on if position should be added to boundaries and adds it.
         */
        addPositionBoundaries(position) {
            let outMapId = this.editingMap.GetOutMapId();
            if (!outMapId) {
                outMapId = this.editingMap.AddMap(polygon_8.PolygonFacing.out);
            }
            this.addPositionToMap(outMapId, position);
        }
        addPositionToMap(mapId, position) {
            let map = this.editingMap.GetMap(mapId);
            // Can't find nearest line yet.
            if (map.positions.getPositions().length < 2) {
                let posId = map.positions.Add(position);
                this.createEditorPoint(posId, mapId);
            }
            else {
                let insertIndex = this.editingMap.GetInsertIndex(mapId, position);
                let posId = map.positions.Insert(position, insertIndex);
                this.createEditorPoint(posId, mapId);
            }
            this.updateGeometriesQueue.Call(true);
        }
        isWithinBoundaries(position) {
            return this.isInMap(this.editingMap.GetOutMap(), position);
        }
        isOutsideHoles(position) {
            let inMaps = this.editingMap.GetInnerMaps();
            for (let i = 0; i < inMaps.length; i++) {
                let map = inMaps[i];
                let isIn = this.isInMap(map, position);
                if (isIn) {
                    return false;
                }
            }
            return true;
        }
        isInMap(map, position) {
            let posses = map.getPositions();
            let cartos = posses.map(x => Cesium.Cartographic.fromCartesian(x));
            let carto = Cesium.Cartographic.fromCartesian(position);
            return cesium_utils_16.CesiumUtils.getIsPointInPolygon(cartos, carto);
        }
        /**
         * Removes editing point visuals.
         * @param emptyArray If array of editor points should be cleared.
         */
        removeEditorPoints(emptyArray) {
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                point.DestroyEntity();
            }
            if (emptyArray) {
                this.editorPoints = [];
            }
        }
        removeEditorPointsForMap(mapId) {
            let newArray = [];
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                if (point.hierarchyId == mapId) {
                    point.DestroyEntity();
                }
                else {
                    newArray.push(point);
                }
            }
            this.editorPoints = newArray;
        }
        /**
         * Returns editing point from this editor from given screen position.
         * @param screenPos
         * @returns
         */
        getEditorPointFromMouse(screenPos) {
            if (cesium_utils_16.CesiumUtils.Validate2DPosition(screenPos)) {
                let viewer = this.cViewer;
                let pickedObjects = viewer.scene.drillPick(screenPos, 5);
                for (let i = 0; i < pickedObjects.length; i++) {
                    let pickedObject = pickedObjects[i];
                    if (pickedObject.id instanceof Cesium.Entity) {
                        pickedObject = pickedObject.id;
                    }
                    if (pickedObject && pickedObject._cesiumGeometryEditorPointId) {
                        let point = this.editorPoints.find(x => x.posId == pickedObject._cesiumGeometryEditorPointId);
                        if (point) {
                            return point;
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Returns editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @returns
         */
        getEditorPointPosition(posId, hierarchyId) {
            let hierarchyMap = this.editingMap.GetMap(hierarchyId).positions;
            return hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Get(posId);
        }
        /**
         * Creates an editor point for a given point id at a given branch id.
         * @param posId
         * @param hierarchyId
         */
        createEditorPoint(posId, hierarchyId) {
            let point = new CesiumGeometryEditorPointExtended(posId, () => this.getEditorPointPosition(posId, hierarchyId), () => true, (position) => {
                this.updateEditorPointPosition(posId, hierarchyId, position);
            }, this.cViewer, hierarchyId);
            point.CreateEntity();
            this.editorPoints.push(point);
        }
        /**
         * Updates editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @param position
         */
        updateEditorPointPosition(posId, hierarchyId, position) {
            let hierarchyMap = this.editingMap.GetMap(hierarchyId).positions;
            hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Update(posId, position);
        }
        /**
         * Updates the clicked offset from the entity's position.
         * @param screenPos
         */
        updateOffset(screenPos) {
            if (this.activePoint) {
                let position = this.activePoint.lastPosition;
                let grounded = Cesium.Cartographic.fromCartesian(position);
                let height = this.heightSampler.Pick(grounded);
                position = Cesium.Cartesian3.fromRadians(grounded.longitude, grounded.latitude, height);
                if (cesium_utils_16.CesiumUtils.ValidatePosition(position)) {
                    let entityScreenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.CesiumViewer.scene, position);
                    if (cesium_utils_16.CesiumUtils.Validate2DPosition(entityScreenPos)) {
                        this.mouseOffset.x = entityScreenPos.x - screenPos.x;
                        this.mouseOffset.y = entityScreenPos.y - screenPos.y;
                    }
                }
            }
        }
        /**
         * Updates cursor styling depending on if editing point is found underneath.
         * @param screenPos
         */
        setPointerCursor(screenPos) {
            let point = this.getEditorPointFromMouse(screenPos);
            if (point) {
                document.body.style.cursor = "pointer";
            }
            else {
                document.body.style.removeProperty("cursor");
            }
        }
        /**
         * Updates the screen cursor styling to be grabbing.
         */
        setGrabCursor() {
            document.body.style.cursor = "grabbing";
        }
        /**
         * Removes cursor styling.
         */
        removeCursor() {
            document.body.style.removeProperty("cursor");
        }
        updateGeometry() {
            let change = false;
            let map = this.editingMap;
            let root = this.editingEntity;
            if (root && !this.cViewer.entities.contains(root)) {
                root = null;
            }
            if (root) {
                if (!root.polygon) {
                    this.createPolygonVisual(root);
                }
            }
            else {
                root = this.editingEntity = new Cesium.Entity();
                this.cViewer.entities.add(root);
                this.createPolygonVisual(root);
            }
            if (root.polygon) {
                this.updatePolygonVisual(root, map);
                change = true;
            }
            if (change) {
                this.cViewer.scene.requestRender();
            }
        }
        createPolygonVisual(entity) {
            let fillColor = this.fillColor;
            if (typeof fillColor == "string") {
                fillColor = Cesium.Color.fromCssColorString(fillColor);
            }
            entity.polygon = new Cesium.PolygonGraphics({
                material: fillColor,
                shadows: Cesium.ShadowMode.ENABLED,
                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                classificationType: Cesium.ClassificationType.BOTH
            });
        }
        updatePolygonVisual(root, map) {
            let polygonHierarchy = map.ConstructCesiumHierarchy();
            // First cover outer loop.
            root.polygon.hierarchy = polygonHierarchy;
            if (root.polyline) {
                root.polyline.positions = polygonHierarchy.positions;
            }
            else if (this.outlineWidth) {
                let color = this.outlineColor;
                if (typeof color == "string") {
                    color = Cesium.Color.fromCssColorString(color);
                }
                root.polyline = new Cesium.PolylineGraphics({
                    positions: polygonHierarchy.positions,
                    clampToGround: true,
                    material: color,
                    width: this.outlineWidth,
                    classificationType: Cesium.ClassificationType.TERRAIN,
                    arcType: Cesium.ArcType.GEODESIC,
                    zIndex: this.zIndex
                });
            }
            // Now process holes.
            let entities = cesium_entity_utils_8.CesiumEntityUtils.getAllEntities(root);
            let holeIndex = 0;
            for (let i = 0; i < entities.length; i++) {
                let entity = entities[i];
                if (cesium_entity_utils_8.CesiumEntityUtils.isInnerEntity(entity)) {
                    if (entity.polyline) {
                        let hole = polygonHierarchy.holes[holeIndex];
                        if (hole) {
                            entity.polyline.positions = hole.positions;
                            holeIndex += 1;
                        }
                        else {
                            cesium_entity_utils_8.CesiumEntityUtils.removeInnerEntity(root, entity);
                            this.viewer.CesiumViewer.entities.remove(entity);
                        }
                    }
                }
            }
            // Create missing holes.
            if (this.outlineWidth) {
                entities = cesium_entity_utils_8.CesiumEntityUtils.getAllEntities(root);
                let holeIds = map.GetInnerMapIds();
                for (let i = 0; i < holeIds.length; i++) {
                    let holeId = holeIds[i];
                    let index = entities.findIndex(x => x._bruceHierarchyMapRefId == holeId);
                    if (index <= -1) {
                        let holeMap = map.GetMap(holeId);
                        let posses = holeMap.positions.getPositions();
                        let color = this.outlineColor;
                        if (typeof color == "string") {
                            color = Cesium.Color.fromCssColorString(color);
                        }
                        let holeEntity = new Cesium.Entity({
                            polyline: {
                                positions: posses,
                                clampToGround: true,
                                material: color,
                                width: this.outlineWidth,
                                classificationType: Cesium.ClassificationType.TERRAIN,
                                arcType: Cesium.ArcType.GEODESIC
                            },
                            parent: root
                        });
                        cesium_entity_utils_8.CesiumEntityUtils.MarkarkAsInner(holeEntity);
                        holeEntity._bruceHierarchyMapRefId = holeId;
                        this.viewer.CesiumViewer.entities.add(holeEntity);
                        this.viewer.CesiumViewer.scene.requestRender();
                    }
                }
            }
        }
    }
    exports.CesiumPolygonGeometryEditor2 = CesiumPolygonGeometryEditor2;
});
define("utils/browser-utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserUtils = exports.EBrowser = void 0;
    var EBrowser;
    (function (EBrowser) {
        EBrowser[EBrowser["Firefox"] = 0] = "Firefox";
        EBrowser[EBrowser["Chrome"] = 1] = "Chrome";
        EBrowser[EBrowser["Opera"] = 2] = "Opera";
        EBrowser[EBrowser["Edge"] = 3] = "Edge";
        EBrowser[EBrowser["InternetExplorer"] = 4] = "InternetExplorer";
        EBrowser[EBrowser["Safari"] = 5] = "Safari";
        EBrowser[EBrowser["Other"] = 6] = "Other";
    })(EBrowser = exports.EBrowser || (exports.EBrowser = {}));
    class BrowserUtils {
        /**
         * Returns if current windowdow is given browser.
         * @param browser
         * @returns
         */
        static IsBrowser(browser) {
            switch (browser) {
                case EBrowser.Chrome:
                    // @ts-ignore
                    return !!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime);
                case EBrowser.InternetExplorer:
                    // @ts-ignore
                    return !!window.document.documentMode;
                case EBrowser.Edge:
                    var isIE = this.GetBrowser() == EBrowser.InternetExplorer;
                    // @ts-ignore
                    return !isIE && !!window.StyleMedia;
                case EBrowser.Firefox:
                    // @ts-ignore
                    return typeof InstallTrigger !== "undefined";
                case EBrowser.Opera:
                    // @ts-ignore
                    return (!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0;
                case EBrowser.Safari:
                    // @ts-ignore
                    return /constructor/i.test(window.HTMLElement) || (function (p) {
                        return p.toString() === "[object SafariRemoteNotification]";
                    })(!window["safari"] || (typeof window["safari"] !== "undefined" && window["safari"].pushNotification));
            }
            return browser == EBrowser.Other;
        }
        /**
         * Returns a best guess at what the current browser is.
         * @returns
         */
        static GetBrowser() {
            // @ts-ignore
            if (!!window.chrome && (!!window.chrome.webstore || !!window.chrome.runtime)) {
                return EBrowser.Chrome;
            }
            // @ts-ignore
            else if (window.document.documentMode) {
                return EBrowser.InternetExplorer;
            }
            // @ts-ignore
            else if (window.StyleMedia) {
                return EBrowser.Edge;
            }
            // @ts-ignore
            else if (typeof InstallTrigger !== "undefined") {
                return EBrowser.Firefox;
            }
            // @ts-ignore
            else if ((!!window.opr && !!opr.addons) || !!window.opera || navigator.userAgent.indexOf(" OPR/") >= 0) {
                return EBrowser.Opera;
            }
            // @ts-ignore
            else if (/constructor/i.test(window.HTMLElement) || (function (p) {
                return p.toString() === "[object SafariRemoteNotification]";
            })(!window["safari"] || (typeof window["safari"] !== "undefined" && window["safari"].pushNotification))) {
                return EBrowser.Safari;
            }
            return EBrowser.Other;
        }
    }
    exports.BrowserUtils = BrowserUtils;
});
define("entry-points/cesium/common/cesium-polygon-geometry-editor3", ["require", "exports", "cesium", "bruce-models/common/cartographic", "bruce-models/common/polygon", "utils/browser-utils", "utils/delay-queue", "utils/drawing-utils", "entry-points/cesium/common/cesium-cached-picking-height-util", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-entity-utils", "entry-points/cesium/common/cesium-geometry-editor-point", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-polygon-hierarchy-map", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, cartographic_6, polygon_9, browser_utils_1, delay_queue_4, drawing_utils_3, cesium_cached_picking_height_util_4, cesium_drawing_utils_9, cesium_entity_utils_9, cesium_geometry_editor_point_3, cesium_mouse_events_4, cesium_polygon_hierarchy_map_3, cesium_utils_17) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPolygonGeometryEditor3 = exports.ECesiumPolygonGeometryEditor3Mode = void 0;
    Cesium = __importStar(Cesium);
    var ECesiumPolygonGeometryEditor3Mode;
    (function (ECesiumPolygonGeometryEditor3Mode) {
        ECesiumPolygonGeometryEditor3Mode[ECesiumPolygonGeometryEditor3Mode["Boundaries"] = 0] = "Boundaries";
        ECesiumPolygonGeometryEditor3Mode[ECesiumPolygonGeometryEditor3Mode["Holes"] = 1] = "Holes";
        ECesiumPolygonGeometryEditor3Mode[ECesiumPolygonGeometryEditor3Mode["All"] = 2] = "All";
    })(ECesiumPolygonGeometryEditor3Mode = exports.ECesiumPolygonGeometryEditor3Mode || (exports.ECesiumPolygonGeometryEditor3Mode = {}));
    class CesiumGeometryEditorPointExtended extends cesium_geometry_editor_point_3.CesiumGeometryEditorPoint {
        constructor(params) {
            super(params);
            this.hierarchyId = params.hierarchyId;
        }
    }
    class CesiumPolygonGeometryEditor3 {
        constructor(mode, params) {
            this._disposed = false;
            this._started = false;
            // Height reference for the drawn points.
            this.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
            // Entities to ignore alongside the editing entity when raycasting.
            this.ignoreEntities = [];
            // Clicked offset from the editor point's center point.
            this.mouseOffset = new Cesium.Cartesian2(0, 0);
            // Polygon map representing currently editing polygon positions.
            this.editingMap = new cesium_polygon_hierarchy_map_3.CesiumPolygonHierarchyMap();
            // Editor points created for map positions.
            this.editorPoints = [];
            this.mode = mode;
            this.viewer = params.viewer;
            this.cameraHandler = params.cameraHandler;
            this.editingEntity = params.entity;
            if (params.outlineColor) {
                this.outlineColor = params.outlineColor;
            }
            else {
                this.outlineColor = "grey";
            }
            if (params.outlineWidth == null) {
                this.outlineWidth = 1;
            }
            else {
                this.outlineWidth = params.outlineWidth;
            }
            if (params.smoothen) {
                this.smoothen = params.smoothen;
            }
            else {
                this.smoothen = 0;
            }
            if (params.heightReference != null) {
                this.heightReference = params.heightReference;
            }
            if (params.ignoreEntities != null) {
                this.ignoreEntities = params.ignoreEntities;
            }
            this.editorPointColor = params.editorPointColor;
            this.editorPointSize = params.editorPointSize;
            try {
                this.browser = browser_utils_1.BrowserUtils.GetBrowser();
            }
            catch (e) {
                console.log(">>Error: Failed to determine browser. Defaulting to Chrome.");
                console.log(e);
                this.browser = browser_utils_1.EBrowser.Chrome;
            }
            this.updateGeometriesQueue = new delay_queue_4.DelayQueue(() => {
                this.updateGeometry();
            }, 100);
            this.heightSampler = new cesium_cached_picking_height_util_4.CesiumCachedPickingHeightUtil(this.viewer);
            this.startingHierarchy = params.hierarchy;
            if (!this.startingHierarchy) {
                // TODO GET HIERARCHY FROM ENTITY.
            }
        }
        get disposed() {
            return this._disposed;
        }
        get started() {
            return this._started;
        }
        init() {
            this.removeEditorPoints(true);
            this.editingMap.Clear();
            let rings = this.startingHierarchy;
            for (let i = 0; i < rings.length; i++) {
                let ring = rings[i];
                let posses = ring.getParsedCartographicPositions();
                let isClosed = cartographic_6.Cartographic.IsClosedRing(posses);
                if (isClosed) {
                    posses.pop();
                }
                let mapId = this.editingMap.AddMap(ring.Facing);
                let map = this.editingMap.GetMap(mapId);
                for (let j = 0; j < posses.length; j++) {
                    let pos = posses[j];
                    let posId = map.positions.Add(Cesium.Cartesian3.fromDegrees(pos.longitude, pos.latitude, pos.altitude));
                    if ((map.facing == polygon_9.PolygonFacing.out && this.mode != ECesiumPolygonGeometryEditor3Mode.Holes) ||
                        (map.facing == polygon_9.PolygonFacing.in && this.mode != ECesiumPolygonGeometryEditor3Mode.Boundaries)) {
                        this.createEditorPoint(posId, mapId);
                    }
                }
            }
            this.updateGeometry();
            this.unlinkGeometry();
        }
        /**
         * Returns polygon that represents the current visual.
         */
        getPolygon() {
            return this.editingMap.ConstructBrucePolygon();
        }
        Start() {
            if (this._disposed) {
                throw (">>Error: Cannot start editor that has been disposed.");
            }
            if (!this._started) {
                this.init();
                this.startMouseListeners();
                this._started = true;
                this.updateGeometriesQueue.Call(true);
            }
        }
        Stop() {
            if (this._disposed) {
                throw (">>Error: Cannot stop editor that has been disposed.");
            }
            if (this._started) {
                this.stopMouseListeners();
                this.clear();
                this.removeCursor();
                this.unlinkGeometry();
                this._started = false;
            }
        }
        /**
         * Sets smoothen level, if changed then a refresh on visual is queued.
         * @param value
         */
        SetSmoothen(value) {
            if (this.smoothen != value) {
                this.smoothen = value;
                this.updateGeometriesQueue.Call(false);
            }
        }
        /**
         * If tool is running then calling reset will refresh editor points and visuals.
         */
        Reset() {
            if (this._disposed) {
                throw (">>Error: Cannot reset editor that has been disposed.");
            }
            if (this._started) {
                this.init();
            }
        }
        Dispose() {
            if (!this._disposed) {
                this.Stop();
                this.heightSampler.Dispose();
                this._disposed = true;
            }
        }
        clear() {
            this.editingMap = new cesium_polygon_hierarchy_map_3.CesiumPolygonHierarchyMap();
            this.removeEditorPoints(true);
        }
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_4.CesiumMouseEvents(this.viewer);
                this.mouseHandler.LeftDownEvent.Subscribe((data) => {
                    this.doMouseLeftDown(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.LeftUpEvent.Subscribe((data) => {
                    this.doMouseLeftUp();
                });
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.RightClickEvent.Subscribe((data) => {
                    this.doMouseRightClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doMouseClick(data === null || data === void 0 ? void 0 : data.position);
                });
                if (this.mode != ECesiumPolygonGeometryEditor3Mode.Boundaries) {
                    this.mouseHandler.MiddleClickEvent.Subscribe((data) => {
                        this.doMiddleClick(data.position);
                    });
                }
                this.mouseHandler.EnableEventHandling();
            }
        }
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.dispose();
                this.mouseHandler = null;
            }
        }
        doMiddleClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = cesium_drawing_utils_9.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                    if (cesium_utils_17.CesiumUtils.ValidatePosition(pos3d)) {
                        this.createHole(pos3d);
                    }
                }
            }
        }
        createHole(position) {
            if (this.isWithinBoundaries(position) && this.isOutsideHoles(position)) {
                let mapId = this.editingMap.AddMap(polygon_9.PolygonFacing.in);
                let map = this.editingMap.GetMap(mapId);
                let posId = map.positions.Add(position);
                this.createEditorPoint(posId, mapId);
            }
        }
        doMouseClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = this.getCartesian3FromMouse(screenPos);
                    if (cesium_utils_17.CesiumUtils.ValidatePosition(pos3d)) {
                        this.addPosition(pos3d);
                    }
                }
            }
        }
        doMouseRightClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.removePoint(point);
                }
            }
        }
        doMouseMove(screenPos) {
            let updatedPos = true;
            if (cesium_utils_17.CesiumUtils.Validate2DPosition(screenPos)) {
                screenPos.x += this.mouseOffset.x;
                screenPos.y += this.mouseOffset.y;
                let pos3d = this.getCartesian3FromMouse(screenPos);
                if (cesium_utils_17.CesiumUtils.ValidatePosition(pos3d)) {
                    if (this.activePoint) {
                        updatedPos = false;
                        this.activePoint.updatePosition(pos3d);
                        this.updateGeometriesQueue.Call(false);
                    }
                }
            }
            if (updatedPos) {
                this.setPointerCursor(screenPos);
            }
        }
        doMouseLeftUp() {
            if (this.activePoint) {
                this.activePoint = null;
                this.cameraHandler.isFrozen = false;
            }
        }
        doMouseLeftDown(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.activePoint = point;
                    this.updateOffset(screenPos);
                    this.setGrabCursor();
                    this.cameraHandler.isFrozen = true;
                }
            }
        }
        /**
         * Removes drawing point and associated map data.
         * @param point
         */
        removePoint(point) {
            let map = this.editingMap;
            if (map) {
                let mapRing = map.GetMap(point.hierarchyId);
                if (mapRing) {
                    let pointsLeft = mapRing.positions.GetIds().length;
                    if (pointsLeft < 4 && mapRing.facing == polygon_9.PolygonFacing.out) {
                        return;
                        /*
                        let innerIds = this.editingMap.GetInnerMapIds();
                        for (let i = 0; i < innerIds.length; i++)
                        {
                            this.removeEditorPointsForMap(innerIds[i]);
                            this.editingMap.RemoveHierarchyBranch(innerIds[i]);
                        }
                        */
                    }
                    if (pointsLeft > 1) {
                        mapRing.positions.Remove(point.posId);
                        let index = this.editorPoints.findIndex(x => x.posId == point.posId);
                        this.editorPoints.splice(index, 1);
                        point.DestroyEntity();
                    }
                    else if (mapRing.facing == polygon_9.PolygonFacing.in) {
                        this.removeEditorPointsForMap(point.hierarchyId);
                        this.editingMap.RemoveHierarchyBranch(point.hierarchyId);
                    }
                    this.updateGeometriesQueue.Call(true);
                }
            }
        }
        /**
         * Adds new position to nearest outer ring line.
         * @param position
         */
        addPosition(position) {
            if (this.mode == ECesiumPolygonGeometryEditor3Mode.All) {
                this.addPositionComplex(position);
            }
            else if (this.mode == ECesiumPolygonGeometryEditor3Mode.Boundaries) {
                this.addPositionBoundaries(position);
            }
            else {
                if (this.isWithinBoundaries(position)) {
                    this.addPositionToHoles(position, true);
                }
            }
        }
        /**
         * Makes a decision on if position should be added to boundaries or holes and adds it.
         */
        addPositionComplex(position) {
            let mapId = null;
            // If the user clicks within the boundaries it can be assumed they are trying to complete an unfinished hole.
            let isWithinBoundaries = this.isWithinBoundaries(position);
            if (isWithinBoundaries) {
                mapId = this.editingMap.GetUnfinishedHoleId();
            }
            let isOutsideHoles = this.isOutsideHoles(position);
            // If there is an unfinished hole and we haven't clicked an existing hole, then we add to it.
            if (mapId && isOutsideHoles) {
                this.addPositionToMap(mapId, position);
            }
            else {
                // We clicked within boundaries so lets find the closest hole.
                if (isWithinBoundaries) {
                    this.addPositionToHoles(position, false);
                }
                // We clicked outside boundaries so lets find the closest border.
                else {
                    this.addPositionBoundaries(position);
                }
            }
        }
        /**
         * Makes a decision on if position should be added to an existing hole and adds it.
         */
        addPositionToHoles(position, unfinishedInclusive) {
            let mapId;
            if (unfinishedInclusive && this.isOutsideHoles(position)) {
                mapId = this.editingMap.GetUnfinishedHoleId();
            }
            if (!mapId) {
                mapId = this.editingMap.GetClosestHoleId(position, true);
            }
            if (mapId) {
                this.addPositionToMap(mapId, position);
            }
        }
        /**
         * Makes a decision on if position should be added to boundaries and adds it.
         */
        addPositionBoundaries(position) {
            let outMapId = this.editingMap.GetOutMapId();
            if (!outMapId) {
                outMapId = this.editingMap.AddMap(polygon_9.PolygonFacing.out);
            }
            this.addPositionToMap(outMapId, position);
        }
        addPositionToMap(mapId, position) {
            let map = this.editingMap.GetMap(mapId);
            // Can't find nearest line yet.
            if (map.positions.getPositions().length < 2) {
                let posId = map.positions.Add(position);
                this.createEditorPoint(posId, mapId);
            }
            else {
                let insertIndex = this.editingMap.GetInsertIndex(mapId, position);
                let posId = map.positions.Insert(position, insertIndex);
                this.createEditorPoint(posId, mapId);
            }
            this.updateGeometriesQueue.Call(true);
        }
        isWithinBoundaries(position) {
            return this.isInMap(this.editingMap.GetOutMap(), position);
        }
        isOutsideHoles(position) {
            let inMaps = this.editingMap.GetInnerMaps();
            for (let i = 0; i < inMaps.length; i++) {
                let map = inMaps[i];
                let isIn = this.isInMap(map, position);
                if (isIn) {
                    return false;
                }
            }
            return true;
        }
        isInMap(map, position) {
            let posses = map.getPositions();
            let cartos = posses.map(x => Cesium.Cartographic.fromCartesian(x));
            let carto = Cesium.Cartographic.fromCartesian(position);
            return cesium_utils_17.CesiumUtils.getIsPointInPolygon(cartos, carto);
        }
        /**
         * Removes editing point visuals.
         * @param emptyArray If array of editor points should be cleared.
         */
        removeEditorPoints(emptyArray) {
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                point.DestroyEntity();
            }
            if (emptyArray) {
                this.editorPoints = [];
            }
        }
        removeEditorPointsForMap(mapId) {
            let newArray = [];
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                if (point.hierarchyId == mapId) {
                    point.DestroyEntity();
                }
                else {
                    newArray.push(point);
                }
            }
            this.editorPoints = newArray;
        }
        /**
         * Returns editing point from this editor from given screen position.
         * @param screenPos
         * @returns
         */
        getEditorPointFromMouse(screenPos) {
            if (cesium_utils_17.CesiumUtils.Validate2DPosition(screenPos)) {
                let viewer = this.viewer;
                let pickedObjects = viewer.scene.drillPick(screenPos, 5);
                for (let i = 0; i < pickedObjects.length; i++) {
                    let pickedObject = pickedObjects[i];
                    if (pickedObject.id instanceof Cesium.Entity) {
                        pickedObject = pickedObject.id;
                    }
                    if (pickedObject && pickedObject._cesiumGeometryEditorPointId) {
                        let point = this.editorPoints.find(x => x.posId == pickedObject._cesiumGeometryEditorPointId);
                        if (point) {
                            return point;
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Returns editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @returns
         */
        getEditorPointPosition(posId, hierarchyId) {
            let hierarchyMap = this.editingMap.GetMap(hierarchyId).positions;
            return hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Get(posId);
        }
        /**
         * Creates an editor point for a given point id at a given branch id.
         * @param posId
         * @param hierarchyId
         */
        createEditorPoint(posId, hierarchyId) {
            let point = new CesiumGeometryEditorPointExtended({
                hierarchyId: hierarchyId,
                getPosition: () => this.getEditorPointPosition(posId, hierarchyId),
                showCallback: () => true,
                updatePosition: (position) => {
                    this.updateEditorPointPosition(posId, hierarchyId, position);
                },
                viewer: this.viewer,
                color: this.editorPointColor,
                pixelSize: this.editorPointSize,
                posId: posId,
                heightReference: this.heightReference
            });
            point.CreateEntity();
            this.editorPoints.push(point);
        }
        /**
         * Updates editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @param position
         */
        updateEditorPointPosition(posId, hierarchyId, position) {
            let hierarchyMap = this.editingMap.GetMap(hierarchyId).positions;
            hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Update(posId, position);
        }
        /**
         * Updates the clicked offset from the entity's position.
         * @param screenPos
         */
        updateOffset(screenPos) {
            if (this.activePoint) {
                let position = this.activePoint.lastPosition;
                if (this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
                    let grounded = Cesium.Cartographic.fromCartesian(position);
                    let height = this.heightSampler.Pick(grounded);
                    position = Cesium.Cartesian3.fromRadians(grounded.longitude, grounded.latitude, height);
                }
                if (cesium_utils_17.CesiumUtils.ValidatePosition(position)) {
                    let entityScreenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, position);
                    if (cesium_utils_17.CesiumUtils.Validate2DPosition(entityScreenPos)) {
                        this.mouseOffset.x = entityScreenPos.x - screenPos.x;
                        this.mouseOffset.y = entityScreenPos.y - screenPos.y;
                    }
                }
            }
        }
        /**
         * Updates cursor styling depending on if editing point is found underneath.
         * @param screenPos
         */
        setPointerCursor(screenPos) {
            let point = this.getEditorPointFromMouse(screenPos);
            if (point) {
                document.body.style.cursor = "pointer";
            }
            else {
                document.body.style.removeProperty("cursor");
            }
        }
        /**
         * Updates the screen cursor styling to be grabbing.
         */
        setGrabCursor() {
            document.body.style.cursor = "grabbing";
        }
        /**
         * Removes cursor styling.
         */
        removeCursor() {
            document.body.style.removeProperty("cursor");
        }
        updateGeometry() {
            if (!this._started || this._disposed) {
                return;
            }
            let map = this.editingMap;
            let polygonHierarchy = map.ConstructCesiumHierarchy();
            polygonHierarchy.positions = this.smoothenPoints(polygonHierarchy.positions);
            polygonHierarchy.positions = cesium_drawing_utils_9.CesiumDrawingUtils.ClosePolygon(polygonHierarchy.positions);
            for (let i = 0; i < polygonHierarchy.holes.length; i++) {
                let hole = polygonHierarchy.holes[i];
                hole.positions = this.smoothenPoints(hole.positions);
                hole.positions = cesium_drawing_utils_9.CesiumDrawingUtils.ClosePolygon(hole.positions);
            }
            this.editingEntityHierarchy = polygonHierarchy;
            let root = this.editingEntity;
            if (root && root.polygon) {
                if (!(root.polygon.hierarchy instanceof Cesium.Property)) {
                    root.polygon.hierarchy = new Cesium.CallbackProperty(() => this.editingEntityHierarchy, false);
                }
                if (root.polyline && (!(root.polyline.positions instanceof Cesium.Property))) {
                    root.polyline.positions = new Cesium.CallbackProperty(() => {
                        var _a;
                        let posses = (_a = this.editingEntityHierarchy) === null || _a === void 0 ? void 0 : _a.positions;
                        return posses ? posses : [];
                    }, false);
                }
                this.updatePolygonVisual(root, map);
                this.viewer.scene.requestRender();
            }
        }
        updatePolygonVisual(root, map) {
            let polygonHierarchy = this.editingEntityHierarchy;
            // Process holes.
            let entities = cesium_entity_utils_9.CesiumEntityUtils.getAllEntities(root);
            let holeIndex = 0;
            for (let i = 0; i < entities.length; i++) {
                let entity = entities[i];
                if (cesium_entity_utils_9.CesiumEntityUtils.isInnerEntity(entity)) {
                    if (entity.polyline) {
                        let hole = polygonHierarchy.holes[holeIndex];
                        if (hole) {
                            entity.polyline.positions = hole.positions;
                            holeIndex += 1;
                        }
                        else {
                            cesium_entity_utils_9.CesiumEntityUtils.removeInnerEntity(root, entity);
                            this.viewer.entities.remove(entity);
                        }
                    }
                }
            }
            // Create missing holes.
            if (this.outlineWidth) {
                entities = cesium_entity_utils_9.CesiumEntityUtils.getAllEntities(root);
                let holeIds = map.GetInnerMapIds();
                for (let i = 0; i < holeIds.length; i++) {
                    let holeId = holeIds[i];
                    let index = entities.findIndex(x => x._bruceHierarchyMapRefId == holeId);
                    if (index <= -1) {
                        let holeMap = map.GetMap(holeId);
                        let posses = holeMap.positions.getPositions();
                        posses = this.smoothenPoints(posses);
                        let color = this.outlineColor;
                        if (typeof color == "string") {
                            color = Cesium.Color.fromCssColorString(color);
                        }
                        let holeEntity = new Cesium.Entity({
                            polyline: {
                                positions: posses,
                                material: color,
                                width: this.outlineWidth,
                                classificationType: Cesium.ClassificationType.TERRAIN,
                                arcType: Cesium.ArcType.GEODESIC,
                                clampToGround: this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND ? true : undefined
                            },
                            parent: root
                        });
                        cesium_entity_utils_9.CesiumEntityUtils.MarkarkAsInner(holeEntity);
                        holeEntity._bruceHierarchyMapRefId = holeId;
                        this.viewer.entities.add(holeEntity);
                        this.viewer.scene.requestRender();
                    }
                }
            }
        }
        unlinkGeometry() {
            let root = this.editingEntity;
            if (root) {
                if (root.polygon) {
                    let hierarchy = root.polygon.hierarchy;
                    if (hierarchy instanceof Cesium.CallbackProperty) {
                        let val = cesium_utils_17.CesiumUtils.getCesiumValue(this.viewer, hierarchy);
                        root.polygon.hierarchy = val;
                    }
                }
                if (root.polyline) {
                    let posses = root.polyline.positions;
                    if (posses instanceof Cesium.CallbackProperty) {
                        let val = cesium_utils_17.CesiumUtils.getCesiumValue(this.viewer, posses);
                        root.polyline.positions = val;
                    }
                }
                this.viewer.scene.requestRender();
            }
        }
        smoothenPoints(points) {
            let times = this.smoothen;
            if (points && points.length > 2 && times > 0) {
                let dots = [];
                for (let i = 0; i < points.length; i++) {
                    let point = points[i];
                    let carto = Cesium.Cartographic.fromCartesian(point);
                    if (cartographic_6.Cartographic.Validate(carto)) {
                        dots.push({ x: carto.longitude, y: carto.latitude });
                    }
                    else {
                        return points;
                    }
                }
                let output = drawing_utils_3.DrawingUtils.ChaikinSmooth(dots, true);
                for (let i = 0; i < times - 1; i++) {
                    output = drawing_utils_3.DrawingUtils.ChaikinSmooth(output, true);
                }
                let newPoints = [];
                for (let i = 0; i < output.length; i++) {
                    let dot = output[i];
                    let newPoint = Cesium.Cartesian3.fromRadians(dot.x, dot.y);
                    if (cesium_utils_17.CesiumUtils.ValidatePosition(newPoint)) {
                        newPoints.push(newPoint);
                    }
                    else {
                        return points;
                    }
                }
                return newPoints;
            }
            return points;
        }
        /**
         * Returns 3d position from given screen position.
         * @param pos2d
         */
        getCartesian3FromMouse(pos2d) {
            let terrainPos = cesium_drawing_utils_9.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, pos2d);
            if (this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
                return terrainPos;
            }
            // We have to make sure to ignore the entity we are editing and the editing points.
            else {
                // Firefox has problems. 
                // Not sure if other browsers have the same problems.
                if (this.browser == browser_utils_1.EBrowser.Firefox) {
                    return cesium_drawing_utils_9.CesiumDrawingUtils.GetCartesian3FromMouse(this.viewer, pos2d);
                }
                else {
                    let ignoreEntities = [this.editingEntity];
                    for (let i = 0; i < this.editorPoints.length; i++) {
                        let point = this.editorPoints[i];
                        let pointEntities = point.entities;
                        ignoreEntities = ignoreEntities.concat(pointEntities);
                    }
                    if (this.ignoreEntities) {
                        ignoreEntities = ignoreEntities.concat(this.ignoreEntities);
                    }
                    let data = cesium_drawing_utils_9.CesiumDrawingUtils.RaycastDrillEntities(this.viewer, this.viewer.camera.position, terrainPos, ignoreEntities);
                    if (data && data.length > 0) {
                        return data[0].position;
                    }
                }
            }
            return terrainPos;
        }
    }
    exports.CesiumPolygonGeometryEditor3 = CesiumPolygonGeometryEditor3;
});
define("entry-points/cesium/common/cesium-polygon-geometry-creator", ["require", "exports", "cesium", "bruce-models/common/bruce-info", "bruce-models/common/geometry", "bruce-models/common/polygon", "utils/delay-queue", "entry-points/cesium/common/cesium-cached-picking-height-util", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-geometry-editor-point", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-polygon-hierarchy-map", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, bruce_info_6, geometry_8, polygon_10, delay_queue_5, cesium_cached_picking_height_util_5, cesium_drawing_utils_10, cesium_geometry_editor_point_4, cesium_mouse_events_5, cesium_polygon_hierarchy_map_4, cesium_utils_18) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPolygonGeometryCreator = void 0;
    Cesium = __importStar(Cesium);
    /**
     * Initialize then call 'Start' to let the user click points in the map to draw a polygon.
     * Once happy the call 'Finish' to get the drawn geometry and changes to siblings for no intersections to be active.
     */
    class CesiumPolygonGeometryCreator {
        constructor(params) {
            this.zIndex = 5;
            this._disposed = false;
            this._started = false;
            // Clicked offset from the editor point's center point.
            this.mouseOffset = new Cesium.Cartesian2(0, 0);
            // Polygon map representing currently drawn polygon positions.
            this.drawingMap = new cesium_polygon_hierarchy_map_4.CesiumPolygonHierarchyMap();
            // Editor points created for map positions.
            this.editorPoints = [];
            this.viewer = params.viewer;
            if (params.fillColor) {
                this.fillColor = params.fillColor;
            }
            else {
                this.fillColor = "white";
            }
            if (params.outlineColor) {
                this.outlineColor = params.outlineColor;
            }
            else {
                this.outlineColor = "grey";
            }
            if (params.outlineWidth == null) {
                this.outlineWidth = 1;
            }
            else {
                this.outlineWidth = params.outlineWidth;
            }
            this.updateGeometriesQueue = new delay_queue_5.DelayQueue(() => {
                this.updateGeometry();
            }, 100);
            this.heightSampler = new cesium_cached_picking_height_util_5.CesiumCachedPickingHeightUtil(this.cViewer);
        }
        get cViewer() {
            var _a;
            return (_a = this.viewer) === null || _a === void 0 ? void 0 : _a.CesiumViewer;
        }
        get disposed() {
            return this._disposed;
        }
        get started() {
            return this._started;
        }
        Start() {
            if (this._disposed) {
                throw (">>Error: Cannot start creator that has been disposed.");
            }
            if (!this._started) {
                this.startMouseListeners();
                this._started = true;
            }
        }
        Stop() {
            if (this._disposed) {
                throw (">>Error: Cannot stop creator that has been disposed.");
            }
            if (this._started) {
                this.stopMouseListeners();
                this.clear();
                this.removeCursor();
                this._started = false;
            }
        }
        /**
         * @param api: api reference for disjoint request.
         * @param siblings: what siblings to cut intersections out of.
         * @param boundary
         */
        Finish(api, siblings, boundary) {
            return __awaiter(this, void 0, void 0, function* () {
                if (this._disposed || !this._started) {
                    throw (">>Error: Cannot finish creator that has been disposed or stopped.");
                }
                // Prepare data for intersection tests.
                let polygon = this.drawingMap.ConstructBrucePolygon();
                let tmpInfo = new bruce_info_6.BruceInfo(null);
                tmpInfo.geometry = new geometry_8.Geometry(null);
                tmpInfo.geometry.Polygon = polygon;
                tmpInfo.Bruce.ID = "TMP";
                if (boundary) {
                    try {
                        tmpInfo = (yield bruce_info_6.BruceInfo.TruncateEntities(api, [tmpInfo], boundary))[0];
                    }
                    catch (_a) {
                    }
                }
                let updatedInfos = [];
                for (let i = 0; i < siblings.length; i++) {
                    let sibling = siblings[i];
                    try {
                        let data = yield bruce_info_6.BruceInfo.DisjointEntities(api, [sibling, tmpInfo]);
                        let updated = data.find(x => x.Bruce.ID == sibling.Bruce.ID);
                        if (updated) {
                            updatedInfos.push(updated);
                        }
                    }
                    catch (_b) {
                    }
                }
                let data = {
                    geometry: tmpInfo.geometry,
                    updatedSiblings: updatedInfos
                };
                this.Stop();
                return data;
            });
        }
        Dispose() {
            if (!this._disposed) {
                this.Stop();
                this.heightSampler.Dispose();
                this._disposed = true;
            }
        }
        clear() {
            this.drawingMap = new cesium_polygon_hierarchy_map_4.CesiumPolygonHierarchyMap();
            if (this.drawingEntity && this.cViewer.entities.contains(this.drawingEntity)) {
                this.cViewer.entities.remove(this.drawingEntity);
            }
            this.drawingEntity = null;
            this.removeEditorPoints(true);
        }
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_5.CesiumMouseEvents(this.cViewer);
                this.mouseHandler.LeftDownEvent.Subscribe((data) => {
                    this.doMouseLeftDown(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.LeftUpEvent.Subscribe((data) => {
                    this.doMouseLeftUp();
                });
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.RightClickEvent.Subscribe((data) => {
                    this.doMouseRightClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doMouseClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.MiddleClickEvent.Subscribe((data) => {
                    // Middle mouse is used for starting new holes.
                    // Holes are not supported in the creation tool, only editing tool.
                    //this.doMouseMiddleClick(data.position);
                });
                this.mouseHandler.EnableEventHandling();
            }
        }
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.Dispose();
                this.mouseHandler = null;
            }
        }
        doMouseClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = cesium_drawing_utils_10.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.cViewer, screenPos);
                    if (cesium_utils_18.CesiumUtils.ValidatePosition(pos3d)) {
                        this.addPosition(pos3d);
                    }
                }
            }
        }
        doMouseRightClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.removePoint(point);
                }
            }
        }
        doMouseMove(screenPos) {
            let updatedPos = true;
            if (cesium_utils_18.CesiumUtils.Validate2DPosition(screenPos)) {
                screenPos.x += this.mouseOffset.x;
                screenPos.y += this.mouseOffset.y;
                let pos3d = cesium_drawing_utils_10.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer.CesiumViewer, screenPos);
                if (cesium_utils_18.CesiumUtils.ValidatePosition(pos3d)) {
                    if (this.activePoint) {
                        updatedPos = false;
                        this.activePoint.updatePosition(pos3d);
                        this.updateGeometriesQueue.Call(false);
                    }
                }
            }
            if (updatedPos) {
                this.setPointerCursor(screenPos);
            }
        }
        doMouseLeftUp() {
            if (this.activePoint) {
                this.activePoint = null;
                this.viewer.cameraHandler.isFrozen = false;
            }
        }
        doMouseLeftDown(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.activePoint = point;
                    this.updateOffset(screenPos);
                    this.setGrabCursor();
                    this.viewer.cameraHandler.isFrozen = true;
                }
            }
        }
        /**
         * Removes drawing point and associated map data.
         * @param point
         */
        removePoint(point) {
            let map = this.drawingMap;
            if (map) {
                let outMap = map.GetOutMap();
                if (outMap) {
                    let pointsLeft = outMap.GetIds().length;
                    if (pointsLeft > 0) {
                        outMap.Remove(point.posId);
                        let index = this.editorPoints.findIndex(x => x.posId == point.posId);
                        this.editorPoints.splice(index, 1);
                        point.DestroyEntity();
                    }
                    this.updateGeometriesQueue.Call(true);
                }
            }
        }
        /**
         * Adds new position to nearest outer ring line.
         * @param position
         */
        addPosition(position) {
            let outMapId = this.drawingMap.GetOutMapId();
            if (!outMapId) {
                outMapId = this.drawingMap.AddMap(polygon_10.PolygonFacing.out);
            }
            let outMap = this.drawingMap.GetMap(outMapId);
            // Can't find nearest line yet.
            if (outMap.positions.getPositions().length < 2) {
                let posId = outMap.positions.Add(position);
                this.createEditorPoint(posId, outMapId);
            }
            else {
                let insertIndex = this.drawingMap.GetInsertIndex(outMapId, position);
                let posId = outMap.positions.Insert(position, insertIndex);
                this.createEditorPoint(posId, outMapId);
            }
            this.updateGeometriesQueue.Call(true);
        }
        /**
         * Returns editing point from this editor from given screen position.
         * @param screenPos
         * @returns
         */
        getEditorPointFromMouse(screenPos) {
            if (cesium_utils_18.CesiumUtils.Validate2DPosition(screenPos)) {
                let viewer = this.cViewer;
                let pickedObjects = viewer.scene.drillPick(screenPos, 5);
                for (let i = 0; i < pickedObjects.length; i++) {
                    let pickedObject = pickedObjects[i];
                    if (pickedObject.id instanceof Cesium.Entity) {
                        pickedObject = pickedObject.id;
                    }
                    if (pickedObject && pickedObject._cesiumGeometryEditorPointId) {
                        let point = this.editorPoints.find(x => x.posId == pickedObject._cesiumGeometryEditorPointId);
                        if (point) {
                            return point;
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Creates an editor point for a given point id at a given branch id.
         * @param posId
         * @param hierarchyId
         */
        createEditorPoint(posId, hierarchyId) {
            let point = new cesium_geometry_editor_point_4.CesiumGeometryEditorPoint({
                posId: posId,
                getPosition: () => this.getEditorPointPosition(posId, hierarchyId),
                showCallback: () => true,
                updatePosition: (position) => {
                    this.updateEditorPointPosition(posId, hierarchyId, position);
                },
                viewer: this.cViewer
            });
            point.CreateEntity();
            this.editorPoints.push(point);
        }
        /**
         * Updates editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @param position
         */
        updateEditorPointPosition(posId, hierarchyId, position) {
            let hierarchyMap = this.drawingMap.GetMap(hierarchyId).positions;
            hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Update(posId, position);
        }
        /**
         * Returns editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @returns
         */
        getEditorPointPosition(posId, hierarchyId) {
            let hierarchyMap = this.drawingMap.GetMap(hierarchyId).positions;
            return hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Get(posId);
        }
        updateGeometry() {
            let change = false;
            let map = this.drawingMap;
            let root = this.drawingEntity;
            if (root && !this.cViewer.entities.contains(root)) {
                root = null;
            }
            if (root) {
                if (!root.polygon) {
                    this.createPolygonVisual(root);
                }
            }
            else {
                root = this.drawingEntity = new Cesium.Entity();
                this.cViewer.entities.add(root);
                this.createPolygonVisual(root);
            }
            if (root.polygon) {
                this.updatePolygonVisual(root, map);
                change = true;
            }
            if (change) {
                this.cViewer.scene.requestRender();
            }
        }
        createPolygonVisual(entity) {
            let fillColor = this.fillColor;
            if (typeof fillColor == "string") {
                fillColor = Cesium.Color.fromCssColorString(fillColor);
            }
            entity.polygon = new Cesium.PolygonGraphics({
                material: fillColor,
                shadows: Cesium.ShadowMode.ENABLED,
                heightReference: Cesium.HeightReference.CLAMP_TO_GROUND,
                classificationType: Cesium.ClassificationType.BOTH
            });
        }
        updatePolygonVisual(root, map) {
            let polygonHierarchy = map.ConstructCesiumHierarchy();
            // First cover outer loop.
            root.polygon.hierarchy = polygonHierarchy;
            if (root.polyline) {
                root.polyline.positions = polygonHierarchy.positions;
            }
            else if (this.outlineWidth) {
                let color = this.outlineColor;
                if (typeof color == "string") {
                    color = Cesium.Color.fromCssColorString(color);
                }
                root.polyline = new Cesium.PolylineGraphics({
                    positions: polygonHierarchy.positions,
                    clampToGround: true,
                    material: color,
                    width: this.outlineWidth,
                    classificationType: Cesium.ClassificationType.TERRAIN,
                    arcType: Cesium.ArcType.GEODESIC,
                    zIndex: this.zIndex
                });
            }
        }
        /**
         * Updates the clicked offset from the entity's position.
         * @param screenPos
         */
        updateOffset(screenPos) {
            if (this.activePoint) {
                let position = this.activePoint.lastPosition;
                let grounded = Cesium.Cartographic.fromCartesian(position);
                let height = this.heightSampler.Pick(grounded);
                position = Cesium.Cartesian3.fromRadians(grounded.longitude, grounded.latitude, height);
                if (cesium_utils_18.CesiumUtils.ValidatePosition(position)) {
                    let entityScreenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.CesiumViewer.scene, position);
                    if (cesium_utils_18.CesiumUtils.Validate2DPosition(entityScreenPos)) {
                        this.mouseOffset.x = entityScreenPos.x - screenPos.x;
                        this.mouseOffset.y = entityScreenPos.y - screenPos.y;
                    }
                }
            }
        }
        /**
         * Removes editing point visuals.
         * @param emptyArray If array of editor points should be cleared.
         */
        removeEditorPoints(emptyArray) {
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                point.DestroyEntity();
            }
            if (emptyArray) {
                this.editorPoints = [];
            }
        }
        /**
         * Updates cursor styling depending on if editing point is found underneath.
         * @param screenPos
         */
        setPointerCursor(screenPos) {
            let point = this.getEditorPointFromMouse(screenPos);
            if (point) {
                document.body.style.cursor = "pointer";
            }
            else {
                document.body.style.removeProperty("cursor");
            }
        }
        /**
         * Updates the screen cursor styling to be grabbing.
         */
        setGrabCursor() {
            document.body.style.cursor = "grabbing";
        }
        /**
         * Removes cursor styling.
         */
        removeCursor() {
            document.body.style.removeProperty("cursor");
        }
    }
    exports.CesiumPolygonGeometryCreator = CesiumPolygonGeometryCreator;
});
define("entry-points/cesium/common/cesium-polygon-geometry-creator2", ["require", "exports", "cesium", "bruce-models/common/cartographic", "bruce-models/common/polygon", "utils/bruce-event", "utils/delay-queue", "utils/drawing-utils", "entry-points/cesium/common/cesium-cached-picking-height-util", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-geometry-editor-point", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-polygon-hierarchy-map", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, cartographic_7, polygon_11, bruce_event_10, delay_queue_6, drawing_utils_4, cesium_cached_picking_height_util_6, cesium_drawing_utils_11, cesium_geometry_editor_point_5, cesium_mouse_events_6, cesium_polygon_hierarchy_map_5, cesium_utils_19) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPolygonGeometryCreator2 = void 0;
    Cesium = __importStar(Cesium);
    class CesiumPolygonGeometryCreator2 {
        constructor(params) {
            this.zIndex = 5;
            this._disposed = false;
            this._started = false;
            // If a primitive should be used for the generated graphic.
            this.usePrimitive = false;
            // Height reference for the drawn points.
            this.heightReference = Cesium.HeightReference.CLAMP_TO_GROUND;
            // Clicked offset from the editor point's center point.
            this.mouseOffset = new Cesium.Cartesian2(0, 0);
            // Polygon map representing currently drawn polygon positions.
            this.drawingMap = new cesium_polygon_hierarchy_map_5.CesiumPolygonHierarchyMap();
            // Entities representing the currently drawn polygon.
            this.drawingEntities = [];
            // Editor points created for map positions.
            this.editorPoints = [];
            // Notifies when there is any change in the tool.
            this.onUpdateEvent = new bruce_event_10.BruceEvent();
            this.viewer = params.viewer;
            this.cameraHandler = params.cameraHandler;
            if (params.fillColor) {
                this.fillColor = params.fillColor;
            }
            else {
                this.fillColor = "white";
            }
            if (params.outlineColor) {
                this.outlineColor = params.outlineColor;
            }
            else {
                this.outlineColor = "grey";
            }
            if (params.outlineWidth == null) {
                this.outlineWidth = 1;
            }
            else {
                this.outlineWidth = params.outlineWidth;
            }
            if (params.smoothen) {
                this.smoothen = params.smoothen;
            }
            else {
                this.smoothen = 0;
            }
            if (params.heightReference != null) {
                this.heightReference = params.heightReference;
            }
            if (params.usePrimitive != null) {
                this.usePrimitive = params.usePrimitive;
            }
            this.editorPointColor = params.editorPointColor;
            this.editorPointSize = params.editorPointSize;
            this.updateGeometriesQueue = new delay_queue_6.DelayQueue(() => {
                this.updateGeometry();
            }, this.usePrimitive ? 50 : 100);
            this.heightSampler = new cesium_cached_picking_height_util_6.CesiumCachedPickingHeightUtil(this.viewer);
        }
        get disposed() {
            return this._disposed;
        }
        get started() {
            return this._started;
        }
        getOnChangeEvent() {
            return this.onUpdateEvent;
        }
        Start() {
            if (this._disposed) {
                throw (">>Error: Cannot start creator that has been disposed.");
            }
            if (!this._started) {
                this.startMouseListeners();
                this._started = true;
            }
        }
        /**
         * Returns polygon that represents the current visual.
         */
        getPolygon() {
            return this.drawingMap.ConstructBrucePolygon();
        }
        Stop() {
            if (this._disposed) {
                throw (">>Error: Cannot stop creator that has been disposed.");
            }
            if (this._started) {
                this.stopMouseListeners();
                this.clear();
                this.removeCursor();
                this._started = false;
            }
        }
        /**
         * Sets smoothen level, if changed then a refresh on visual is queued.
         * @param value
         */
        SetSmoothen(value) {
            if (this.smoothen != value) {
                this.smoothen = value;
                this.updateGeometriesQueue.Call(false);
            }
        }
        Dispose() {
            if (!this._disposed) {
                this.Stop();
                this.heightSampler.Dispose();
                this._disposed = true;
            }
        }
        clear() {
            this.drawingMap = new cesium_polygon_hierarchy_map_5.CesiumPolygonHierarchyMap();
            for (let i = 0; i < this.drawingEntities.length; i++) {
                let entity = this.drawingEntities[i];
                if (entity instanceof Cesium.Primitive) {
                    if (this.viewer.scene.primitives.contains(entity)) {
                        this.viewer.scene.primitives.remove(entity);
                    }
                }
                else {
                    if (this.viewer.entities.contains(entity)) {
                        this.viewer.entities.remove(entity);
                    }
                }
            }
            this.drawingEntities = [];
            this.removeEditorPoints(true);
        }
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_6.CesiumMouseEvents(this.viewer);
                this.mouseHandler.LeftDownEvent.Subscribe((data) => {
                    this.doMouseLeftDown(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.LeftUpEvent.Subscribe((data) => {
                    this.doMouseLeftUp();
                });
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.RightClickEvent.Subscribe((data) => {
                    this.doMouseRightClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doMouseClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.MiddleClickEvent.Subscribe((data) => {
                    // Middle mouse is used for starting new holes.
                    // Holes are not supported in the creation tool, only editing tool.
                    //this.doMouseMiddleClick(data.position);
                });
                this.mouseHandler.EnableEventHandling();
            }
        }
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.Dispose();
                this.mouseHandler = null;
            }
        }
        doMouseClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d;
                    if (this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
                        pos3d = cesium_drawing_utils_11.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                    }
                    else {
                        pos3d = cesium_drawing_utils_11.CesiumDrawingUtils.GetCartesian3FromMouse(this.viewer, screenPos);
                    }
                    if (cesium_utils_19.CesiumUtils.ValidatePosition(pos3d)) {
                        this.addPosition(pos3d);
                    }
                }
            }
        }
        doMouseRightClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.removePoint(point);
                }
            }
        }
        doMouseMove(screenPos) {
            let updatedPos = true;
            if (cesium_utils_19.CesiumUtils.Validate2DPosition(screenPos)) {
                screenPos.x += this.mouseOffset.x;
                screenPos.y += this.mouseOffset.y;
                let pos3d;
                if (this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
                    pos3d = cesium_drawing_utils_11.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                }
                else {
                    pos3d = cesium_drawing_utils_11.CesiumDrawingUtils.GetCartesian3FromMouse(this.viewer, screenPos);
                }
                if (cesium_utils_19.CesiumUtils.ValidatePosition(pos3d)) {
                    if (this.activePoint) {
                        updatedPos = false;
                        this.activePoint.updatePosition(pos3d);
                        this.updateGeometriesQueue.Call(false);
                    }
                }
            }
            if (updatedPos) {
                this.setPointerCursor(screenPos);
            }
        }
        doMouseLeftUp() {
            if (this.activePoint) {
                this.activePoint = null;
                this.cameraHandler.isFrozen = false;
            }
        }
        doMouseLeftDown(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.activePoint = point;
                    this.updateOffset(screenPos);
                    this.setGrabCursor();
                    this.cameraHandler.isFrozen = true;
                }
            }
        }
        /**
         * Removes drawing point and associated map data.
         * @param point
         */
        removePoint(point) {
            let map = this.drawingMap;
            if (map) {
                let outMap = map.GetOutMap();
                if (outMap) {
                    let pointsLeft = outMap.GetIds().length;
                    if (pointsLeft > 0) {
                        outMap.Remove(point.posId);
                        let index = this.editorPoints.findIndex(x => x.posId == point.posId);
                        this.editorPoints.splice(index, 1);
                        point.DestroyEntity();
                    }
                    this.updateGeometriesQueue.Call(true);
                }
            }
        }
        /**
         * Adds new position to nearest outer ring line.
         * @param position
         */
        addPosition(position) {
            let outMapId = this.drawingMap.GetOutMapId();
            if (!outMapId) {
                outMapId = this.drawingMap.AddMap(polygon_11.PolygonFacing.out);
            }
            let outMap = this.drawingMap.GetMap(outMapId);
            // Can't find nearest line yet.
            if (outMap.positions.getPositions().length < 2) {
                let posId = outMap.positions.Add(position);
                this.createEditorPoint(posId, outMapId);
            }
            else {
                let insertIndex = this.drawingMap.GetInsertIndex(outMapId, position);
                let posId = outMap.positions.Insert(position, insertIndex);
                this.createEditorPoint(posId, outMapId);
            }
            this.updateGeometriesQueue.Call(true);
        }
        /**
         * Returns editing point from this editor from given screen position.
         * @param screenPos
         * @returns
         */
        getEditorPointFromMouse(screenPos) {
            if (cesium_utils_19.CesiumUtils.Validate2DPosition(screenPos)) {
                let viewer = this.viewer;
                let pickedObjects = viewer.scene.drillPick(screenPos, 5);
                for (let i = 0; i < pickedObjects.length; i++) {
                    let pickedObject = pickedObjects[i];
                    if (pickedObject.id instanceof Cesium.Entity) {
                        pickedObject = pickedObject.id;
                    }
                    if (pickedObject && pickedObject._cesiumGeometryEditorPointId) {
                        let point = this.editorPoints.find(x => x.posId == pickedObject._cesiumGeometryEditorPointId);
                        if (point) {
                            return point;
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Creates an editor point for a given point id at a given branch id.
         * @param posId
         * @param hierarchyId
         */
        createEditorPoint(posId, hierarchyId) {
            let point = new cesium_geometry_editor_point_5.CesiumGeometryEditorPoint({
                posId: posId,
                getPosition: () => this.getEditorPointPosition(posId, hierarchyId),
                showCallback: () => true,
                updatePosition: (position) => {
                    this.updateEditorPointPosition(posId, hierarchyId, position);
                },
                viewer: this.viewer,
                color: this.editorPointColor,
                pixelSize: this.editorPointSize,
                heightReference: this.heightReference
            });
            point.CreateEntity();
            this.editorPoints.push(point);
        }
        /**
         * Updates editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @param position
         */
        updateEditorPointPosition(posId, hierarchyId, position) {
            let hierarchyMap = this.drawingMap.GetMap(hierarchyId).positions;
            hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Update(posId, position);
        }
        /**
         * Returns editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @returns
         */
        getEditorPointPosition(posId, hierarchyId) {
            let hierarchyMap = this.drawingMap.GetMap(hierarchyId).positions;
            return hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Get(posId);
        }
        updateGeometry() {
            let map = this.drawingMap;
            let polygonHierarchy = map.ConstructCesiumHierarchy();
            this.smoothenPoints(polygonHierarchy.positions);
            polygonHierarchy.positions.pop();
            polygonHierarchy.positions = this.smoothenPoints(polygonHierarchy.positions);
            polygonHierarchy.positions = cesium_drawing_utils_11.CesiumDrawingUtils.ClosePolygon(polygonHierarchy.positions);
            this.drawingEntityHierarchy = polygonHierarchy;
            if (this.usePrimitive) {
                this.createPrimitiveVisual();
            }
            else if (this.drawingEntities.length < 1) {
                this.drawingEntities = [this.viewer.entities.add(new Cesium.Entity({}))];
                this.createPolygonVisual(this.drawingEntities[0]);
            }
            this.viewer.scene.requestRender();
            this.onUpdateEvent.Trigger();
        }
        createPolygonVisual(entity) {
            let fillColor = this.fillColor;
            if (typeof fillColor == "string") {
                fillColor = Cesium.Color.fromCssColorString(fillColor);
            }
            entity.polygon = new Cesium.PolygonGraphics({
                material: fillColor,
                shadows: Cesium.ShadowMode.ENABLED,
                heightReference: this.heightReference,
                perPositionHeight: this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND ? undefined : true,
                classificationType: Cesium.ClassificationType.BOTH,
                hierarchy: new Cesium.CallbackProperty(() => this.drawingEntityHierarchy, false)
            });
            let color = this.outlineColor;
            if (typeof color == "string") {
                color = Cesium.Color.fromCssColorString(color);
            }
            entity.polyline = new Cesium.PolylineGraphics({
                positions: new Cesium.CallbackProperty(() => {
                    var _a;
                    let posses = (_a = this.drawingEntityHierarchy) === null || _a === void 0 ? void 0 : _a.positions;
                    return posses ? posses : [];
                }, false),
                clampToGround: this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND ? true : undefined,
                material: color,
                width: this.outlineWidth,
                classificationType: Cesium.ClassificationType.TERRAIN,
                arcType: Cesium.ArcType.GEODESIC,
                zIndex: this.zIndex
            });
        }
        createPrimitiveVisual() {
            var _a;
            for (let i = 0; i < this.drawingEntities.length; i++) {
                let entity = this.drawingEntities[i];
                if (this.viewer.scene.primitives.contains(entity)) {
                    this.viewer.scene.primitives.remove(entity);
                }
            }
            this.drawingEntities = [];
            let posses = (_a = this.drawingEntityHierarchy) === null || _a === void 0 ? void 0 : _a.positions;
            let color = this.outlineColor;
            if (typeof color == "string") {
                color = Cesium.Color.fromCssColorString(color);
            }
            if (!posses || posses.length < 2) {
                return;
            }
            let polyline = this.viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                    geometry: new Cesium.PolylineGeometry({
                        positions: posses,
                        width: this.outlineWidth,
                        vertexFormat: Cesium.PolylineMaterialAppearance.VERTEX_FORMAT
                    })
                }),
                appearance: new Cesium.PolylineMaterialAppearance({
                    material: new Cesium.Material({
                        fabric: {
                            type: "Color",
                            uniforms: {
                                color: color
                            }
                        }
                    }),
                    renderState: {
                        depthTest: {
                            enabled: false
                        }
                    }
                }),
                asynchronous: false
            }));
            this.drawingEntities.push(polyline);
            if (posses.length < 3) {
                return;
            }
            let fillColor = this.fillColor;
            if (typeof fillColor == "string") {
                fillColor = Cesium.Color.fromCssColorString(fillColor);
            }
            let polygon = this.viewer.scene.primitives.add(new Cesium.Primitive({
                geometryInstances: new Cesium.GeometryInstance({
                    geometry: Cesium.PolygonGeometry.createGeometry(Cesium.PolygonGeometry.fromPositions({
                        positions: posses,
                        perPositionHeight: true
                    }))
                }),
                appearance: new Cesium.EllipsoidSurfaceAppearance({
                    material: new Cesium.Material({
                        fabric: {
                            type: "Color",
                            uniforms: {
                                color: fillColor
                            }
                        }
                    }),
                    renderState: {
                        depthTest: {
                            enabled: false
                        }
                    },
                    aboveGround: true
                }),
                asynchronous: false
            }));
            this.drawingEntities.push(polygon);
        }
        /**
         * Updates the clicked offset from the entity's position.
         * @param screenPos
         */
        updateOffset(screenPos) {
            if (this.activePoint) {
                let position = this.activePoint.lastPosition;
                if (this.heightReference == Cesium.HeightReference.CLAMP_TO_GROUND) {
                    let grounded = Cesium.Cartographic.fromCartesian(position);
                    let height = this.heightSampler.Pick(grounded);
                    position = Cesium.Cartesian3.fromRadians(grounded.longitude, grounded.latitude, height);
                }
                if (cesium_utils_19.CesiumUtils.ValidatePosition(position)) {
                    let entityScreenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, position);
                    if (cesium_utils_19.CesiumUtils.Validate2DPosition(entityScreenPos)) {
                        this.mouseOffset.x = entityScreenPos.x - screenPos.x;
                        this.mouseOffset.y = entityScreenPos.y - screenPos.y;
                    }
                }
            }
        }
        /**
         * Removes editing point visuals.
         * @param emptyArray If array of editor points should be cleared.
         */
        removeEditorPoints(emptyArray) {
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                point.DestroyEntity();
            }
            if (emptyArray) {
                this.editorPoints = [];
            }
        }
        /**
         * Updates cursor styling depending on if editing point is found underneath.
         * @param screenPos
         */
        setPointerCursor(screenPos) {
            let point = this.getEditorPointFromMouse(screenPos);
            if (point) {
                document.body.style.cursor = "pointer";
            }
            else {
                document.body.style.removeProperty("cursor");
            }
        }
        /**
         * Updates the screen cursor styling to be grabbing.
         */
        setGrabCursor() {
            document.body.style.cursor = "grabbing";
        }
        /**
         * Removes cursor styling.
         */
        removeCursor() {
            document.body.style.removeProperty("cursor");
        }
        smoothenPoints(points) {
            let times = this.smoothen;
            if (points && points.length > 2 && times > 0) {
                let dots = [];
                for (let i = 0; i < points.length; i++) {
                    let point = points[i];
                    let carto = Cesium.Cartographic.fromCartesian(point);
                    if (cartographic_7.Cartographic.Validate(carto)) {
                        dots.push({ x: carto.longitude, y: carto.latitude });
                    }
                    else {
                        return points;
                    }
                }
                let output = drawing_utils_4.DrawingUtils.ChaikinSmooth(dots, true);
                for (let i = 0; i < times - 1; i++) {
                    output = drawing_utils_4.DrawingUtils.ChaikinSmooth(output, true);
                }
                let newPoints = [];
                for (let i = 0; i < output.length; i++) {
                    let dot = output[i];
                    let newPoint = Cesium.Cartesian3.fromRadians(dot.x, dot.y);
                    if (cesium_utils_19.CesiumUtils.ValidatePosition(newPoint)) {
                        newPoints.push(newPoint);
                    }
                    else {
                        return points;
                    }
                }
                return newPoints;
            }
            return points;
        }
    }
    exports.CesiumPolygonGeometryCreator2 = CesiumPolygonGeometryCreator2;
});
define("entry-points/cesium/common/cesium-polygon-geometry-restricted-editor", ["require", "exports", "cesium", "bruce-models/common/line", "bruce-models/common/polygon", "utils/delay-queue", "utils/drawing-utils", "utils/object-utils", "entry-points/cesium/visuals/cesium-bruce-entity", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-entity-utils", "entry-points/cesium/common/cesium-geometry-editor-point", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-polygon-hierarchy-map", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, line_2, polygon_12, delay_queue_7, drawing_utils_5, object_utils_51, cesium_bruce_entity_8, cesium_drawing_utils_12, cesium_entity_utils_10, cesium_geometry_editor_point_6, cesium_mouse_events_7, cesium_polygon_hierarchy_map_6, cesium_utils_20) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPolygonGeometryRestrictedEditor = exports.CesiumPolygonHierarchyEditorMapExtended = void 0;
    Cesium = __importStar(Cesium);
    class CesiumPolygonHierarchyEditorMapExtended extends cesium_polygon_hierarchy_map_6.CesiumPolygonHierarchyMap {
        constructor(hierarchy, boundingMapId, entity, hierarchyId) {
            super(hierarchy);
            this.boundingMapId = boundingMapId;
            this.entity = entity;
            this.hierarchyId = hierarchyId;
        }
    }
    exports.CesiumPolygonHierarchyEditorMapExtended = CesiumPolygonHierarchyEditorMapExtended;
    class CesiumPolygonGeometryRestrictedEditor {
        constructor(viewer, params, boundingGeometry, siblingGeometries, editingEntity, deleteEntityCallback) {
            // If the editor has been disposed.
            this._disposed = false;
            this.boundingMaps = {};
            this.siblingMaps = {};
            // Editor points created for map positions.
            this.editorPoints = [];
            // Clicked offset from the editor point's center point.
            this.mouseOffset = new Cesium.Cartesian2(0, 0);
            this.viewer = viewer;
            this.params = params;
            this.deleteEntityCallback = deleteEntityCallback;
            this.updateGeometriesQueue = new delay_queue_7.DelayQueue(() => {
                this.updateGeometry();
            }, 100);
            this.prepareBoundingGeometry(boundingGeometry);
            if (siblingGeometries) {
                this.AddSiblings(siblingGeometries);
            }
            this.prepareEditingEntity(editingEntity);
        }
        get disposed() {
            return this._disposed;
        }
        get active() {
            return this._active;
        }
        get boundingMapsList() {
            let keys = Object.keys(this.boundingMaps);
            let maps = [];
            for (let i = 0; i < keys.length; i++) {
                maps.push(this.boundingMaps[keys[i]]);
            }
            return maps;
        }
        get siblingMapsList() {
            let keys = Object.keys(this.siblingMaps);
            let maps = [];
            for (let i = 0; i < keys.length; i++) {
                maps.push(this.siblingMaps[keys[i]]);
            }
            return maps;
        }
        prepareEditingEntity(entity) {
            if (entity) {
                let boundingId = this.getBoundingHierarchyIdFromEntity(entity);
                if (boundingId) {
                    let newId = object_utils_51.ObjectUtils.UID();
                    let map = new CesiumPolygonHierarchyEditorMapExtended(null, boundingId, entity, newId);
                    let hierarchy = cesium_utils_20.CesiumUtils.getCesiumValue(this.viewer.CesiumViewer, entity.polygon.hierarchy);
                    if (hierarchy) {
                        map.updateOuterUsingCesiumHierarchy(hierarchy);
                    }
                    let entities = cesium_entity_utils_10.CesiumEntityUtils.getAllEntities(entity).filter(x => cesium_entity_utils_10.CesiumEntityUtils.isInnerEntity(x));
                    map.updateInnerUsingCesiumEntities(this.viewer.CesiumViewer, entities);
                    this.editingMap = map;
                    if (this._active) {
                        this.refreshEditorPointsForMap(map);
                    }
                }
            }
        }
        getBoundingHierarchyIdFromEntity(entity) {
            var _a, _b;
            let hierarchy = cesium_utils_20.CesiumUtils.getCesiumValue(this.viewer.CesiumViewer, (_a = entity === null || entity === void 0 ? void 0 : entity.polygon) === null || _a === void 0 ? void 0 : _a.hierarchy);
            if (hierarchy) {
                let hPosses = hierarchy.positions;
                return (_b = this.getClosestBoundingHierarchy(hPosses[0])) === null || _b === void 0 ? void 0 : _b.hierarchyId;
            }
            return null;
        }
        /**
         * Attempts to construct needed styling params for the editor from given entities.
         * @param viewer
         * @param entities
         */
        static ConstructParamsFromEntities(viewer, entities) {
            let outlineColor = null;
            let outlineWidth = null;
            let fillColor = null;
            for (let i = 0; i < entities.length; i++) {
                let root = entities[i];
                if (!fillColor) {
                    if (root.polygon) {
                        fillColor = cesium_utils_20.CesiumUtils.getCesiumValue(viewer, root.polygon.material);
                    }
                    if (fillColor && fillColor.color instanceof Cesium.Color) {
                        fillColor = fillColor.color;
                    }
                    if (root.polyline) {
                        outlineColor = cesium_utils_20.CesiumUtils.getCesiumValue(viewer, root.polyline.material);
                        outlineWidth = cesium_utils_20.CesiumUtils.getCesiumValue(viewer, root.polyline.width);
                    }
                    if (outlineColor && outlineColor.color instanceof Cesium.Color) {
                        outlineColor = outlineColor.color;
                    }
                }
            }
            if (fillColor || outlineWidth || outlineColor) {
                let params = {
                    outlineColor: outlineColor,
                    outlineWidth: outlineWidth,
                    fillColor: fillColor
                };
                return params;
            }
            return null;
        }
        Start() {
            if (this._disposed) {
                return;
            }
            this._active = true;
            this.startMouseListeners();
            this.refreshEditorPoints();
        }
        Stop() {
            this.stopMouseListeners();
            this.removeEditorPoints(false);
            this.removeCursor();
            this._active = false;
        }
        GetPolygons() {
            return this.editingMap.ConstructBrucePolygon();
        }
        refreshEditorPoints() {
            if (this.editingMap) {
                this.refreshEditorPointsForMap(this.editingMap);
            }
        }
        refreshEditorPointsForMap(map) {
            let positionMap = map.GetOutMap();
            let posIds = positionMap.GetIds();
            for (let j = 0; j < posIds.length; j++) {
                let pos = posIds[j];
                let index = this.editorPoints.findIndex(x => x.posId == pos);
                if (index <= -1) {
                    this.createEditorPoint(pos);
                }
                else {
                    this.editorPoints[index].CreateEntity();
                }
            }
        }
        /**
         * Disposes the editor.
         * This removes editor entities, listeners and stops it from being started again.
         */
        Dispose() {
            this.Stop();
            this.editorPoints = [];
            this.siblingMaps = {};
            this.boundingMaps = {};
            this._disposed = true;
        }
        prepareBoundingGeometry(geometry) {
            if (geometry.MultiGeometry && geometry.MultiGeometry.length > 0) {
                for (let i = 0; i < geometry.MultiGeometry.length; i++) {
                    let geo = geometry.MultiGeometry[i];
                    if (geo.Polygon && geo.Polygon.length > 0) {
                        this.prepareBoundingPolygon(geo.Polygon);
                    }
                }
            }
            else if (geometry.Polygon && geometry.Polygon.length > 0) {
                this.prepareBoundingPolygon(geometry.Polygon);
            }
        }
        prepareBoundingPolygon(polygon) {
            let newId = object_utils_51.ObjectUtils.UID();
            let map = new CesiumPolygonHierarchyEditorMapExtended(null, null, null, newId);
            for (let i = 0; i < polygon.length; i++) {
                let polygonPart = polygon[i];
                let parsedPoints = polygonPart.getParsedCartographicPositions();
                if (parsedPoints && parsedPoints.length > 2) {
                    let partMapId = map.AddMap(polygonPart.Facing);
                    let partMap = map.GetMap(partMapId);
                    for (let j = 0; j < parsedPoints.length; j++) {
                        let pos = parsedPoints[j];
                        let cartes = Cesium.Cartesian3.fromDegrees(pos.longitude, pos.latitude, pos.altitude);
                        partMap.positions.Add(cartes);
                    }
                }
            }
            if (map.GetAllPositionIds().length > 0) {
                this.boundingMaps[newId] = map;
            }
        }
        AddSiblings(siblings) {
            for (let i = 0; i < siblings.length; i++) {
                let sibling = siblings[i];
                this.AddSibling(sibling);
            }
        }
        AddSibling(sibling) {
            let polygons = sibling.GetPolygons();
            for (let i = 0; i < polygons.length; i++) {
                let polygon = polygons[i];
                let boundingId = this.getBoundingHierarchyIdFromPolygon(polygon);
                if (boundingId) {
                    let newId = object_utils_51.ObjectUtils.UID();
                    let map = new CesiumPolygonHierarchyEditorMapExtended(null, boundingId, null, newId);
                    map.updateUsingPolygon(polygon);
                    this.siblingMaps[newId] = map;
                }
            }
        }
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_7.CesiumMouseEvents(this.viewer.CesiumViewer);
                this.mouseHandler.LeftDownEvent.Subscribe((data) => {
                    this.doMouseLeftDown(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.LeftUpEvent.Subscribe((data) => {
                    this.doMouseLeftUp();
                });
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.RightClickEvent.Subscribe((data) => {
                    this.doMouseRightClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doMouseClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.EnableEventHandling();
            }
        }
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.dispose();
                this.mouseHandler = null;
            }
        }
        doMouseClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = cesium_drawing_utils_12.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer.CesiumViewer, screenPos);
                    if (cesium_utils_20.CesiumUtils.ValidatePosition(pos3d)) {
                        this.addPosition(pos3d);
                    }
                }
            }
        }
        doMouseMove(screenPos) {
            let updatedPos = true;
            if (cesium_utils_20.CesiumUtils.Validate2DPosition(screenPos)) {
                screenPos.x += this.mouseOffset.x;
                screenPos.y += this.mouseOffset.y;
                let pos3d = cesium_drawing_utils_12.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer.CesiumViewer, screenPos);
                if (cesium_utils_20.CesiumUtils.ValidatePosition(pos3d)) {
                    this.lastCursorPos = pos3d;
                    if (this.activePoint) {
                        updatedPos = false;
                        let newPos = this.getValidMove(this.activePoint.posId, pos3d);
                        if (newPos) {
                            this.activePoint.updatePosition(newPos);
                        }
                        this.updateGeometriesQueue.Call(false);
                    }
                }
            }
            if (updatedPos) {
                this.setPointerCursor(screenPos);
            }
        }
        doMouseLeftUp() {
            if (this.activePoint) {
                this.activePoint = null;
                this.viewer.cameraHandler.isFrozen = false;
            }
        }
        doMouseLeftDown(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.activePoint = point;
                    this.updateOffset(screenPos);
                    this.setGrabCursor();
                    this.viewer.cameraHandler.isFrozen = true;
                }
            }
        }
        doMouseRightClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    let map = this.editingMap;
                    if (map) {
                        let outMap = map.GetOutMap();
                        if (outMap) {
                            let pointsLeft = outMap.GetIds().length;
                            if (pointsLeft <= 1) {
                                this.removeHierarchy();
                            }
                            else if (pointsLeft < 4) {
                                // TODO: Remove map holes.
                            }
                            if (pointsLeft > 1) {
                                outMap.Remove(point.posId);
                                let index = this.editorPoints.findIndex(x => x.posId == point.posId);
                                this.editorPoints.splice(index, 1);
                                point.DestroyEntity();
                            }
                            this.updateGeometriesQueue.Call(true);
                        }
                    }
                }
            }
        }
        getIsWithinBoundingGeometry(pos, outMapId) {
            let outMap = this.boundingMaps[outMapId];
            let positionsMap = outMap === null || outMap === void 0 ? void 0 : outMap.GetOutMap();
            if (!positionsMap) {
                return false;
            }
            let cartos = cesium_utils_20.CesiumUtils.toRadiansCartographicArray(positionsMap.getPositions());
            let carto = cesium_utils_20.CesiumUtils.toRadiansCartographic(pos);
            return cesium_utils_20.CesiumUtils.getIsPointInPolygon(cartos, carto);
        }
        getIsOutsideMaps(pos) {
            var _a;
            let excludingHierarchyId = this.editingMap.hierarchyId;
            let maps = this.siblingMapsList;
            for (let i = 0; i < maps.length; i++) {
                let map = maps[i];
                let mapId = map.hierarchyId;
                if (mapId != excludingHierarchyId) {
                    let posses = (_a = map.GetOutMap()) === null || _a === void 0 ? void 0 : _a.getPositions();
                    if (posses) {
                        let cartos = cesium_utils_20.CesiumUtils.toRadiansCartographicArray(posses);
                        let carto = cesium_utils_20.CesiumUtils.toRadiansCartographic(pos);
                        if (cesium_utils_20.CesiumUtils.getIsPointInPolygon(cartos, carto)) {
                            return false;
                        }
                    }
                }
            }
            return true;
        }
        getClosestBoundingHierarchy(pos) {
            let shortestDistance;
            let hierarchy;
            let maps = this.boundingMapsList;
            for (let i = 0; i < maps.length; i++) {
                let map = maps[i];
                let outMap = map.GetOutMap();
                let posses = outMap.getPositions();
                for (let j = 0; j < posses.length; j++) {
                    let distance = Cesium.Cartesian3.distance(posses[j], pos);
                    if (!hierarchy || distance < shortestDistance) {
                        hierarchy = map;
                        shortestDistance = distance;
                    }
                }
            }
            return hierarchy;
        }
        getBoundingHierarchyIdFromPolygon(polygon) {
            var _a, _b;
            let cartos = (_a = polygon.find(x => x.Facing == polygon_12.PolygonFacing.out)) === null || _a === void 0 ? void 0 : _a.getParsedCartographicPositions();
            if (cartos) {
                let posses = cesium_utils_20.CesiumUtils.ICartographicArrayToCartesian3(cartos);
                if (posses.length > 0) {
                    return (_b = this.getClosestBoundingHierarchy(posses[0])) === null || _b === void 0 ? void 0 : _b.hierarchyId;
                }
            }
            return null;
        }
        getClosestHierarchy(pos) {
            let shortestDistance;
            let hierarchy;
            let maps = this.siblingMapsList;
            for (let i = 0; i < maps.length; i++) {
                let map = maps[i];
                let outMap = map.GetOutMap();
                let posses = outMap.getPositions();
                for (let j = 0; j < posses.length; j++) {
                    let nextPoint = j >= posses.length - 1 ? posses[0] : posses[j + 1];
                    if (nextPoint) {
                        let point = this.getPointFromPos(pos);
                        let line = {
                            end: this.getPointFromPos(nextPoint),
                            start: this.getPointFromPos(posses[j])
                        };
                        let closestPoint = drawing_utils_5.DrawingUtils.GetClosestPointToLine(line, point);
                        if (closestPoint) {
                            let closestPos = Cesium.Cartesian3.fromRadians(closestPoint.x, closestPoint.y);
                            let distance = Cesium.Cartesian3.distance(closestPos, pos);
                            if (!hierarchy || distance < shortestDistance) {
                                hierarchy = map;
                                shortestDistance = distance;
                            }
                        }
                    }
                }
            }
            return hierarchy;
        }
        /**
         * Returns distance between point and line.
         * This value is not real, it is only used for internal use in this editor.
         * This value does not represent a real amount in any known value type.
         * @param refPoint
         * @param pos1
         * @param pos2
         * @returns
         */
        avgDistanceFromPointPair(refPoint, pos1, pos2) {
            let carto1 = Cesium.Cartographic.fromCartesian(refPoint);
            let carto2 = Cesium.Cartographic.fromCartesian(pos1);
            let carto3 = Cesium.Cartographic.fromCartesian(pos2);
            let x1 = carto1.longitude;
            let y1 = carto1.latitude;
            let x2 = carto2.longitude;
            let y2 = carto2.latitude;
            let x3 = carto3.longitude;
            let y3 = carto3.latitude;
            let A = x1 - x2;
            let B = y1 - y2;
            let C = x3 - x2;
            let D = y3 - y2;
            let dot = A * C + B * D;
            let len_sq = C * C + D * D;
            let param = dot / len_sq;
            let xx;
            let yy;
            if (param < 0 || x2 == x3 && y2 == y3) {
                xx = x2;
                yy = y2;
            }
            else if (param > 1) {
                xx = x3;
                yy = y3;
            }
            else {
                xx = x2 + param * C;
                yy = y2 + param * D;
            }
            let dx = x1 - xx;
            let dy = y1 - yy;
            return Math.sqrt(dx * dx + dy * dy);
        }
        isMoveValid(posId, newValue) {
            // Construct array of positions updated with new value.
            let map = this.editingMap;
            let posMap = map.GetOutMap();
            let posses = posMap.getPositions();
            let index = posMap.GetIndex(posId);
            posses[index] = newValue;
            // Check if this new set of positions cause intersections.
            for (let j = 0; j < posses.length; j++) {
                let pos = posses[j];
                if (!this.getIsWithinBoundingGeometry(pos, map.boundingMapId) || !this.getIsOutsideMaps(pos)) {
                    return false;
                }
            }
            return true;
        }
        getValidMove(posId, newValue) {
            let isValid = this.isMoveValid(posId, newValue);
            if (isValid) {
                return newValue;
            }
            // Construct array of positions updated with new value.
            let map = this.editingMap;
            let posMap = map.GetOutMap();
            let posses = posMap.getPositions();
            let index = posMap.GetIndex(posId);
            posses[index] = newValue;
            let prevPoint = index == 0 ? posses[posses.length - 1] : posses[index - 1];
            let nextPoint = index >= posses.length - 1 ? posses[0] : posses[index + 1];
            let maps;
            if (!this.getIsWithinBoundingGeometry(newValue, map.boundingMapId)) {
                maps = this.boundingMapsList;
            }
            if (!this.getIsOutsideMaps(newValue)) {
                maps = this.siblingMapsList;
            }
            if (maps) {
                let intersectionPos = this.findSingleIntersection([prevPoint, newValue, nextPoint], maps);
                if (cesium_utils_20.CesiumUtils.ValidatePosition(intersectionPos)) {
                    return intersectionPos;
                }
                let closestPos = this.findClosestPoint(newValue, maps);
                if (cesium_utils_20.CesiumUtils.ValidatePosition(closestPos)) {
                    return closestPos;
                }
            }
            return newValue;
        }
        /**
         * Finds one intersecting line from a given triangle and returns it.
         * If multiple intersections are found from two different lines in the triangle, nothing is returned.
         * If multiple intersections are found from one line in the triangle, the closest intersection is returned.
         * @param mapId
         * @param posses
         * @returns
         */
        findSingleIntersection(posses, maps) {
            var _a;
            if (!cesium_utils_20.CesiumUtils.ValidatePositions(posses)) {
                return null;
            }
            let intPos1;
            let intPos2;
            for (let i = 0; i < 2; i++) {
                let pos1;
                let pos2;
                if (i == 0) {
                    pos1 = posses[0];
                }
                else if (i == 1) {
                    pos1 = posses[2];
                }
                pos2 = posses[1];
                let carto1 = Cesium.Cartographic.fromCartesian(pos1);
                let carto2 = Cesium.Cartographic.fromCartesian(pos2);
                let line1 = {
                    start: {
                        x: carto1.longitude,
                        y: carto1.latitude
                    },
                    end: {
                        x: carto2.longitude,
                        y: carto2.latitude
                    }
                };
                let lineInt;
                let lineIntDistance;
                for (let j = 0; j < maps.length; j++) {
                    let testMap = maps[j];
                    let testPosses = (_a = testMap.GetOutMap()) === null || _a === void 0 ? void 0 : _a.getPositions(true);
                    for (let k = 0; k < testPosses.length; k++) {
                        let testPos1 = testPosses[k];
                        let testPos2 = testPosses[k + 1];
                        if (testPos2 == null) {
                            break;
                        }
                        let carto1 = Cesium.Cartographic.fromCartesian(testPos1);
                        let carto2 = Cesium.Cartographic.fromCartesian(testPos2);
                        let line2 = {
                            start: {
                                x: carto1.longitude,
                                y: carto1.latitude
                            },
                            end: {
                                x: carto2.longitude,
                                y: carto2.latitude
                            }
                        };
                        if (drawing_utils_5.DrawingUtils.GetIfLinesIntersect(line1, line2)) {
                            let eq1 = drawing_utils_5.DrawingUtils.GetEquationFromLine(line1);
                            let eq2 = drawing_utils_5.DrawingUtils.GetEquationFromLine(line2);
                            let intersection = drawing_utils_5.DrawingUtils.GetLineIntersection(eq1, eq2);
                            if (cesium_utils_20.CesiumUtils.Validate2DPosition(intersection)) {
                                let tmpPos = Cesium.Cartesian3.fromRadians(intersection.x, intersection.y, carto1.height);
                                if (!lineInt) {
                                    lineInt = tmpPos;
                                    lineIntDistance = Cesium.Cartesian3.distance(pos1, tmpPos);
                                }
                                else {
                                    let distance = Cesium.Cartesian3.distance(pos1, tmpPos);
                                    if (distance < lineIntDistance) {
                                        lineIntDistance = distance;
                                        lineInt = tmpPos;
                                    }
                                }
                            }
                        }
                    }
                }
                if (lineInt) {
                    if (i == 0) {
                        intPos1 = lineInt;
                    }
                    else {
                        intPos2 = lineInt;
                    }
                }
            }
            if (cesium_utils_20.CesiumUtils.ValidatePositions([intPos1, intPos2])) {
                return null;
            }
            let pos;
            if (intPos1) {
                pos = intPos1;
            }
            else {
                pos = intPos2;
            }
            if (!pos) {
                return null;
            }
            let bearing = drawing_utils_5.DrawingUtils.GetLineBearingInDegrees(line_2.Line2D.LineFromPoints(this.getPointFromPos(pos), this.getPointFromPos(posses[1])));
            let carto = cesium_utils_20.CesiumUtils.toCartographic(pos);
            let newPos = cesium_drawing_utils_12.CesiumDrawingUtils.OffsetPoint(carto, -0.3, bearing);
            let cartesian = Cesium.Cartesian3.fromDegrees(newPos.longitude, newPos.latitude, newPos.height);
            return cartesian;
        }
        findClosestPoint(pos, maps) {
            var _a;
            let closestPos;
            let distance;
            let pos2d = this.getPointFromPos(pos);
            for (let j = 0; j < maps.length; j++) {
                let testMap = maps[j];
                let testPosses = (_a = testMap.GetOutMap()) === null || _a === void 0 ? void 0 : _a.getPositions(true);
                for (let k = 0; k < testPosses.length; k++) {
                    let testPos1 = testPosses[k];
                    let testPos2 = testPosses[k + 1];
                    if (testPos2 == null) {
                        break;
                    }
                    let carto1 = Cesium.Cartographic.fromCartesian(testPos1);
                    let carto2 = Cesium.Cartographic.fromCartesian(testPos2);
                    let line = {
                        start: {
                            x: carto1.longitude,
                            y: carto1.latitude
                        },
                        end: {
                            x: carto2.longitude,
                            y: carto2.latitude
                        }
                    };
                    let tmpPoint = drawing_utils_5.DrawingUtils.GetClosestPointToLine(line, pos2d);
                    if (cesium_utils_20.CesiumUtils.Validate2DPosition(tmpPoint)) {
                        let tmpPos = Cesium.Cartesian3.fromRadians(tmpPoint.x, tmpPoint.y, carto1.height);
                        let tmpDistance = Cesium.Cartesian3.distance(pos, tmpPos);
                        if (!closestPos) {
                            closestPos = tmpPos;
                            distance = tmpDistance;
                        }
                        else if (tmpDistance < distance) {
                            closestPos = tmpPos;
                            distance = tmpDistance;
                        }
                    }
                }
            }
            return closestPos;
        }
        /**
         * Returns x,y position from 3d position.
         * @param pos
         */
        getPointFromPos(pos) {
            let carto = Cesium.Cartographic.fromCartesian(pos);
            return { x: carto.longitude, y: carto.latitude };
        }
        updateGeometry() {
            let map = this.editingMap;
            if (map) {
                let root = map.entity;
                if (root) {
                    this.updatePolygonVisual(root, map);
                    this.viewer.CesiumViewer.scene.requestRender();
                }
            }
        }
        updatePolygonVisual(root, map) {
            let polygonHierarchy = map.ConstructCesiumHierarchy();
            // First cover outer loop.
            root.polygon.hierarchy = polygonHierarchy;
            if (root.polyline) {
                root.polyline.positions = polygonHierarchy.positions;
            }
            else if (this.params.outlineColor) {
                let color = this.params.outlineColor;
                if (typeof color == "string") {
                    color = Cesium.Color.fromCssColorString(color);
                }
                root.polyline = new Cesium.PolylineGraphics({
                    positions: polygonHierarchy.positions,
                    clampToGround: true,
                    material: color,
                    width: this.params.outlineWidth,
                    classificationType: Cesium.ClassificationType.TERRAIN,
                    arcType: Cesium.ArcType.GEODESIC
                });
            }
            // Now process holes.
            let entities = cesium_entity_utils_10.CesiumEntityUtils.getAllEntities(root);
            let holeIndex = 0;
            for (let i = 0; i < entities.length; i++) {
                let entity = entities[i];
                if (cesium_entity_utils_10.CesiumEntityUtils.isInnerEntity(entity)) {
                    if (entity.polyline) {
                        let hole = polygonHierarchy.holes[holeIndex];
                        if (hole) {
                            entity.polyline.positions = hole.positions;
                            holeIndex += 1;
                        }
                        else {
                            cesium_entity_utils_10.CesiumEntityUtils.removeInnerEntity(root, entity);
                            this.viewer.CesiumViewer.entities.remove(entity);
                        }
                    }
                }
            }
            // Create missing holes.
            if (this.params && this.params.outlineWidth != null && this.params.outlineWidth > 0) {
                entities = cesium_entity_utils_10.CesiumEntityUtils.getAllEntities(root);
                let holeIds = map.GetInnerMapIds();
                for (let i = 0; i < holeIds.length; i++) {
                    let holeId = holeIds[i];
                    let index = entities.findIndex(x => x._bruceHierarchyMapRefId == holeId);
                    if (index <= -1) {
                        let holeMap = map.GetMap(holeId);
                        let posses = holeMap.positions.getPositions();
                        let color = this.params.outlineColor;
                        if (typeof color == "string") {
                            color = Cesium.Color.fromCssColorString(color);
                        }
                        let holeEntity = new Cesium.Entity({
                            polyline: {
                                positions: posses,
                                clampToGround: true,
                                material: color,
                                width: this.params.outlineWidth,
                                classificationType: Cesium.ClassificationType.TERRAIN,
                                arcType: Cesium.ArcType.GEODESIC
                            },
                            parent: root
                        });
                        cesium_entity_utils_10.CesiumEntityUtils.MarkarkAsInner(holeEntity);
                        holeEntity._bruceHierarchyMapRefId = holeId;
                        this.viewer.CesiumViewer.entities.add(holeEntity);
                        this.viewer.CesiumViewer.scene.requestRender();
                    }
                }
            }
        }
        /**
         * Returns editing point from this editor from given screen position.
         * @param screenPos
         * @returns
         */
        getEditorPointFromMouse(screenPos) {
            if (cesium_utils_20.CesiumUtils.Validate2DPosition(screenPos)) {
                let viewer = this.viewer.CesiumViewer;
                let pickedObjects = viewer.scene.drillPick(screenPos, 5);
                for (let i = 0; i < pickedObjects.length; i++) {
                    let pickedObject = pickedObjects[i];
                    if (pickedObject.id instanceof Cesium.Entity) {
                        pickedObject = pickedObject.id;
                    }
                    if (pickedObject && pickedObject._cesiumGeometryEditorPointId) {
                        let point = this.editorPoints.find(x => x.posId == pickedObject._cesiumGeometryEditorPointId);
                        if (point) {
                            return point;
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Creates a new editor point at a given position and calls to update geometry.
         * @param hierarchyId
         * @param position
         * @param insertIndex
         */
        createAndRegisterEditorPoint(position, insertIndex = -1) {
            var _a;
            let pointId;
            let map = (_a = this.editingMap) === null || _a === void 0 ? void 0 : _a.GetOutMap();
            if (map) {
                if (insertIndex != null && insertIndex > -1) {
                    pointId = map.Insert(position, insertIndex);
                }
                else {
                    pointId = map.Add(position);
                }
                this.createEditorPoint(pointId);
                this.updateGeometriesQueue.Call(true);
            }
            return pointId;
        }
        /**
         * Creates an editor point for a given point id at a given branch id.
         * @param posId
         * @param hierarchyId
         */
        createEditorPoint(posId) {
            let point = new cesium_geometry_editor_point_6.CesiumGeometryEditorPoint({
                posId: posId,
                getPosition: () => this.getEditorPointPosition(posId),
                showCallback: () => this.isPointVisible(posId),
                updatePosition: (position) => {
                    this.updateEditorPointPosition(posId, position);
                },
                viewer: this.viewer.CesiumViewer
            });
            point.CreateEntity();
            this.editorPoints.push(point);
        }
        /**
         * Returns editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @returns
         */
        getEditorPointPosition(posId) {
            var _a;
            let map = this.editingMap;
            return (_a = map === null || map === void 0 ? void 0 : map.GetOutMap()) === null || _a === void 0 ? void 0 : _a.Get(posId);
        }
        /**
         * Updates editor point's 3D position.
         * @param posId
         * @param hierarchyId
         * @param position
         */
        updateEditorPointPosition(posId, position) {
            var _a;
            let hierarchyMap = (_a = this.editingMap) === null || _a === void 0 ? void 0 : _a.GetOutMap();
            hierarchyMap === null || hierarchyMap === void 0 ? void 0 : hierarchyMap.Update(posId, position);
        }
        /**
         * Removes editing point visuals.
         * @param emptyArray If array of editor points should be cleared.
         */
        removeEditorPoints(emptyArray) {
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                point.DestroyEntity();
            }
            if (emptyArray) {
                this.editorPoints = [];
            }
        }
        /**
         * Returns if a given point should be visible.
         * @param posId
         * @param hierarchyId
         */
        isPointVisible(posId) {
            return true;
            /*
            if (posId == this.activePoint?.posId) {
                return true;
            }
    
            if (CesiumUtils.ValidatePosition(this.lastCursorPos)) {
                let map = this.editingMap;
                let posMap = map?.GetOutMap();
                let pos = posMap?.Get(posId);
                if (pos) {
                    let distance = Cesium.Cartesian3.distance(pos, this.lastCursorPos);
                    return distance <= 50;
                }
                else {
                    return false;
                }
            }
            return false;
            */
        }
        /**
         * Updates the clicked offset from the entity's position.
         * @param screenPos
         */
        updateOffset(screenPos) {
            if (this.activePoint) {
                let position = this.activePoint.lastPosition;
                let grounded = Cesium.Cartographic.fromCartesian(position);
                position = Cesium.Cartesian3.fromRadians(grounded.longitude, grounded.latitude, 0);
                if (cesium_utils_20.CesiumUtils.ValidatePosition(position)) {
                    let entityScreenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.CesiumViewer.scene, position);
                    if (cesium_utils_20.CesiumUtils.Validate2DPosition(entityScreenPos)) {
                        this.mouseOffset.x = entityScreenPos.x - screenPos.x;
                        this.mouseOffset.y = entityScreenPos.y - screenPos.y;
                    }
                }
            }
        }
        /**
         * Adds point to the map.
         * Point will be added to the closest point branch.
         * @param position
         */
        addPosition(position) {
            var _a;
            let hierarchyId = (_a = this.editingMap) === null || _a === void 0 ? void 0 : _a.hierarchyId;
            if (hierarchyId) {
                let insertIndex = this.getInsertIndex(position);
                let posId = this.createAndRegisterEditorPoint(position, insertIndex == -1 ? null : insertIndex);
                let newPos = this.getValidMove(posId, position);
                this.updateEditorPointPosition(posId, newPos);
                this.updateGeometriesQueue.Call();
            }
        }
        /**
         * Returns closest insert index for a position in a given hierarchy.
         * @param position
         * @returns
         */
        getInsertIndex(position) {
            var _a;
            let distance;
            let index = -1;
            let map = this.editingMap;
            if (map) {
                let positions = (_a = map.GetOutMap()) === null || _a === void 0 ? void 0 : _a.getPositions();
                if (positions) {
                    for (let j = 0; j < positions.length; j++) {
                        let pos1 = positions[j];
                        let pos2;
                        let pos2Index = -1;
                        if (j >= positions.length - 1) {
                            pos2 = positions[0];
                            pos2Index = 0;
                        }
                        else {
                            pos2 = positions[j + 1];
                            pos2Index = j + 1;
                        }
                        if (cesium_utils_20.CesiumUtils.ValidatePositions([pos1, pos2])) {
                            let length = this.avgDistanceFromPointPair(position, pos1, pos2);
                            if (index == -1 || length < distance) {
                                let insertIndex = pos2Index == 0 ? 0 : j > pos2Index ? j : pos2Index;
                                index = insertIndex;
                                distance = length;
                            }
                        }
                    }
                }
            }
            return index;
        }
        removeHierarchy() {
            let map = this.editingMap;
            let bruceEntity = cesium_bruce_entity_8.CesiumBruceEntity.FromCesiumEntity(map.entity);
            if (bruceEntity) {
                let res = confirm("Are you sure you want to delete this entity?");
                if (!res) {
                    return;
                }
                this.deleteEntityCallback(bruceEntity);
            }
            map.entity.show = false;
            this.removeEditorPoints(true);
            this.editingMap.entity = null;
            delete this.editingMap;
        }
        /**
         * Updates cursor styling depending on if editing point is found underneath.
         * @param screenPos
         */
        setPointerCursor(screenPos) {
            let point = this.getEditorPointFromMouse(screenPos);
            if (point) {
                document.body.style.cursor = "pointer";
            }
            else {
                document.body.style.removeProperty("cursor");
            }
        }
        /**
         * Updates the screen cursor styling to be grabbing.
         */
        setGrabCursor() {
            document.body.style.cursor = "grabbing";
        }
        /**
         * Removes cursor styling.
         */
        removeCursor() {
            document.body.style.removeProperty("cursor");
        }
    }
    exports.CesiumPolygonGeometryRestrictedEditor = CesiumPolygonGeometryRestrictedEditor;
});
define("entry-points/cesium/common/cesium-snapped-rectangle-creator", ["require", "exports", "cesium", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, cesium_drawing_utils_13, cesium_mouse_events_8, cesium_utils_21) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumSnappedRectangleCreator = void 0;
    Cesium = __importStar(Cesium);
    class CesiumSnappedRectangleCreator {
        constructor(viewer, refPoint, cellSize) {
            // The last updated mouse position.
            this.mousePosition = new Cesium.Cartesian3(0, 0, 0);
            // Z index to apply to polyline on its creation.
            this.zIndex = 10;
            if (!cellSize) {
                cellSize = 100;
            }
            this.cellSize = cellSize;
            this.viewer = viewer;
            this.refPoint = refPoint;
        }
        /**
         * Returns cell reference index for a given amount of meters in either lat or lon direction.
         * @param num
         * @returns
         */
        getCellDelta(num) {
            let index = 0;
            let div = num / this.cellSize;
            if (div > 1) {
                index = Math.floor(div);
            }
            let dotIndex = (div + "").indexOf(".");
            if (dotIndex > -1) {
                let tenths = parseFloat((div + "")[dotIndex + 1]);
                if (tenths && tenths > 5) {
                    index += 1;
                }
            }
            return index;
        }
        /**
         * Returns a position snapped to the cell grid for given cell indexes.
         * @param lonIndex
         * @param latIndex
         * @returns
         */
        getCellPositionFromIndexes(lonIndex, latIndex) {
            let lonIncrement = this.cellSize * lonIndex;
            let latIncrement = this.cellSize * latIndex;
            let cesiumCarto = Cesium.Cartographic.fromDegrees(this.refPoint.longitude, this.refPoint.latitude);
            cesiumCarto = cesium_utils_21.CesiumUtils.toDegrees(cesiumCarto);
            let pos = cesium_drawing_utils_13.CesiumDrawingUtils.OffsetPoint(cesiumCarto, lonIncrement, 90);
            pos = cesium_drawing_utils_13.CesiumDrawingUtils.OffsetPoint(pos, latIncrement, 0);
            return Cesium.Cartesian3.fromDegrees(pos.longitude, pos.latitude, pos.latitude);
        }
        /**
         * Returns position snapped to the grid.
         * @param position
         * @returns
         */
        getPositionOnCell(position) {
            let pos = position;
            let carto = Cesium.Cartographic.fromCartesian(pos);
            if (!carto) {
                return null;
            }
            carto = cesium_utils_21.CesiumUtils.toDegrees(carto);
            let refPos = Cesium.Cartographic.fromDegrees(this.refPoint.longitude, this.refPoint.latitude);
            refPos = cesium_utils_21.CesiumUtils.toDegrees(refPos);
            let p1 = Cesium.Cartographic.fromDegrees(this.refPoint.longitude, carto.latitude);
            p1 = cesium_utils_21.CesiumUtils.toDegrees(p1);
            let p2 = Cesium.Cartographic.fromDegrees(carto.longitude, this.refPoint.latitude);
            p2 = cesium_utils_21.CesiumUtils.toDegrees(p2);
            let p1Distance = cesium_drawing_utils_13.CesiumDrawingUtils.DistanceAcrossGlobe(p1, refPos);
            let p2Distance = cesium_drawing_utils_13.CesiumDrawingUtils.DistanceAcrossGlobe(p2, refPos);
            let p1Delta = this.getCellDelta(p1Distance);
            let p2Delta = this.getCellDelta(p2Distance);
            if (carto.longitude < this.refPoint.longitude) {
                p2Delta *= -1;
            }
            if (carto.latitude < this.refPoint.latitude) {
                p1Delta *= -1;
            }
            return this.getCellPositionFromIndexes(p2Delta, p1Delta);
        }
        /**
         * Starts cesium mouse event listeners.
         */
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_8.CesiumMouseEvents(this.viewer);
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.EnableEventHandling();
            }
        }
        /**
         * Stops cesium mouse event listeners.
         */
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.dispose();
                this.mouseHandler = null;
            }
        }
        /**
         * Handles mouse movement in cesium view.
         * @param screenPos
         */
        doMouseMove(screenPos) {
            if (cesium_utils_21.CesiumUtils.Validate2DPosition(screenPos)) {
                let pos3d = cesium_drawing_utils_13.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                if (cesium_utils_21.CesiumUtils.ValidatePosition(pos3d)) {
                    this.mousePosition = pos3d;
                }
            }
        }
        /**
         * Handles mouse click in cesium view.
         * @param screenPos
         */
        doClick(screenPos) {
            if (cesium_utils_21.CesiumUtils.Validate2DPosition(screenPos)) {
                let pos3d = cesium_drawing_utils_13.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                if (cesium_utils_21.CesiumUtils.ValidatePosition(pos3d)) {
                    if (this.startPos && this.stopPos) {
                        this.stopPos = null;
                        this.startPos = this.getPositionOnCell(pos3d);
                    }
                    else if (this.startPos) {
                        this.stopPos = this.getPositionOnCell(pos3d);
                    }
                    else {
                        this.startPos = this.getPositionOnCell(pos3d);
                    }
                    if (this.startPos && this.stopPos && this.OnDrawFinish) {
                        this.OnDrawFinish(this.getPositions(false));
                    }
                }
            }
        }
        /**
         * Creates 3d entity representing current mouse position snapped to grid.
         */
        createMouseEntity() {
            if (!this.mouseEntity) {
                let mouseEntity = new Cesium.Entity({
                    point: {
                        pixelSize: 8,
                        color: Cesium.Color.fromCssColorString("rgb(77, 136, 255, 0.7)"),
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                    },
                    position: new Cesium.CallbackProperty(() => this.getPositionOnCell(this.mousePosition), false)
                });
                this.viewer.entities.add(mouseEntity);
                this.mouseEntity = mouseEntity;
            }
        }
        /**
         * Removes the 3d entity representing mouse.
         */
        removeMouseEntity() {
            if (this.mouseEntity) {
                if (this.viewer.entities.contains(this.mouseEntity)) {
                    this.viewer.entities.remove(this.mouseEntity);
                }
                this.mouseEntity = null;
            }
        }
        /**
         * Creates cesium 3d entity that represents the current drawn rectangle.
         */
        createRectangleEntity() {
            if (!this.rectangleEntity) {
                let rectangleEntity = new Cesium.Entity({
                    polyline: {
                        positions: new Cesium.CallbackProperty(() => {
                            let posses = this.getPositions(true);
                            if (posses) {
                                posses.push(posses[0]);
                            }
                            return posses;
                        }, false),
                        material: Cesium.Color.fromCssColorString("rgb(77, 136, 255, 0.7)"),
                        clampToGround: true,
                        classificationType: Cesium.ClassificationType.TERRAIN,
                        arcType: Cesium.ArcType.GEODESIC,
                        width: 5,
                        zIndex: this.zIndex
                    }
                });
                this.viewer.entities.add(rectangleEntity);
                this.rectangleEntity = rectangleEntity;
            }
        }
        /**
         * Removes the cesium 3d entity for current drawn rectangle.
         */
        removeRectangleEntity() {
            if (this.rectangleEntity) {
                if (this.viewer.entities.contains(this.rectangleEntity)) {
                    this.viewer.entities.remove(this.rectangleEntity);
                }
                this.rectangleEntity = null;
            }
        }
        Start() {
            this.startMouseListeners();
            this.createMouseEntity();
            this.createRectangleEntity();
        }
        Stop() {
            this.stopMouseListeners();
            this.removeMouseEntity();
            this.removeRectangleEntity();
        }
        /**
         * Returns positions defining the 4 corners of the currently drawn rectangle.
         * Returns null if there is no defined rectangle.
         */
        getPositions(allowMouse) {
            let p1 = this.startPos;
            let p2 = this.stopPos;
            if (!p2 && allowMouse) {
                p2 = this.getPositionOnCell(this.mousePosition);
            }
            if (!cesium_utils_21.CesiumUtils.ValidatePositions([p1, p2])) {
                return null;
            }
            let p1Carto = Cesium.Cartographic.fromCartesian(p1);
            let p2Carto = Cesium.Cartographic.fromCartesian(p2);
            let p3Carto = Cesium.Cartographic.fromRadians(p1Carto.longitude, p2Carto.latitude);
            let p4Carto = Cesium.Cartographic.fromRadians(p2Carto.longitude, p1Carto.latitude);
            let posses = Cesium.Cartesian3.fromRadiansArray([
                p1Carto.longitude, p1Carto.latitude,
                p3Carto.longitude, p3Carto.latitude,
                p2Carto.longitude, p2Carto.latitude,
                p4Carto.longitude, p4Carto.latitude
            ]);
            return posses;
        }
    }
    exports.CesiumSnappedRectangleCreator = CesiumSnappedRectangleCreator;
});
define("utils/keyboard-events", ["require", "exports", "utils/bruce-event"], function (require, exports, bruce_event_11) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.KeyboardEvents = exports.EKeyEventKey = void 0;
    var EKeyEventKey;
    (function (EKeyEventKey) {
        EKeyEventKey["Control"] = "Control";
        EKeyEventKey["Alt"] = "Alt";
        EKeyEventKey["Backspace"] = "Backspace";
        EKeyEventKey["ArrowUp"] = "ArrowUp";
        EKeyEventKey["ArrowDown"] = "ArrowDown";
        EKeyEventKey["ArrowLeft"] = "ArrowLeft";
        EKeyEventKey["ArrowRight"] = "ArrowRight";
        EKeyEventKey["Escape"] = "Escape";
        EKeyEventKey["CapsLock"] = "CapsLock";
        EKeyEventKey["Shift"] = "Shift";
        EKeyEventKey["Z"] = "z";
        EKeyEventKey["A"] = "a";
        EKeyEventKey["W"] = "w";
        EKeyEventKey["S"] = "s";
        EKeyEventKey["D"] = "d";
        EKeyEventKey["Q"] = "q";
        EKeyEventKey["E"] = "e";
        EKeyEventKey["Space"] = " ";
        EKeyEventKey["Enter"] = "Enter";
    })(EKeyEventKey = exports.EKeyEventKey || (exports.EKeyEventKey = {}));
    class KeyboardEvents {
        constructor() {
            // Event to subscribe to to receieve notifications about keyboard key-down events.
            this.KeyDownEvent = new bruce_event_11.BruceEvent();
            // Event to subscribe to to receieve notifications about keyboard key-up events.
            this.KeyUpEvent = new bruce_event_11.BruceEvent();
        }
        /**
         * Starts listening for keyboard events.
         */
        EnableEventListening() {
            if (!this.keyDownEventHandler) {
                window.addEventListener("keydown", this.keyDownEventHandler = (e) => {
                    this.KeyDownEvent.Trigger(e);
                });
            }
            if (!this.keyUpEventHandler) {
                window.addEventListener("keyup", this.keyUpEventHandler = (e) => {
                    this.KeyUpEvent.Trigger(e);
                });
            }
        }
        /**
         * Stops listening for keyboard events.
         */
        DisableEventListening() {
            if (this.keyDownEventHandler) {
                window.removeEventListener("keydown", this.keyDownEventHandler);
                this.keyDownEventHandler = null;
            }
            if (this.keyUpEventHandler) {
                window.removeEventListener("keyup", this.keyUpEventHandler);
                this.keyUpEventHandler = null;
            }
        }
    }
    exports.KeyboardEvents = KeyboardEvents;
});
define("entry-points/cesium/common/cesium-player-mode", ["require", "exports", "cesium", "bruce-models/common/dictionary", "utils/keyboard-events", "entry-points/cesium/common/cesium-drawing-utils"], function (require, exports, Cesium, dictionary_1, keyboard_events_1, cesium_drawing_utils_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPlayerMode = exports.ECesiumPlayerModeMovementType = exports.ECesiumPlayerModeAction = void 0;
    Cesium = __importStar(Cesium);
    var ECesiumPlayerModeAction;
    (function (ECesiumPlayerModeAction) {
        ECesiumPlayerModeAction["Forward"] = "f";
        ECesiumPlayerModeAction["Backward"] = "b";
        ECesiumPlayerModeAction["Left"] = "l";
        ECesiumPlayerModeAction["Right"] = "r";
        ECesiumPlayerModeAction["Up"] = "u";
        ECesiumPlayerModeAction["Down"] = "d";
        ECesiumPlayerModeAction["LookUp"] = "lu";
        ECesiumPlayerModeAction["LookDown"] = "ld";
        ECesiumPlayerModeAction["LookLeft"] = "ll";
        ECesiumPlayerModeAction["LookRight"] = "lr";
        ECesiumPlayerModeAction["Looking"] = "looking";
    })(ECesiumPlayerModeAction = exports.ECesiumPlayerModeAction || (exports.ECesiumPlayerModeAction = {}));
    var ECesiumPlayerModeMovementType;
    (function (ECesiumPlayerModeMovementType) {
        ECesiumPlayerModeMovementType["Walk"] = "walk";
        ECesiumPlayerModeMovementType["Fly"] = "fly";
    })(ECesiumPlayerModeMovementType = exports.ECesiumPlayerModeMovementType || (exports.ECesiumPlayerModeMovementType = {}));
    class CesiumPlayerMode {
        constructor(viewer) {
            // Dictionary of keyboard event code's mapping to player mode actions.
            // If you want to disable an action simply remove the map in this dictionary. 
            this.keyBinds = new dictionary_1.Dictionary();
            // Dictionary of player mode action's and their current states.
            this.actions = new dictionary_1.Dictionary();
            // Cesium event handlers.
            this.screenSpaceHandler = null;
            this.tickHandler = null;
            // Document event handlers.
            this.keyDownHandler = null;
            this.keyUpHandler = null;
            // Current movement speed.
            // In a single tick it applies this value in meters.
            // In perfect scenario this mode will tick at 60fps but it often does not reach that value.
            // When in walk mode this value has less weight as camera is re-adjusted to stay at consistent altitude.
            this.moveRate = 0.2;
            // Movement type (either walk or fly).
            this.movementType = ECesiumPlayerModeMovementType.Fly;
            // If player mode is on or not.
            this.running = false;
            this.viewer = viewer;
            this.populateKeybinds();
        }
        /**
         * Returns if player mode is currently running.
         */
        get isRunning() {
            return this.running;
        }
        /**
         * This method sets the keyboard bindings for the different player mode actions.
         *
         * Using method to apply bindings on constructor call instead of part of class declaration because-
         * object declaration in TS does not allow Enum -> Enum application even though they have string values.
         */
        populateKeybinds() {
            let dict = this.keyBinds;
            dict.Assign(keyboard_events_1.EKeyEventKey.W, ECesiumPlayerModeAction.Forward);
            dict.Assign(keyboard_events_1.EKeyEventKey.S, ECesiumPlayerModeAction.Backward);
            dict.Assign(keyboard_events_1.EKeyEventKey.A, ECesiumPlayerModeAction.Left);
            dict.Assign(keyboard_events_1.EKeyEventKey.D, ECesiumPlayerModeAction.Right);
            dict.Assign(keyboard_events_1.EKeyEventKey.Q, ECesiumPlayerModeAction.Up);
            dict.Assign(keyboard_events_1.EKeyEventKey.E, ECesiumPlayerModeAction.Down);
            dict.Assign(keyboard_events_1.EKeyEventKey.ArrowUp, ECesiumPlayerModeAction.LookUp);
            dict.Assign(keyboard_events_1.EKeyEventKey.ArrowRight, ECesiumPlayerModeAction.LookRight);
            dict.Assign(keyboard_events_1.EKeyEventKey.ArrowLeft, ECesiumPlayerModeAction.LookLeft);
            dict.Assign(keyboard_events_1.EKeyEventKey.ArrowDown, ECesiumPlayerModeAction.LookDown);
        }
        /**
         * Starts player mode.
         */
        Start() {
            if (this.running) {
                console.warn("Called Cesium Player Mode 'Start' while already started.");
                return;
            }
            this.running = true;
            let viewer = this.viewer.CesiumViewer;
            let canvas = viewer.canvas;
            let scene = viewer.scene;
            // Puts focus on canvas (means space wont keep turning off/on the button).
            canvas.setAttribute("tabindex", "0");
            canvas.onclick = function () {
                canvas.focus();
            };
            // Swap between normal event handlers and player mode ones.
            this.viewer.cameraHandler.isFrozen = true;
            scene.screenSpaceCameraController.maximumMovementRatio = 0.3;
            scene.screenSpaceCameraController.minimumCollisionTerrainHeight = 1000;
            //scene.logarithmicDepthBuffer = false;
            //camera.frustum.near = 0.01;
            this.listeners();
            this.cesiumEvents();
            let lastCheck;
            let currentTime = new Date();
            viewer.clock.onTick.addEventListener(this.tickHandler = () => __awaiter(this, void 0, void 0, function* () {
                lastCheck = new Date();
                if (lastCheck.getTime() - currentTime.getTime() > (1000 / 60)) {
                    this.doTick();
                    currentTime = new Date();
                }
            }));
        }
        listeners() {
            document.addEventListener("keydown", this.keyDownHandler = (e) => {
                this.updateDirectionByKey(e.key, true);
            }, false);
            document.addEventListener("keyup", this.keyUpHandler = (e) => {
                this.updateDirectionByKey(e.key, false);
            }, false);
        }
        updateDirectionByKey(key, state) {
            let action = this.keyBinds.Get(key);
            if (action) {
                this.actions.Assign(action, state);
            }
        }
        cesiumEvents() {
            let canvas = this.viewer.CesiumViewer.canvas;
            this.screenSpaceHandler = new Cesium.ScreenSpaceEventHandler(canvas);
            this.screenSpaceHandler.setInputAction((e) => {
                this.actions.Assign(ECesiumPlayerModeAction.Looking, true);
                this.currentMousePos = this.startMousePos = Cesium.Cartesian2.clone(e.position);
            }, Cesium.ScreenSpaceEventType.LEFT_DOWN);
            this.screenSpaceHandler.setInputAction(((movement) => {
                this.currentMousePos = movement.endPosition;
            }), Cesium.ScreenSpaceEventType.MOUSE_MOVE);
            this.screenSpaceHandler.setInputAction(() => {
                this.actions.Assign(ECesiumPlayerModeAction.Looking, false);
            }, Cesium.ScreenSpaceEventType.LEFT_UP);
        }
        /**
         * Stops player mode.
         */
        Stop() {
            if (!this.running) {
                console.warn("Called Cesium Player Mode 'Stop' while already stopped.");
                return;
            }
            this.running = false;
            let viewer = this.viewer.CesiumViewer;
            let scene = viewer.scene;
            // Re-enable camera controls.
            this.viewer.cameraHandler.isFrozen = false;
            scene.screenSpaceCameraController.maximumMovementRatio = 0.1;
            scene.screenSpaceCameraController.minimumCollisionTerrainHeight = 1000;
            //cene.logarithmicDepthBuffer = true;
            //camera.frustum.near = 1;
            // Remove new cesium event listeners.
            if (this.screenSpaceHandler != null) {
                this.screenSpaceHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOWN);
                this.screenSpaceHandler.removeInputAction(Cesium.ScreenSpaceEventType.MOUSE_MOVE);
                this.screenSpaceHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_UP);
            }
            // Remove document keyboard event listeners.
            document.removeEventListener("keyup", this.keyDownHandler);
            document.removeEventListener("keydown", this.keyUpHandler);
            // Remove the tick event listener
            viewer.clock.onTick.removeEventListener(this.tickHandler);
        }
        /**
         * Returns a new position using the current camera position, speed and a given heading.
         * @param heading
         * @returns
         */
        walk(heading) {
            let currentPos = this.viewer.CesiumViewer.camera.positionCartographic;
            currentPos.longitude = Cesium.Math.toDegrees(currentPos.longitude);
            currentPos.latitude = Cesium.Math.toDegrees(currentPos.latitude);
            let newPos = cesium_drawing_utils_14.CesiumDrawingUtils.OffsetPoint(currentPos, this.moveRate, heading);
            return newPos;
        }
        /**
         * Gets final heading from all enabled movement directions.
         * @returns
         */
        getHeading() {
            let heading = Cesium.Math.toDegrees(this.viewer.CesiumViewer.camera.heading);
            let count = 0;
            let totalHeading = 0;
            let left = this.actions.Get(ECesiumPlayerModeAction.Left);
            if (left) {
                totalHeading += heading + 270;
                count += 1;
            }
            if (this.actions.Get(ECesiumPlayerModeAction.Right)) {
                totalHeading += heading + 90;
                count += 1;
            }
            let forward = this.actions.Get(ECesiumPlayerModeAction.Forward);
            if (forward) {
                totalHeading += heading;
                count += 1;
            }
            if (this.actions.Get(ECesiumPlayerModeAction.Backward)) {
                totalHeading += heading + 180;
                count += 1;
            }
            if (left && forward) {
                totalHeading = heading - 45;
            }
            else {
                totalHeading /= count;
            }
            return totalHeading;
        }
        doTick() {
            let viewer = this.viewer.CesiumViewer;
            let canvas = viewer.canvas;
            let camera = viewer.camera;
            if (this.actions.Get(ECesiumPlayerModeAction.Looking)) {
                let width = canvas.clientWidth;
                let height = canvas.clientHeight;
                // Coordinate (0.0, 0.0) will be where the mouse was clicked.
                let x = (this.currentMousePos.x - this.startMousePos.x) / width;
                let y = -(this.currentMousePos.y - this.startMousePos.y) / height;
                let lookFactor = 0.1;
                camera.lookRight(x * lookFactor);
                camera.lookUp(y * lookFactor);
            }
            let moveRate = this.moveRate;
            let pos = viewer.camera.position;
            let carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(pos);
            // Camera movements on arrow keys down.
            let lookStep = 0.03;
            if (this.actions.Get(ECesiumPlayerModeAction.LookLeft)) {
                camera.lookLeft(lookStep);
            }
            if (this.actions.Get(ECesiumPlayerModeAction.LookRight)) {
                camera.lookRight(lookStep);
            }
            if (this.actions.Get(ECesiumPlayerModeAction.LookUp)) {
                camera.lookUp(lookStep);
            }
            if (this.actions.Get(ECesiumPlayerModeAction.LookDown)) {
                camera.lookDown(lookStep);
            }
            if (this.actions.Get(ECesiumPlayerModeAction.Up)) {
                camera.moveUp(moveRate / 2);
            }
            if (this.actions.Get(ECesiumPlayerModeAction.Down)) {
                camera.moveDown(moveRate / 2);
            }
            // Keep camera steady.
            if (camera.roll > 0) {
                camera.twistLeft(camera.roll);
            }
            else if (camera.roll < 0) {
                camera.twistRight(camera.roll * -1);
            }
            pos = viewer.camera.position;
            carto = Cesium.Ellipsoid.WGS84.cartesianToCartographic(pos);
            // If movement type is fly use cesium movement methods
            if (this.movementType == ECesiumPlayerModeMovementType.Fly) {
                if (this.actions.Get(ECesiumPlayerModeAction.Forward)) {
                    camera.moveForward(this.moveRate);
                }
                if (this.actions.Get(ECesiumPlayerModeAction.Backward)) {
                    camera.moveBackward(this.moveRate);
                }
                if (this.actions.Get(ECesiumPlayerModeAction.Left)) {
                    camera.moveLeft(this.moveRate);
                }
                if (this.actions.Get(ECesiumPlayerModeAction.Right)) {
                    camera.moveRight(this.moveRate);
                }
            }
            // If movement type is walk, calculate new position without affecting altitude
            else {
                if (this.actions.Get(ECesiumPlayerModeAction.Left) ||
                    this.actions.Get(ECesiumPlayerModeAction.Right) ||
                    this.actions.Get(ECesiumPlayerModeAction.Forward) ||
                    this.actions.Get(ECesiumPlayerModeAction.Backward)) {
                    let heading = this.getHeading();
                    carto = this.walk(heading);
                    camera.position = Cesium.Cartesian3.fromDegrees(carto.longitude, carto.latitude, carto.height);
                }
            }
        }
    }
    exports.CesiumPlayerMode = CesiumPlayerMode;
});
define("entry-points/cesium/common/cesium-line-creator", ["require", "exports", "cesium", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, cesium_drawing_utils_15, cesium_mouse_events_9, cesium_utils_22) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumLineCreator = void 0;
    Cesium = __importStar(Cesium);
    class CesiumLineCreator {
        constructor(viewer) {
            // The last updated mouse position.
            this.mousePosition = new Cesium.Cartesian3(0, 0, 0);
            // Z index to apply to polyline on its creation.
            this.zIndex = 10;
            this.viewer = viewer;
        }
        /**
         * Starts cesium mouse event listeners.
         */
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_9.CesiumMouseEvents(this.viewer);
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.EnableEventHandling();
            }
        }
        /**
         * Stops cesium mouse event listeners.
         */
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.dispose();
                this.mouseHandler = null;
            }
        }
        /**
         * Handles mouse movement in cesium view.
         * @param screenPos
         */
        doMouseMove(screenPos) {
            if (cesium_utils_22.CesiumUtils.Validate2DPosition(screenPos)) {
                let pos3d = cesium_drawing_utils_15.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                if (cesium_utils_22.CesiumUtils.ValidatePosition(pos3d)) {
                    this.mousePosition = pos3d;
                }
            }
        }
        /**
         * Handles mouse click in cesium view.
         * @param screenPos
         */
        doClick(screenPos) {
            if (cesium_utils_22.CesiumUtils.Validate2DPosition(screenPos)) {
                let pos3d = cesium_drawing_utils_15.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                if (cesium_utils_22.CesiumUtils.ValidatePosition(pos3d)) {
                    if (this.startPos && this.stopPos) {
                        this.stopPos = null;
                        this.startPos = pos3d;
                    }
                    else if (this.startPos) {
                        this.stopPos = pos3d;
                    }
                    else {
                        this.startPos = pos3d;
                    }
                }
            }
        }
        /**
         * Creates 3d entity representing current mouse position snapped to grid.
         */
        createMouseEntity() {
            if (!this.mouseEntity) {
                let mouseEntity = new Cesium.Entity({
                    point: {
                        pixelSize: 8,
                        color: Cesium.Color.fromCssColorString("rgb(77, 136, 255, 0.7)"),
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                    },
                    position: new Cesium.CallbackProperty(() => this.mousePosition, false)
                });
                this.viewer.entities.add(mouseEntity);
                this.mouseEntity = mouseEntity;
            }
        }
        /**
         * Removes the 3d entity representing mouse.
         */
        removeMouseEntity() {
            if (this.mouseEntity) {
                if (this.viewer.entities.contains(this.mouseEntity)) {
                    this.viewer.entities.remove(this.mouseEntity);
                }
                this.mouseEntity = null;
            }
        }
        /**
         * Creates cesium 3d entity that represents the current drawn polyline.
         */
        createPolylineEntity() {
            if (!this.polylineEntity) {
                let polylineEntity = new Cesium.Entity({
                    polyline: {
                        positions: new Cesium.CallbackProperty(() => this.getPositions(true), false),
                        material: Cesium.Color.fromCssColorString("rgb(77, 136, 255, 0.7)"),
                        clampToGround: true,
                        classificationType: Cesium.ClassificationType.TERRAIN,
                        arcType: Cesium.ArcType.GEODESIC,
                        width: 5,
                        zIndex: this.zIndex
                    }
                });
                this.viewer.entities.add(polylineEntity);
                this.polylineEntity = polylineEntity;
            }
        }
        /**
         * Removes the cesium 3d entity for current drawn polyline.
         */
        removePolylineEntity() {
            if (this.polylineEntity) {
                if (this.viewer.entities.contains(this.polylineEntity)) {
                    this.viewer.entities.remove(this.polylineEntity);
                }
                this.polylineEntity = null;
            }
        }
        /**
         * Returns positions defining the line positions.
         * Returns null if there is no defined polyline.
         */
        getPositions(allowMouse) {
            let p1 = this.startPos;
            let p2 = this.stopPos;
            if (!p2 && allowMouse) {
                p2 = this.mousePosition;
            }
            if (!cesium_utils_22.CesiumUtils.ValidatePositions([p1, p2])) {
                return null;
            }
            return [p1, p2];
        }
        Start() {
            this.startMouseListeners();
            this.createMouseEntity();
            this.createPolylineEntity();
        }
        Stop() {
            this.stopMouseListeners();
            this.removeMouseEntity();
            this.removePolylineEntity();
        }
    }
    exports.CesiumLineCreator = CesiumLineCreator;
});
define("entry-points/cesium/common/cesium-outline3d", ["require", "exports", "cesium", "bruce-models/common/color", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, color_2, cesium_drawing_utils_16, cesium_utils_23) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumOutline3D = void 0;
    Cesium = __importStar(Cesium);
    var ECesiumOutlineType;
    (function (ECesiumOutlineType) {
        ECesiumOutlineType[ECesiumOutlineType["Polygon"] = 0] = "Polygon";
        ECesiumOutlineType[ECesiumOutlineType["Polyline"] = 1] = "Polyline";
        ECesiumOutlineType[ECesiumOutlineType["Point"] = 2] = "Point";
        ECesiumOutlineType[ECesiumOutlineType["Model"] = 3] = "Model";
        ECesiumOutlineType[ECesiumOutlineType["None"] = 4] = "None";
    })(ECesiumOutlineType || (ECesiumOutlineType = {}));
    class CesiumOutline3D {
        constructor(viewer) {
            // Visual attributes.
            this.color = new color_2.Color(102, 161, 255, 0.95);
            this.width = 3;
            this.zIndex = 10;
            this.viewer = viewer;
        }
        /**
         * Outlines a given entity.
         * @Warning: this will detect changes in geometry but will not detect visual type changes.
         * @param entity
         */
        Outline(entity) {
            this.destroyOutline();
            this.currentEntity = entity;
            this.createOutline();
        }
        /**
         * Removes current outline if there is one.
         */
        Clear() {
            this.destroyOutline();
        }
        createOutline() {
            let type = this.detectType();
            this.outline = new Cesium.Entity({
                polyline: type == ECesiumOutlineType.Polygon || type == ECesiumOutlineType.Polyline ?
                    {
                        positions: new Cesium.CallbackProperty(() => this.getPoints(), false),
                        clampToGround: true,
                        width: this.width,
                        zIndex: this.zIndex,
                        material: cesium_utils_23.CesiumUtils.ColorToCesiumColor(this.color)
                    } : null
            });
            this.viewer.entities.add(this.outline);
        }
        detectType() {
            let ent = this.currentEntity;
            if (ent.model) {
                return ECesiumOutlineType.Model;
            }
            else if (ent.polygon) {
                return ECesiumOutlineType.Polygon;
            }
            else if (ent.polyline) {
                return ECesiumOutlineType.Polyline;
            }
            else if (ent.point) {
                return ECesiumOutlineType.Point;
            }
            return ECesiumOutlineType.None;
        }
        /**
         * Returns points for polygon / polyline outline.
         */
        getPoints() {
            let ent = this.currentEntity;
            if (ent.polygon) {
                let hierarchy = cesium_utils_23.CesiumUtils.getCesiumValue(this.viewer, ent.polygon.hierarchy);
                if (hierarchy) {
                    return cesium_drawing_utils_16.CesiumDrawingUtils.ClosePolygon(hierarchy.positions);
                }
            }
            else if (ent.polyline) {
                let posses = cesium_utils_23.CesiumUtils.getCesiumValue(this.viewer, ent.polyline.positions);
                if (posses) {
                    return cesium_drawing_utils_16.CesiumDrawingUtils.ClosePolygon(posses);
                }
            }
            return [];
        }
        destroyOutline() {
            if (this.outline && this.viewer.entities.contains(this.outline)) {
                this.viewer.entities.remove(this.outline);
            }
            this.outline = null;
        }
    }
    exports.CesiumOutline3D = CesiumOutline3D;
});
define("entry-points/cesium/common/cesium-polyline-geometry-creator", ["require", "exports", "cesium", "bruce-models/common/cartographic", "bruce-models/common/color", "utils/bruce-event", "utils/delay-queue", "utils/drawing-utils", "entry-points/cesium/common/cesium-cached-picking-height-util", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-geometry-editor-point", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-position-map", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, cartographic_8, color_3, bruce_event_12, delay_queue_8, drawing_utils_6, cesium_cached_picking_height_util_7, cesium_drawing_utils_17, cesium_geometry_editor_point_7, cesium_mouse_events_10, cesium_position_map_2, cesium_utils_24) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPolylineGeometryCreator = void 0;
    Cesium = __importStar(Cesium);
    class CesiumPolylineGeometryCreator {
        constructor(params) {
            this.zIndex = 5;
            this._disposed = false;
            this._started = false;
            // Clicked offset from the editor point's center point.
            this.mouseOffset = new Cesium.Cartesian2(0, 0);
            // Map representing currently drawn polyline positions.
            this.drawingMap = new cesium_position_map_2.CesiumPositionMap();
            // Editor points created for map positions.
            this.editorPoints = [];
            // Notifies when there is any change in the tool.
            this.onUpdateEvent = new bruce_event_12.BruceEvent();
            this.viewer = params.viewer;
            this.cameraHandler = params.cameraHandler;
            if (params.color) {
                this.color = params.color;
            }
            else {
                this.color = new color_3.Color(255, 255, 255, 1);
            }
            if (params.width == null) {
                this.width = 3;
            }
            else {
                this.width = params.width;
            }
            if (params.smoothen == null) {
                this.smoothen = 0;
            }
            else {
                this.smoothen = params.smoothen;
            }
            this.editorPointColor = params.editorPointColor;
            this.editorPointSize = params.editorPointSize;
            this.updateGeometriesQueue = new delay_queue_8.DelayQueue(() => {
                this.updateGeometry();
            }, 100);
            this.heightSampler = new cesium_cached_picking_height_util_7.CesiumCachedPickingHeightUtil(this.viewer);
        }
        get disposed() {
            return this._disposed;
        }
        get started() {
            return this._started;
        }
        getOnChangeEvent() {
            return this.onUpdateEvent;
        }
        Start() {
            if (this._disposed) {
                throw (">>Error: Cannot start creator that has been disposed.");
            }
            if (!this._started) {
                this.startMouseListeners();
                this._started = true;
            }
        }
        /**
         * @returns: current positions of the polyline.
         */
        getPositions() {
            return this.drawingMap.getPositions().map(x => x.clone());
        }
        /**
         * Sets smoothen level, if changed then a refresh on visual is queued.
         * @param value
         */
        SetSmoothen(value) {
            if (this.smoothen != value) {
                this.smoothen = value;
                this.updateGeometriesQueue.Call(false);
            }
        }
        Stop() {
            if (this._disposed) {
                throw (">>Error: Cannot stop creator that has been disposed.");
            }
            if (this._started) {
                this.stopMouseListeners();
                this.clear();
                this.removeCursor();
                this._started = false;
            }
        }
        Dispose() {
            if (!this._disposed) {
                this.Stop();
                this.heightSampler.Dispose();
                this._disposed = true;
            }
        }
        clear() {
            this.drawingMap = new cesium_position_map_2.CesiumPositionMap();
            if (this.drawingEntity && this.viewer.entities.contains(this.drawingEntity)) {
                this.viewer.entities.remove(this.drawingEntity);
            }
            this.drawingEntity = null;
            this.removeEditorPoints(true);
        }
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_10.CesiumMouseEvents(this.viewer);
                this.mouseHandler.LeftDownEvent.Subscribe((data) => {
                    this.doMouseLeftDown(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.LeftUpEvent.Subscribe((data) => {
                    this.doMouseLeftUp();
                });
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.RightClickEvent.Subscribe((data) => {
                    this.doMouseRightClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doMouseClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.EnableEventHandling();
            }
        }
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.Dispose();
                this.mouseHandler = null;
            }
        }
        doMouseClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = cesium_drawing_utils_17.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                    if (cesium_utils_24.CesiumUtils.ValidatePosition(pos3d)) {
                        this.addPosition(pos3d);
                    }
                }
            }
        }
        doMouseRightClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.removePoint(point);
                }
            }
        }
        doMouseMove(screenPos) {
            let updatedPos = true;
            if (cesium_utils_24.CesiumUtils.Validate2DPosition(screenPos)) {
                screenPos.x += this.mouseOffset.x;
                screenPos.y += this.mouseOffset.y;
                let pos3d = cesium_drawing_utils_17.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                if (cesium_utils_24.CesiumUtils.ValidatePosition(pos3d)) {
                    if (this.activePoint) {
                        updatedPos = false;
                        this.activePoint.updatePosition(pos3d);
                        this.updateGeometriesQueue.Call(false);
                    }
                }
            }
            if (updatedPos) {
                this.setPointerCursor(screenPos);
            }
        }
        doMouseLeftUp() {
            if (this.activePoint) {
                this.activePoint = null;
                this.cameraHandler.isFrozen = false;
            }
        }
        doMouseLeftDown(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.activePoint = point;
                    this.updateOffset(screenPos);
                    this.setGrabCursor();
                    this.cameraHandler.isFrozen = true;
                }
            }
        }
        /**
         * Removes drawing point and associated map data.
         * @param point
         */
        removePoint(point) {
            let map = this.drawingMap;
            if (map) {
                let pointsLeft = map.GetIds().length;
                if (pointsLeft > 0) {
                    map.Remove(point.posId);
                    let index = this.editorPoints.findIndex(x => x.posId == point.posId);
                    this.editorPoints.splice(index, 1);
                    point.DestroyEntity();
                }
                this.updateGeometriesQueue.Call(true);
            }
        }
        /**
         * Adds new position to nearest outer ring line.
         * @param position
         */
        addPosition(position) {
            let map = this.drawingMap;
            // Can't find nearest line yet.
            if (map.getPositions().length < 2) {
                let posId = map.Add(position);
                this.createEditorPoint(posId);
            }
            else {
                let insertIndex = map.GetInsertIndex(position);
                let posId = map.Insert(position, insertIndex);
                this.createEditorPoint(posId);
            }
            this.updateGeometriesQueue.Call(true);
        }
        /**
         * Returns editing point from this editor from given screen position.
         * @param screenPos
         * @returns
         */
        getEditorPointFromMouse(screenPos) {
            if (cesium_utils_24.CesiumUtils.Validate2DPosition(screenPos)) {
                let viewer = this.viewer;
                let pickedObjects = viewer.scene.drillPick(screenPos, 5);
                for (let i = 0; i < pickedObjects.length; i++) {
                    let pickedObject = pickedObjects[i];
                    if (pickedObject.id instanceof Cesium.Entity) {
                        pickedObject = pickedObject.id;
                    }
                    if (pickedObject && pickedObject._cesiumGeometryEditorPointId) {
                        let point = this.editorPoints.find(x => x.posId == pickedObject._cesiumGeometryEditorPointId);
                        if (point) {
                            return point;
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Creates an editor point for a given point id at a given branch id.
         * @param posId
         * @param hierarchyId
         */
        createEditorPoint(posId) {
            let point = new cesium_geometry_editor_point_7.CesiumGeometryEditorPoint({
                posId: posId,
                getPosition: () => this.drawingMap.Get(posId),
                showCallback: () => true,
                updatePosition: (position) => {
                    this.drawingMap.Update(posId, position);
                },
                viewer: this.viewer,
                color: this.editorPointColor,
                pixelSize: this.editorPointSize
            });
            point.CreateEntity();
            this.editorPoints.push(point);
        }
        /**
         * Updates the clicked offset from the entity's position.
         * @param screenPos
         */
        updateOffset(screenPos) {
            if (this.activePoint) {
                let position = this.activePoint.lastPosition;
                let grounded = Cesium.Cartographic.fromCartesian(position);
                let height = this.heightSampler.Pick(grounded);
                position = Cesium.Cartesian3.fromRadians(grounded.longitude, grounded.latitude, height);
                if (cesium_utils_24.CesiumUtils.ValidatePosition(position)) {
                    let entityScreenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, position);
                    if (cesium_utils_24.CesiumUtils.Validate2DPosition(entityScreenPos)) {
                        this.mouseOffset.x = entityScreenPos.x - screenPos.x;
                        this.mouseOffset.y = entityScreenPos.y - screenPos.y;
                    }
                }
            }
        }
        /**
         * Removes editing point visuals.
         * @param emptyArray If array of editor points should be cleared.
         */
        removeEditorPoints(emptyArray) {
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                point.DestroyEntity();
            }
            if (emptyArray) {
                this.editorPoints = [];
            }
        }
        /**
         * Updates cursor styling depending on if editing point is found underneath.
         * @param screenPos
         */
        setPointerCursor(screenPos) {
            let point = this.getEditorPointFromMouse(screenPos);
            if (point) {
                document.body.style.cursor = "pointer";
            }
            else {
                document.body.style.removeProperty("cursor");
            }
        }
        /**
         * Updates the screen cursor styling to be grabbing.
         */
        setGrabCursor() {
            document.body.style.cursor = "grabbing";
        }
        /**
         * Removes cursor styling.
         */
        removeCursor() {
            document.body.style.removeProperty("cursor");
        }
        updateGeometry() {
            let root = this.drawingEntity;
            if (root && !this.viewer.entities.contains(root)) {
                root = null;
            }
            if (root) {
                if (!root.polyline) {
                    this.createPolylineVisual(root);
                }
            }
            else {
                root = this.drawingEntity = new Cesium.Entity();
                this.viewer.entities.add(root);
                this.createPolylineVisual(root);
            }
            if (root.polyline) {
                this.viewer.scene.requestRender();
            }
            this.onUpdateEvent.Trigger();
        }
        createPolylineVisual(entity) {
            entity.polyline = new Cesium.PolylineGraphics({
                positions: new Cesium.CallbackProperty(() => {
                    let posses = this.drawingMap.getPositions();
                    return this.smoothenPoints(posses);
                }, false),
                clampToGround: true,
                material: cesium_utils_24.CesiumUtils.ColorToCesiumColor(this.color),
                width: this.width,
                classificationType: Cesium.ClassificationType.TERRAIN,
                arcType: Cesium.ArcType.GEODESIC,
                zIndex: this.zIndex
            });
        }
        smoothenPoints(points) {
            let times = this.smoothen;
            if (points && points.length > 2 && times > 0) {
                let dots = [];
                for (let i = 0; i < points.length; i++) {
                    let point = points[i];
                    let carto = Cesium.Cartographic.fromCartesian(point);
                    if (cartographic_8.Cartographic.Validate(carto)) {
                        dots.push({ x: carto.longitude, y: carto.latitude });
                    }
                    else {
                        return points;
                    }
                }
                let output = drawing_utils_6.DrawingUtils.ChaikinSmooth(dots);
                for (let i = 0; i < times - 1; i++) {
                    output = drawing_utils_6.DrawingUtils.ChaikinSmooth(output);
                }
                let newPoints = [];
                for (let i = 0; i < output.length; i++) {
                    let dot = output[i];
                    let newPoint = Cesium.Cartesian3.fromRadians(dot.x, dot.y);
                    if (cesium_utils_24.CesiumUtils.ValidatePosition(newPoint)) {
                        newPoints.push(newPoint);
                    }
                    else {
                        return points;
                    }
                }
                return newPoints;
            }
            return points;
        }
    }
    exports.CesiumPolylineGeometryCreator = CesiumPolylineGeometryCreator;
});
define("entry-points/cesium/common/cesium-polyline-geometry-editor", ["require", "exports", "cesium", "bruce-models/common/cartographic", "utils/bruce-event", "utils/delay-queue", "utils/drawing-utils", "entry-points/cesium/common/cesium-cached-picking-height-util", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-geometry-editor-point", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-position-map", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, cartographic_9, bruce_event_13, delay_queue_9, drawing_utils_7, cesium_cached_picking_height_util_8, cesium_drawing_utils_18, cesium_geometry_editor_point_8, cesium_mouse_events_11, cesium_position_map_3, cesium_utils_25) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumPolylineGeometryEditor = void 0;
    Cesium = __importStar(Cesium);
    class CesiumPolylineGeometryEditor {
        constructor(params) {
            this._disposed = false;
            this._started = false;
            // Clicked offset from the editor point's center point.
            this.mouseOffset = new Cesium.Cartesian2(0, 0);
            // Map representing currently drawn polyline positions.
            this.drawingMap = new cesium_position_map_3.CesiumPositionMap();
            // Editor points created for map positions.
            this.editorPoints = [];
            // Notifies when there is any change in the tool.
            this.onUpdateEvent = new bruce_event_13.BruceEvent();
            this.viewer = params.viewer;
            this.cameraHandler = params.cameraHandler;
            this.editingEntity = params.entity;
            if (params.smoothen == null) {
                this.smoothen = 0;
            }
            else {
                this.smoothen = params.smoothen;
            }
            this.editorPointColor = params.editorPointColor;
            this.editorPointSize = params.editorPointSize;
            this.updateGeometriesQueue = new delay_queue_9.DelayQueue(() => {
                this.updateGeometry();
            }, 100);
            this.heightSampler = new cesium_cached_picking_height_util_8.CesiumCachedPickingHeightUtil(this.viewer);
            this.startingPositions = params.posses;
            if (!this.startingPositions) {
                let posses = cesium_utils_25.CesiumUtils.getCesiumValue(this.viewer, this.editingEntity.polyline.positions);
                this.startingPositions = posses;
            }
        }
        get disposed() {
            return this._disposed;
        }
        get started() {
            return this._started;
        }
        init() {
            this.drawingMap.Clear();
            this.removeEditorPoints(true);
            let posses = this.startingPositions;
            for (let i = 0; i < posses.length; i++) {
                let pos = posses[i];
                let id = this.drawingMap.Add(pos.clone());
                this.createEditorPoint(id);
            }
            this.unlinkGeometry();
        }
        getOnChangeEvent() {
            return this.onUpdateEvent;
        }
        Start() {
            if (this._disposed) {
                throw (">>Error: Cannot start editor that has been disposed.");
            }
            if (!this._started) {
                this.startMouseListeners();
                this._started = true;
                this.init();
                this.updateGeometriesQueue.Call(true);
            }
        }
        /**
         * @returns: current positions of the polyline.
         */
        getPositions() {
            return this.drawingMap.getPositions().map(x => x.clone());
        }
        /**
         * If tool is running then calling reset will refresh editor points and visuals.
         */
        Reset() {
            if (this._disposed) {
                throw (">>Error: Cannot reset editor that has been disposed.");
            }
            if (this._started) {
                this.init();
            }
        }
        /**
         * Sets smoothen level, if changed then a refresh on visual is queued.
         * @param value
         */
        SetSmoothen(value) {
            if (this.smoothen != value) {
                this.smoothen = value;
                this.updateGeometriesQueue.Call(false);
            }
        }
        Stop() {
            if (this._disposed) {
                throw (">>Error: Cannot stop editor that has been disposed.");
            }
            if (this._started) {
                this.stopMouseListeners();
                this.clear();
                this.removeCursor();
                this.unlinkGeometry();
                this._started = false;
            }
        }
        Dispose() {
            if (!this._disposed) {
                this.Stop();
                this.heightSampler.Dispose();
                this._disposed = true;
            }
        }
        clear() {
            this.removeEditorPoints(true);
        }
        startMouseListeners() {
            if (!this.mouseHandler) {
                this.mouseHandler = new cesium_mouse_events_11.CesiumMouseEvents(this.viewer);
                this.mouseHandler.LeftDownEvent.Subscribe((data) => {
                    this.doMouseLeftDown(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.LeftUpEvent.Subscribe((data) => {
                    this.doMouseLeftUp();
                });
                this.mouseHandler.MoveEvent.Subscribe((data) => {
                    this.doMouseMove(data === null || data === void 0 ? void 0 : data.endPosition);
                });
                this.mouseHandler.RightClickEvent.Subscribe((data) => {
                    this.doMouseRightClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.ClickEvent.Subscribe((data) => {
                    this.doMouseClick(data === null || data === void 0 ? void 0 : data.position);
                });
                this.mouseHandler.EnableEventHandling();
            }
        }
        stopMouseListeners() {
            if (this.mouseHandler) {
                this.mouseHandler.Dispose();
                this.mouseHandler = null;
            }
        }
        doMouseClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (!point) {
                    let pos3d = cesium_drawing_utils_18.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                    if (cesium_utils_25.CesiumUtils.ValidatePosition(pos3d)) {
                        this.addPosition(pos3d);
                    }
                }
            }
        }
        doMouseRightClick(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.removePoint(point);
                }
            }
        }
        doMouseMove(screenPos) {
            let updatedPos = true;
            if (cesium_utils_25.CesiumUtils.Validate2DPosition(screenPos)) {
                screenPos.x += this.mouseOffset.x;
                screenPos.y += this.mouseOffset.y;
                let pos3d = cesium_drawing_utils_18.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, screenPos);
                if (cesium_utils_25.CesiumUtils.ValidatePosition(pos3d)) {
                    if (this.activePoint) {
                        updatedPos = false;
                        this.activePoint.updatePosition(pos3d);
                        this.updateGeometriesQueue.Call(false);
                    }
                }
            }
            if (updatedPos) {
                this.setPointerCursor(screenPos);
            }
        }
        doMouseLeftUp() {
            if (this.activePoint) {
                this.activePoint = null;
                this.cameraHandler.isFrozen = false;
            }
        }
        doMouseLeftDown(screenPos) {
            if (!this.activePoint) {
                let point = this.getEditorPointFromMouse(screenPos);
                if (point) {
                    this.activePoint = point;
                    this.updateOffset(screenPos);
                    this.setGrabCursor();
                    this.cameraHandler.isFrozen = true;
                }
            }
        }
        /**
         * Removes drawing point and associated map data.
         * @param point
         */
        removePoint(point) {
            let map = this.drawingMap;
            if (map) {
                let pointsLeft = map.GetIds().length;
                if (pointsLeft > 2) {
                    map.Remove(point.posId);
                    let index = this.editorPoints.findIndex(x => x.posId == point.posId);
                    this.editorPoints.splice(index, 1);
                    point.DestroyEntity();
                    this.updateGeometriesQueue.Call(true);
                }
            }
        }
        /**
         * Adds new position to nearest outer ring line.
         * @param position
         */
        addPosition(position) {
            let map = this.drawingMap;
            // Can't find nearest line yet.
            if (map.getPositions().length < 2) {
                let posId = map.Add(position);
                this.createEditorPoint(posId);
            }
            else {
                let insertIndex = map.GetInsertIndex(position);
                let posId = map.Insert(position, insertIndex);
                this.createEditorPoint(posId);
            }
            this.updateGeometriesQueue.Call(true);
        }
        /**
         * Returns editing point from this editor from given screen position.
         * @param screenPos
         * @returns
         */
        getEditorPointFromMouse(screenPos) {
            if (cesium_utils_25.CesiumUtils.Validate2DPosition(screenPos)) {
                let viewer = this.viewer;
                let pickedObjects = viewer.scene.drillPick(screenPos, 5);
                for (let i = 0; i < pickedObjects.length; i++) {
                    let pickedObject = pickedObjects[i];
                    if (pickedObject.id instanceof Cesium.Entity) {
                        pickedObject = pickedObject.id;
                    }
                    if (pickedObject && pickedObject._cesiumGeometryEditorPointId) {
                        let point = this.editorPoints.find(x => x.posId == pickedObject._cesiumGeometryEditorPointId);
                        if (point) {
                            return point;
                        }
                    }
                }
            }
            return null;
        }
        /**
         * Creates an editor point for a given point id at a given branch id.
         * @param posId
         * @param hierarchyId
         */
        createEditorPoint(posId) {
            let point = new cesium_geometry_editor_point_8.CesiumGeometryEditorPoint({
                posId: posId,
                getPosition: () => this.drawingMap.Get(posId),
                showCallback: () => true,
                updatePosition: (position) => {
                    this.drawingMap.Update(posId, position);
                },
                viewer: this.viewer,
                color: this.editorPointColor,
                pixelSize: this.editorPointSize
            });
            point.CreateEntity();
            this.editorPoints.push(point);
        }
        /**
         * Updates the clicked offset from the entity's position.
         * @param screenPos
         */
        updateOffset(screenPos) {
            if (this.activePoint) {
                let position = this.activePoint.lastPosition;
                let grounded = Cesium.Cartographic.fromCartesian(position);
                let height = this.heightSampler.Pick(grounded);
                position = Cesium.Cartesian3.fromRadians(grounded.longitude, grounded.latitude, height);
                if (cesium_utils_25.CesiumUtils.ValidatePosition(position)) {
                    let entityScreenPos = Cesium.SceneTransforms.wgs84ToWindowCoordinates(this.viewer.scene, position);
                    if (cesium_utils_25.CesiumUtils.Validate2DPosition(entityScreenPos)) {
                        this.mouseOffset.x = entityScreenPos.x - screenPos.x;
                        this.mouseOffset.y = entityScreenPos.y - screenPos.y;
                    }
                }
            }
        }
        /**
         * Removes editing point visuals.
         * @param emptyArray If array of editor points should be cleared.
         */
        removeEditorPoints(emptyArray) {
            for (let i = 0; i < this.editorPoints.length; i++) {
                let point = this.editorPoints[i];
                point.DestroyEntity();
            }
            if (emptyArray) {
                this.editorPoints = [];
            }
        }
        /**
         * Updates cursor styling depending on if editing point is found underneath.
         * @param screenPos
         */
        setPointerCursor(screenPos) {
            let point = this.getEditorPointFromMouse(screenPos);
            if (point) {
                document.body.style.cursor = "pointer";
            }
            else {
                document.body.style.removeProperty("cursor");
            }
        }
        /**
         * Updates the screen cursor styling to be grabbing.
         */
        setGrabCursor() {
            document.body.style.cursor = "grabbing";
        }
        /**
         * Removes cursor styling.
         */
        removeCursor() {
            document.body.style.removeProperty("cursor");
        }
        updateGeometry() {
            if (!this._started || this._disposed) {
                return;
            }
            let root = this.editingEntity;
            if (root) {
                let posses = root.polyline.positions;
                if (!(posses instanceof Cesium.CallbackProperty)) {
                    root.polyline.positions = new Cesium.CallbackProperty(() => {
                        let posses = this.drawingMap.getPositions();
                        return this.smoothenPoints(posses);
                    }, false);
                }
            }
            if (root.polyline) {
                this.viewer.scene.requestRender();
            }
            this.onUpdateEvent.Trigger();
        }
        unlinkGeometry() {
            let root = this.editingEntity;
            if (root) {
                let posses = root.polyline.positions;
                if (posses instanceof Cesium.CallbackProperty) {
                    let posses = this.drawingMap.getPositions();
                    root.polyline.positions = this.smoothenPoints(posses);
                    this.viewer.scene.requestRender();
                }
            }
        }
        smoothenPoints(points) {
            let times = this.smoothen;
            if (points && points.length > 2 && times > 0) {
                let dots = [];
                for (let i = 0; i < points.length; i++) {
                    let point = points[i];
                    let carto = Cesium.Cartographic.fromCartesian(point);
                    if (cartographic_9.Cartographic.Validate(carto)) {
                        dots.push({ x: carto.longitude, y: carto.latitude });
                    }
                    else {
                        return points;
                    }
                }
                let output = drawing_utils_7.DrawingUtils.ChaikinSmooth(dots);
                for (let i = 0; i < times - 1; i++) {
                    output = drawing_utils_7.DrawingUtils.ChaikinSmooth(output);
                }
                let newPoints = [];
                for (let i = 0; i < output.length; i++) {
                    let dot = output[i];
                    let newPoint = Cesium.Cartesian3.fromRadians(dot.x, dot.y);
                    if (cesium_utils_25.CesiumUtils.ValidatePosition(newPoint)) {
                        newPoints.push(newPoint);
                    }
                    else {
                        return points;
                    }
                }
                return newPoints;
            }
            return points;
        }
    }
    exports.CesiumPolylineGeometryEditor = CesiumPolylineGeometryEditor;
});
define("utils/cursor-css-handler", ["require", "exports", "bruce-models/common/dictionary", "utils/object-utils"], function (require, exports, dictionary_2, object_utils_52) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CursorCSSHandler = exports.ECursor = void 0;
    var ECursor;
    (function (ECursor) {
        ECursor["Default"] = "default";
        ECursor["Pointer"] = "pointer";
        ECursor["Loading"] = "wait";
    })(ECursor = exports.ECursor || (exports.ECursor = {}));
    /**
     * Handles cursor state for a provided HTML container.
     */
    class CursorCSSHandler {
        constructor(container) {
            // All requests currently active. Keys are the request ids.
            this.data = new dictionary_2.Dictionary();
            this.container = container;
        }
        get state() {
            return this._state;
        }
        /**
         * @param priority: how important this state is compared to others. Higher priority values itself over others.
         * @param state: the cursor CSS to apply.
         * @returns: request id to use to dismiss the request.
         */
        RequestState(priority, state) {
            let id = object_utils_52.ObjectUtils.UID();
            this.data.Assign(id, {
                priority: priority,
                state: state
            });
            this.update();
            return id;
        }
        /**
         * Enables the given cursor state by putting it at the top of the priority list.
         * @param state
         * @returns: request id to use to dismiss the a state request.
         */
        ForceState(state) {
            let id = object_utils_52.ObjectUtils.UID();
            this.data.Assign(id, {
                priority: this.getNextHighestPriority(),
                state: state
            });
            this.update();
            return id;
        }
        /**
         * Dismisses a cursor state request by id.
         * @param requestId
         */
        DismissRequest(requestId) {
            this.data.Delete(requestId);
            this.update();
        }
        /**
         * Removes all requests and sets cursor to default.
         */
        Reset() {
            this.data.Clear();
            this.update();
        }
        /**
         * Checks current requests and makes a decision on what cursor should be active.
         */
        update() {
            let requests = this.getRequestsDescending();
            if (requests.length > 0) {
                this.setState(requests[0].state);
            }
            else {
                this.setState(ECursor.Default);
            }
        }
        setState(state) {
            if (state == ECursor.Default) {
                this.container.style.removeProperty("cursor");
            }
            else {
                this.container.style.cursor = state;
            }
        }
        /**
         * @returns: a priority value higher than any currently active.
         */
        getNextHighestPriority() {
            let requests = this.getRequestsDescending();
            if (requests.length <= 0) {
                return 0;
            }
            else {
                return requests[0].priority + 1;
            }
        }
        /**
         * @returns: all current state requests ordered by highest priority first.
         */
        getRequestsDescending() {
            let values = this.data.getValues();
            values.sort((a, b) => {
                if (a.priority < b.priority) {
                    return 1;
                }
                else if (a.priority > b.priority) {
                    return -1;
                }
                return 0;
            });
            return values;
        }
    }
    exports.CursorCSSHandler = CursorCSSHandler;
});
define("entry-points/cesium/common/cesium-rectangle-drawer", ["require", "exports", "cesium", "bruce-maps-widget", "bruce-models/common/cartesian2", "utils/delay-queue", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-utils"], function (require, exports, Cesium, bruce_maps_widget_7, cartesian2_2, delay_queue_10, cesium_drawing_utils_19, cesium_mouse_events_12, cesium_utils_26) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CesiumRectangleDrawer = void 0;
    Cesium = __importStar(Cesium);
    class CesiumRectangleDrawer {
        constructor(viewer, cameraHandler, cursorHandler) {
            // State of the drawer.
            this._running = false;
            this._paused = false;
            // Delay queue for updating position2 from last 2d position.
            this.posDrawUpdateQueue = new delay_queue_10.DelayQueue(this.onDrawMouseMoveQueueUpdate.bind(this), 50);
            this.posEditUpdateQueue = new delay_queue_10.DelayQueue(this.onEditMouseMoveQueueUpdate.bind(this), 50);
            if (viewer == null) {
                throw (">>Developer error: viewer is required for CesiumRectangleDrawer.");
            }
            if (cameraHandler == null) {
                throw (">>Developer error: cameraHandler is required for CesiumRectangleDrawer.");
            }
            if (cursorHandler == null) {
                throw (">>Developer error: cursorHandler is required for CesiumRectangleDrawer.");
            }
            this.viewer = viewer;
            this.cameraHandler = cameraHandler;
            this.cursorHandler = cursorHandler;
        }
        get running() {
            return this._running;
        }
        get paused() {
            return this._paused;
        }
        get OnUpdateEvent() {
            if (this._onUpdateEvent == null) {
                this._onUpdateEvent = new bruce_maps_widget_7.BruceEvent();
            }
            return this._onUpdateEvent;
        }
        get editors() {
            return [this.corner1, this.corner2, this.corner3, this.corner4, this.side1, this.side2, this.side3, this.side4];
        }
        /**
         * Starts the tool.
         */
        Start() {
            if (this._paused || this._running) {
                throw (">>Developer Error: CesiumRectangleDrawer is already in a running state.");
            }
            this._paused = false;
            this._running = true;
            this.initDrawEvents();
            this.createRectangleEntity();
            this.cursorHandlerId = this.cursorHandler.RequestState(0, "cell");
        }
        /**
         * Starts the tool with a defined rectangle.
         */
        StartWithPositions(pos1, pos2) {
            if (this._paused || this._running) {
                throw (">>Developer Error: CesiumRectangleDrawer is already in a running state.");
            }
            this._paused = false;
            this._running = true;
            this.pos1 = pos1;
            this.pos2 = pos2;
            this.createRectangleEntity();
            this.disposeDrawEvents();
            this.createRectangleEditors();
            this.initEditEvents();
        }
        /**
         * Stops and disposes the tool.
         */
        Stop() {
            if (!this._running) {
                throw (">>Developer Error: CesiumRectangleDrawer is not running.");
            }
            this._paused = false;
            this._running = false;
            this.editorEntity = null;
            this.disposeDrawEvents();
            this.disposeEditEvents();
            this.disposeRectangleEntity();
            this.disposeRectangleEditors();
            if (this.cursorHandlerId) {
                this.cursorHandler.DismissRequest(this.cursorHandlerId);
                this.cursorHandlerId = null;
            }
        }
        /**
         * Stops listening to events but keeps the drawn rectangle as is.
         */
        Pause() {
            if (!this._running) {
                throw (">>Developer Error: CesiumRectangleDrawer is not running.");
            }
            this._paused = true;
            this.editorEntity = null;
            this.disposeDrawEvents();
            this.disposeEditEvents();
            if (this.cursorHandlerId) {
                this.cursorHandler.DismissRequest(this.cursorHandlerId);
                this.cursorHandlerId = null;
            }
        }
        /**
         * Resumes listening to events after a pause.
         */
        Resume() {
            if (!this._paused || !this._running) {
                throw (">>Developer Error: CesiumRectangleDrawer is not paused.");
            }
            this._paused = false;
            if (this.pos1 && this.pos2) {
                this.initEditEvents();
            }
            else {
                this.initDrawEvents();
                this.cursorHandlerId = this.cursorHandler.RequestState(0, "cell");
            }
        }
        /**
         * Returns rectangle positions from its current state.
         */
        GetPositions() {
            if (this.pos1 && this.pos2) {
                return [this.pos1, this.pos2];
            }
            return [];
        }
        /**
         * Initializes and starts events for detecting mouse in Cesium viewer.
         */
        initDrawEvents() {
            if (!this.drawEventHandler) {
                let eventHandler = new cesium_mouse_events_12.CesiumMouseEvents(this.viewer);
                eventHandler.MoveEvent.Subscribe(this.onDrawMouseMove.bind(this));
                eventHandler.LeftDownEvent.Subscribe(this.onDrawMouseDown.bind(this));
                eventHandler.LeftUpEvent.Subscribe(this.onDrawMouseUp.bind(this));
                eventHandler.EnableEventHandling();
                this.drawEventHandler = eventHandler;
            }
        }
        /**
         * Reacts to mouse moving while in rectangle draw.
         * Queues an update on the visual.
         * @param e
         */
        onDrawMouseMove(e) {
            if (this.cameraHandler.isFrozen && cartesian2_2.Cartesian2.Validate(e === null || e === void 0 ? void 0 : e.endPosition)) {
                this.lastDraw2dPos = e.endPosition;
                this.posDrawUpdateQueue.Call();
            }
        }
        /**
         * Reacts to visual update queue being triggered for rectangle draw.
         * Updates the rectangle entity.
         */
        onDrawMouseMoveQueueUpdate() {
            let pos2d = this.lastDraw2dPos;
            if (pos2d) {
                let pos3d = cesium_drawing_utils_19.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, pos2d);
                if (cesium_utils_26.CesiumUtils.ValidatePosition(pos3d)) {
                    this.pos2 = pos3d;
                    this.lastDraw2dPos = null;
                    this.viewer.scene.requestRender();
                }
            }
        }
        /**
         * Reacts to mouse press down when in rectangle draw.
         * Samples position and sets it as starting position.
         * @param e
         */
        onDrawMouseDown(e) {
            if (!this.cameraHandler.isFrozen) {
                if (cartesian2_2.Cartesian2.Validate(e === null || e === void 0 ? void 0 : e.position)) {
                    let pos3d = cesium_drawing_utils_19.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, e.position);
                    if (cesium_utils_26.CesiumUtils.ValidatePosition(pos3d)) {
                        this.cameraHandler.isFrozen = true;
                        this.pos1 = pos3d;
                        this.viewer.scene.requestRender();
                    }
                }
            }
        }
        /**
         * Reacts to mouse press up when in rectangle draw.
         * Samples position and finishes rectangle draw.
         * @param e
         */
        onDrawMouseUp(e) {
            var _a;
            if (this.cameraHandler.isFrozen) {
                if (this.pos1 && this.pos2) {
                    if (this.cursorHandlerId) {
                        this.cursorHandler.DismissRequest(this.cursorHandlerId);
                        this.cursorHandlerId = null;
                    }
                    this.disposeDrawEvents();
                    this.createRectangleEditors();
                    this.initEditEvents();
                }
                else if (this.pos1) {
                    this.pos1 = null;
                }
                this.cameraHandler.isFrozen = false;
                this.viewer.scene.requestRender();
                (_a = this._onUpdateEvent) === null || _a === void 0 ? void 0 : _a.Trigger();
            }
        }
        /**
         * Disposes Cesium mouse event handler.
         */
        disposeDrawEvents() {
            if (this.drawEventHandler) {
                this.drawEventHandler.Dispose();
                this.drawEventHandler = null;
            }
            this.cameraHandler.isFrozen = false;
            this.lastDraw2dPos = null;
        }
        /**
         * Creates rectangle entity and adds it to Cesium viewer.
         */
        createRectangleEntity() {
            if (!this.rectangleEntity) {
                this.rectangleEntity = new Cesium.Entity({
                    rectangle: {
                        coordinates: new Cesium.CallbackProperty(() => {
                            if (this.pos1 && this.pos2) {
                                return Cesium.Rectangle.fromCartesianArray([this.pos1, this.pos2]);
                            }
                            return null;
                        }, false),
                        fill: true,
                        material: Cesium.Color.fromCssColorString("rgba(35, 169, 252, 0.4)"),
                        heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                    }
                });
                this.viewer.entities.add(this.rectangleEntity);
            }
        }
        /**
         * Creates all rectangle side and corner entities.
         */
        createRectangleEditors() {
            // At least one side exists so we assume all sides/corners exist.
            if (!this.side1) {
                let getPos1 = () => this.pos1;
                let getPos2 = () => {
                    if (cesium_utils_26.CesiumUtils.ValidatePositions([this.pos1, this.pos2])) {
                        let carto1 = Cesium.Cartographic.fromCartesian(this.pos1);
                        let carto2 = Cesium.Cartographic.fromCartesian(this.pos2);
                        return Cesium.Cartesian3.fromRadians(carto1.longitude, carto2.latitude, carto1.height);
                    }
                    return null;
                };
                let getPos3 = () => this.pos2;
                let getPos4 = () => {
                    if (cesium_utils_26.CesiumUtils.ValidatePositions([this.pos1, this.pos2])) {
                        let carto1 = Cesium.Cartographic.fromCartesian(this.pos1);
                        let carto2 = Cesium.Cartographic.fromCartesian(this.pos2);
                        return Cesium.Cartesian3.fromRadians(carto2.longitude, carto1.latitude, carto2.height);
                    }
                    return null;
                };
                let setPos1 = (pos) => {
                    this.pos1 = pos;
                };
                let setPos2 = (pos) => {
                    if (cesium_utils_26.CesiumUtils.ValidatePositions([pos, this.pos1, this.pos2])) {
                        let carto1 = Cesium.Cartographic.fromCartesian(this.pos1);
                        let carto2 = Cesium.Cartographic.fromCartesian(this.pos2);
                        let carto3 = Cesium.Cartographic.fromCartesian(pos);
                        this.pos1 = Cesium.Cartesian3.fromRadians(carto3.longitude, carto1.latitude, carto1.height);
                        this.pos2 = Cesium.Cartesian3.fromRadians(carto2.longitude, carto3.latitude, carto2.height);
                    }
                };
                let setPos3 = (pos) => {
                    this.pos2 = pos;
                };
                let setPos4 = (pos) => {
                    if (cesium_utils_26.CesiumUtils.ValidatePositions([pos, this.pos1, this.pos2])) {
                        let carto1 = Cesium.Cartographic.fromCartesian(this.pos1);
                        let carto2 = Cesium.Cartographic.fromCartesian(this.pos2);
                        let carto3 = Cesium.Cartographic.fromCartesian(pos);
                        this.pos1 = Cesium.Cartesian3.fromRadians(carto1.longitude, carto3.latitude, carto1.height);
                        this.pos2 = Cesium.Cartesian3.fromRadians(carto3.longitude, carto2.latitude, carto2.height);
                    }
                };
                let setSide1Pos = (pos) => {
                    if (cesium_utils_26.CesiumUtils.ValidatePositions([pos, this.pos1])) {
                        let carto1 = Cesium.Cartographic.fromCartesian(pos);
                        let carto2 = Cesium.Cartographic.fromCartesian(this.pos1);
                        this.pos1 = Cesium.Cartesian3.fromRadians(carto1.longitude, carto2.latitude, carto1.height);
                    }
                };
                let setSide2Pos = (pos) => {
                    if (cesium_utils_26.CesiumUtils.ValidatePositions([pos, this.pos2])) {
                        let carto1 = Cesium.Cartographic.fromCartesian(pos);
                        let carto2 = Cesium.Cartographic.fromCartesian(this.pos2);
                        this.pos2 = Cesium.Cartesian3.fromRadians(carto2.longitude, carto1.latitude, carto1.height);
                    }
                };
                let setSide3Pos = (pos) => {
                    if (cesium_utils_26.CesiumUtils.ValidatePositions([pos, this.pos2])) {
                        let carto1 = Cesium.Cartographic.fromCartesian(pos);
                        let carto2 = Cesium.Cartographic.fromCartesian(this.pos2);
                        this.pos2 = Cesium.Cartesian3.fromRadians(carto1.longitude, carto2.latitude, carto1.height);
                    }
                };
                let setSide4Pos = (pos) => {
                    if (cesium_utils_26.CesiumUtils.ValidatePositions([pos, this.pos1])) {
                        let carto1 = Cesium.Cartographic.fromCartesian(pos);
                        let carto2 = Cesium.Cartographic.fromCartesian(this.pos1);
                        this.pos1 = Cesium.Cartesian3.fromRadians(carto2.longitude, carto1.latitude, carto1.height);
                    }
                };
                this.side1 = this.createRectangleSide(getPos1, getPos2, setSide1Pos);
                this.side2 = this.createRectangleSide(getPos2, getPos3, setSide2Pos);
                this.side3 = this.createRectangleSide(getPos3, getPos4, setSide3Pos);
                this.side4 = this.createRectangleSide(getPos4, getPos1, setSide4Pos);
                this.corner1 = this.createRectangleCorner(getPos1, setPos1);
                this.corner2 = this.createRectangleCorner(getPos2, setPos2);
                this.corner3 = this.createRectangleCorner(getPos3, setPos3);
                this.corner4 = this.createRectangleCorner(getPos4, setPos4);
            }
        }
        /**
         * Disposes all rectangle side and corner entities.
         */
        disposeRectangleEditors() {
            if (this.side1 && this.viewer.entities.contains(this.side1)) {
                this.viewer.entities.remove(this.side1);
            }
            if (this.side2 && this.viewer.entities.contains(this.side2)) {
                this.viewer.entities.remove(this.side2);
            }
            if (this.side3 && this.viewer.entities.contains(this.side3)) {
                this.viewer.entities.remove(this.side3);
            }
            if (this.side4 && this.viewer.entities.contains(this.side4)) {
                this.viewer.entities.remove(this.side4);
            }
            this.side1 = null;
            this.side2 = null;
            this.side3 = null;
            this.side4 = null;
            if (this.corner1 && this.viewer.entities.contains(this.corner1)) {
                this.viewer.entities.remove(this.corner1);
            }
            if (this.corner2 && this.viewer.entities.contains(this.corner2)) {
                this.viewer.entities.remove(this.corner2);
            }
            if (this.corner3 && this.viewer.entities.contains(this.corner3)) {
                this.viewer.entities.remove(this.corner3);
            }
            if (this.corner4 && this.viewer.entities.contains(this.corner4)) {
                this.viewer.entities.remove(this.corner4);
            }
            this.corner1 = null;
            this.corner2 = null;
            this.corner3 = null;
            this.corner4 = null;
        }
        /**
         * Creates and returns rectangle side entity from given set of position getters/setters.
         * @param getPos1
         * @param getPos2
         * @param setPos
         */
        createRectangleSide(getPos1, getPos2, setPos) {
            let sideEntity = new Cesium.Entity({
                polyline: {
                    positions: new Cesium.CallbackProperty(() => {
                        let pos1 = getPos1();
                        let pos2 = getPos2();
                        if (pos1 && pos2) {
                            return [pos1, pos2];
                        }
                        return [];
                    }, false),
                    material: Cesium.Color.fromCssColorString("rgba(35, 169, 252, 0.9)"),
                    width: 3,
                    clampToGround: true
                }
            });
            sideEntity.setPos = setPos;
            this.viewer.entities.add(sideEntity);
            return sideEntity;
        }
        /**
         * Disposes rectangle entity.
         */
        disposeRectangleEntity() {
            if (this.rectangleEntity && this.viewer && this.viewer.entities.contains(this.rectangleEntity)) {
                this.viewer.entities.remove(this.rectangleEntity);
                this.viewer.scene.requestRender();
            }
            this.rectangleEntity = null;
        }
        /**
         * Creates and returns a rectangle corner entity from given callbacks.
         * @param getPos
         * @param setPos
         */
        createRectangleCorner(getPos, setPos) {
            let cornerEntity = new Cesium.Entity({
                point: {
                    color: Cesium.Color.fromCssColorString("rgba(35, 169, 252, 0.9)"),
                    pixelSize: 15,
                    heightReference: Cesium.HeightReference.CLAMP_TO_GROUND
                },
                position: new Cesium.CallbackProperty(() => getPos(), false)
            });
            cornerEntity.setPos = setPos;
            this.viewer.entities.add(cornerEntity);
            return cornerEntity;
        }
        /**
         * Creates and starts listening to Cesium events for editing rectangle.
         */
        initEditEvents() {
            if (!this.editEventHandler) {
                let eventHandler = new cesium_mouse_events_12.CesiumMouseEvents(this.viewer);
                eventHandler.MoveEvent.Subscribe(this.onEditMouseMove.bind(this));
                eventHandler.LeftDownEvent.Subscribe(this.onEditMouseDown.bind(this));
                eventHandler.LeftUpEvent.Subscribe(this.onEditMouseUp.bind(this));
                eventHandler.EnableEventHandling();
                this.editEventHandler = eventHandler;
            }
        }
        /**
         * Reacts to mouse move event from editor events.
         * @param e
         */
        onEditMouseMove(e) {
            if (cartesian2_2.Cartesian2.Validate(e === null || e === void 0 ? void 0 : e.endPosition)) {
                this.lastEdit2dPos = e.endPosition;
                this.posEditUpdateQueue.Call();
            }
        }
        onEditMouseMoveQueueUpdate() {
            if (this.editorEntity) {
                let pos2d = this.lastEdit2dPos;
                if (pos2d) {
                    let pos3d = cesium_drawing_utils_19.CesiumDrawingUtils.GetCartesian3TerrainFromMouse(this.viewer, pos2d);
                    if (cesium_utils_26.CesiumUtils.ValidatePosition(pos3d)) {
                        this.editorEntity.setPos(pos3d);
                        this.lastEdit2dPos = null;
                        this.viewer.scene.requestRender();
                    }
                }
            }
            else {
                let hoverEntity = null;
                if (this.lastEdit2dPos) {
                    hoverEntity = this.getEditorFromPos2d(this.lastEdit2dPos);
                }
                // Need to show drag cursor.
                if (hoverEntity && !this.cursorHandlerId) {
                    this.cursorHandlerId = this.cursorHandler.RequestState(0, "grab");
                }
                // Need to remove drag cursor.
                else if (!hoverEntity && this.cursorHandlerId) {
                    this.cursorHandler.DismissRequest(this.cursorHandlerId);
                    this.cursorHandlerId = null;
                }
            }
        }
        /**
         * Reacts to mouse down event from editor events.
         * @param e
         */
        onEditMouseDown(e) {
            if (!this.editorEntity && cartesian2_2.Cartesian2.Validate(e === null || e === void 0 ? void 0 : e.position)) {
                this.editorEntity = this.getEditorFromPos2d(e.position);
                if (this.editorEntity) {
                    if (this.cursorHandlerId) {
                        this.cursorHandler.DismissRequest(this.cursorHandlerId);
                    }
                    this.cursorHandlerId = this.cursorHandler.RequestState(0, "grabbing");
                    this.cameraHandler.isFrozen = true;
                    this.viewer.scene.requestRender();
                }
            }
        }
        /**
         * Returns rectangle editor entity from given screen position.
         * @param pos2d
         */
        getEditorFromPos2d(pos2d) {
            let editors = this.editors;
            let drilled = this.viewer.scene.drillPick(pos2d, 5, 2, 2);
            for (let i = 0; i < drilled.length; i++) {
                let drilledObj = drilled[i];
                if ((drilledObj === null || drilledObj === void 0 ? void 0 : drilledObj.id) instanceof Cesium.Entity) {
                    drilledObj = drilledObj.id;
                }
                if (drilledObj instanceof Cesium.Entity) {
                    let editor = editors.find(x => (x === null || x === void 0 ? void 0 : x.id) == drilledObj.id);
                    if (editor) {
                        return editor;
                    }
                }
            }
            return null;
        }
        /**
         * Reacts to mouse up event from editor events.
         * @param e
         */
        onEditMouseUp(e) {
            if (this.editorEntity) {
                this.editorEntity = null;
                if (this.cursorHandlerId) {
                    this.cursorHandler.DismissRequest(this.cursorHandlerId);
                    this.cursorHandlerId = null;
                }
                this.cameraHandler.isFrozen = false;
                this.viewer.scene.requestRender();
            }
        }
        /**
         * Disposes editing events.
         */
        disposeEditEvents() {
            if (this.editEventHandler) {
                this.editEventHandler.Dispose();
            }
            this.editEventHandler = null;
            this.lastEdit2dPos;
        }
    }
    exports.CesiumRectangleDrawer = CesiumRectangleDrawer;
});
define("entry-points/common/fixed-view-monitor", ["require", "exports", "utils/bruce-event"], function (require, exports, bruce_event_14) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CFixedViewMonitor = void 0;
    /**
     * This class monitors the view .
     */
    class CFixedViewMonitor {
        /**
        * The view monitor object.
        */
        constructor(center, bounds) {
            // The emmited events.
            this._onPositionReady = new bruce_event_14.BruceEvent();
            this._currentPOI = center;
            this._currentView = bounds;
        }
        /**
        * Dispose.
        */
        dispose() {
        }
        /**
        * the postion events updated
        */
        ViewAreaUpdated() {
            return this._onPositionReady;
        }
        /**
        * Getting the current view area
        */
        GetViewAreaInDegrees() {
            return this._currentView;
        }
        /**
        * Get the center of the view
        */
        GetTargetPointInDegrees() {
            return this._currentPOI;
        }
        Update() {
        }
    }
    exports.CFixedViewMonitor = CFixedViewMonitor;
});
define("bruce-models/common/bruce-headers", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceHeaders = void 0;
    class BruceHeaders {
        constructor(rawData) {
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
        }
    }
    exports.BruceHeaders = BruceHeaders;
});
define("bruce-models/common/bruce-location", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_53) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceLocation = void 0;
    /**
     * DEPRECATED: Please use Cartographic model. This will be removed in a few updates.
     */
    class BruceLocation {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current state as raw JSON.
         */
        get JSON() {
            let data = {
                altitude: this.altitude,
                latitude: this.latitude,
                longitude: this.longitude
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.altitude != null) {
                this.altitude = object_utils_53.ObjectUtils.parseNum(rawData.altitude);
            }
            if (rawData.latitude != null) {
                this.latitude = object_utils_53.ObjectUtils.parseNum(rawData.latitude);
            }
            if (rawData.longitude != null) {
                this.longitude = object_utils_53.ObjectUtils.parseNum(rawData.longitude);
            }
        }
        /**
         * Creates location instance from given geometry.
         * Returns null if failed to do so.
         * @param geometry
         */
        static FromGeometry(geometry) {
            let pos = geometry === null || geometry === void 0 ? void 0 : geometry.CalculatePosition();
            if (pos) {
                let newLocation = new BruceLocation(null);
                newLocation.altitude = pos.altitude;
                newLocation.longitude = pos.longitude;
                newLocation.latitude = pos.latitude;
                return newLocation;
            }
            return null;
        }
    }
    exports.BruceLocation = BruceLocation;
});
define("bruce-models/session/cam-account", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CAMAccount = void 0;
    class CAMAccount {
        constructor(rawData) {
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Updates instance of CAM Account using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ID) {
                this.ID = rawData.ID;
            }
            if (rawData.Name) {
                this.Name = rawData.Name;
            }
            if (rawData.Type) {
                this.Type = rawData.Type;
            }
        }
    }
    exports.CAMAccount = CAMAccount;
});
define("bruce-models/common/test", ["require", "exports", "bruce-models/session/cam-account", "bruce-models/session/idm-session", "bruce-models/common/bruce-headers"], function (require, exports, cam_account_1, idm_session_4, bruce_headers_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Test = void 0;
    class Test {
        constructor(rawData) {
            /**
             * Comma-separated list of root domains expected to be supported by this application.
             * NULL for "localhost" debugging.
             */
            this.RootDomains = [];
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns the raw JSON for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Updates instance of Test using given test raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.SubdomainEffective != null) {
                this.SubdomainEffective = rawData.SubdomainEffective;
            }
            if (rawData.RootDomains != null) {
                this.RootDomains = rawData.RootDomains;
            }
            if (rawData.SubdomainOverride != null) {
                this.SubdomainOverride = rawData.SubdomainOverride;
            }
            if (rawData.Headers != null) {
                this.Headers = new bruce_headers_1.BruceHeaders(rawData.Headers);
            }
            if (rawData.RequestURL != null) {
                this.RequestURL = rawData.RequestURL;
            }
            if (rawData["Globals.EnvironmentId"] != null) {
                this["Globals.EnvironmentId"] = rawData["Globals.EnvironmentId"];
            }
            if (rawData.RequestProtocal != null) {
                this.RequestProtocal = rawData.RequestProtocal;
            }
            if (rawData["System.getProperty"] != null) {
                this["System.getProperty"] = rawData["System.getProperty"];
            }
            if (rawData.RequestContextPath != null) {
                this.RequestContextPath = rawData.RequestContextPath;
            }
            if (rawData.RequestURI != null) {
                this.RequestURI = rawData.RequestURI;
            }
            if (rawData.EnvironmentFamily != null) {
                this.EnvironmentFamily = rawData.EnvironmentFamily;
            }
            if (rawData.ClientAccount != null) {
                this.ClientAccount = new cam_account_1.CAMAccount(rawData.ClientAccount);
            }
            if (rawData.Session != null && rawData.Session != "NONE") {
                this.Session = new idm_session_4.IDMSession(rawData.Session);
            }
        }
        /**
         * @param api
         * @returns: API test data.
         */
        static GetTest(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.get(api.BRUCE_URL + "test");
                if (data) {
                    let test = new Test(data);
                    return test;
                }
                return null;
            });
        }
    }
    exports.Test = Test;
});
define("bruce-models/common/layer", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Layer = void 0;
    class Layer {
        constructor(rawData) {
            // If access is restricted.
            // Enabling this means user has to have permission: Layer_<TagId> to see tagged content.
            this.IsAccessRestricted = false;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw JSON.
         */
        get JSON() {
            let raw = {
                ID: this.ID,
                Name: this.Name,
                Description: this.Description,
                IsAccessRestricted: this.IsAccessRestricted,
                "EntityType.ID": this["EntityType.ID"],
                Color: this.Color
            };
            return raw;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.Name != null) {
                this.Name = rawData.Name;
            }
            if (rawData.Description != null) {
                this.Description = rawData.Description;
            }
            if (rawData.IsAccessRestricted != null) {
                this.IsAccessRestricted = rawData.IsAccessRestricted;
            }
            if (rawData["EntityType.ID"] != null) {
                this["EntityType.ID"] = rawData["EntityType.ID"];
            }
            if (rawData.Color != null) {
                this.Color = rawData.Color;
            }
        }
        /**
         * Uses current instance to create or update layer record.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let requestData = this.JSON;
                    let data = yield api.post(api.BRUCE_URL + (this.ID ? `layer/${this.ID}` : "layer"), JSON.stringify(requestData));
                    this.Update(data);
                    return this;
                }
                catch (e) {
                    console.log(">>Error: Failed to save layer.");
                    console.log(this);
                    console.log(e);
                }
                return null;
            });
        }
        /**
         * Deletes record associated with current layer instance.
         * @param api
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    yield api.delete(api.BRUCE_URL + `layer/${this.ID}`);
                }
                catch (e) {
                    console.log(">>Error: Failed to delete layer record.");
                    console.log(e);
                    console.log(this);
                }
            });
        }
        /**
         * Returns all layers either on account or on account matching given entity type id.
         * @param api
         * @param entityTypeId
         */
        static GetLayers(api, entityTypeId) {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    let data = yield api.get(api.BRUCE_URL + (entityTypeId ? `entityType/${entityTypeId}/layers` : "layers"));
                    if (data === null || data === void 0 ? void 0 : data.Items) {
                        let layers = [];
                        for (let i = 0; i < data.Items.length; i++) {
                            let layer = new Layer(data.Items[i]);
                            layers.push(layer);
                        }
                        return layers;
                    }
                    else {
                        return [];
                    }
                }
                catch (e) {
                    console.log(">>Error: Failed to get list of layers.");
                    console.log(e);
                }
                return [];
            });
        }
        /**
         * Returns layer corresponding to given id.
         * @param api
         * @param layerId
         */
        static GetByID(api, layerId) {
            return __awaiter(this, void 0, void 0, function* () {
                let layers = yield Layer.GetByIDs(api, [layerId]);
                return layers && layers.length > 0 ? layers[0] : null;
            });
        }
        /**
         * Returns layers corresponding to given ids.
         * @param api
         * @param layerId
         */
        static GetByIDs(api, layerIds) {
            return __awaiter(this, void 0, void 0, function* () {
                let req = {
                    layerIds: layerIds
                };
                let data = yield api.POST("layers/get", JSON.stringify(req));
                let layers = [];
                if (data && data.Items) {
                    for (let i = 0; i < data.Items.length; i++) {
                        layers.push(new Layer(data.Items[i]));
                    }
                }
                return layers;
            });
        }
    }
    exports.Layer = Layer;
});
define("bruce-models/common/bruce-entity-source", ["require", "exports", "utils/hash"], function (require, exports, hash_2) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BruceEntitySource = void 0;
    /**
     * Describes a single bruce entity source.
     * An entity source is a map between arbitrary ID to a bruce entity ID.
     */
    class BruceEntitySource {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current state as raw JSON.
         */
        get JSON() {
            let data = {
                "Entity.ID": this["Entity.ID"],
                "Source.ID": this["Source.ID"],
                "SourceRecord.Key": this["SourceRecord.Key"]
            };
            return data;
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData["Entity.ID"] != null) {
                this["Entity.ID"] = rawData["Entity.ID"];
            }
            if (rawData["Source.ID"] != null) {
                this["Source.ID"] = rawData["Source.ID"];
            }
            if (rawData["SourceRecord.Key"] != null) {
                this["SourceRecord.Key"] = rawData["SourceRecord.Key"];
            }
        }
        /**
         * Creates record matching current state of source.
         * Changing a value in instance after creating a record then calling create again will create a new record.
         * @param api
         */
        CreateRecord(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let rawData = yield api.post(api.BRUCE_URL + "entitysource", JSON.stringify(this.JSON));
                if (rawData) {
                    this.Update(rawData);
                }
            });
        }
        /**
         * Returns a single bruce entity source record corresponding to given sourceId and sourceKey.
         * @param api
         * @param sourceId
         * @param sourceKey
         */
        static GetEntitySourceBySourceKey(api, sourceId, sourceKey) {
            return __awaiter(this, void 0, void 0, function* () {
                let rawData = yield api.get(api.BRUCE_URL + `entitysource/${sourceId}/${sourceKey}`);
                if (rawData && rawData["Source.ID"] != null) {
                    let source = new BruceEntitySource(rawData);
                    return source;
                }
                else {
                    return null;
                }
            });
        }
        /**
         * Returns array of bruce entity sources corresponding to given sourceId and many source keys.
         * @param api
         * @param sourceId
         * @param sourceKeys
         */
        static GetEntitySourcesBySourceKeys(api, sourceId, sourceKeys) {
            return __awaiter(this, void 0, void 0, function* () {
                let requestData = {
                    SourceRecordKeys: sourceKeys
                };
                let rawData = yield api.post(api.BRUCE_URL + `entitysource/${sourceId}`, JSON.stringify(requestData));
                if (rawData && rawData.Items != null) {
                    let sources = [];
                    for (let i = 0; i < rawData.Items.length; i++) {
                        let source = new BruceEntitySource(rawData.Items[i]);
                        sources.push(source);
                    }
                    return sources;
                }
                else {
                    return [];
                }
            });
        }
        /**
         * Returns array of bruce entity ids corresponding to given source id and many source keys.
         * Returns values will be in the same order as provided sourceKeys.
         * If there was no record then the index value will be null.
         * @param api
         * @param sourceId
         * @param sourceKeys
         */
        static GetBruceEntityIdsBySourceKeys(api, sourceId, sourceKeys) {
            return __awaiter(this, void 0, void 0, function* () {
                let result = [];
                let realRequestKeys = [];
                // Finding what is already cached.
                for (let i = 0; i < sourceKeys.length; i++) {
                    let key = sourceKeys[i];
                    let id = api.bruceEntitySourceIdCache.Get(hash_2.Hash.Cyrb53Hash(sourceId + "_" + key));
                    if (id) {
                        result[i] = id;
                    }
                    else {
                        result[i] = undefined;
                        realRequestKeys.push(key);
                    }
                }
                // Keys that have no cache data.
                if (realRequestKeys.length > 0) {
                    let sources = yield BruceEntitySource.GetEntitySourcesBySourceKeys(api, sourceId, realRequestKeys);
                    for (let i = 0; i < sources.length; i++) {
                        let source = sources[i];
                        for (let i = 0; i < sourceKeys.length; i++) {
                            let key = sourceKeys[i];
                            if (key == source["SourceRecord.Key"]) {
                                result[i] = source["Entity.ID"];
                            }
                        }
                        api.bruceEntitySourceIdCache.Set(hash_2.Hash.Cyrb53Hash(sourceId + "_" + source["SourceRecord.Key"]), source["Entity.ID"]);
                    }
                }
                return result;
            });
        }
    }
    exports.BruceEntitySource = BruceEntitySource;
});
define("bruce-models/common/entity-relationship-type", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_54) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityRelationshipType = void 0;
    class EntityRelationshipType {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                ID: this.ID,
                ForwardName: this.ForwardName,
                ReverseName: this.ReverseName,
                Name: this.Name,
                FlipDisplayDirection: this.FlipDisplayDirection,
                EntityDisplaySettingID: this.EntityDisplaySettingID,
                "Relation.EntityType.ID": this["Relation.EntityType.ID"]
            };
            data = object_utils_54.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new EntityRelationshipType(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.ForwardName != null) {
                this.ForwardName = rawData.ForwardName;
            }
            if (rawData.ReverseName != null) {
                this.ReverseName = rawData.ReverseName;
            }
            if (rawData.Name != null) {
                this.Name = rawData.Name;
            }
            if (rawData.FlipDisplayDirection != null) {
                this.FlipDisplayDirection = rawData.FlipDisplayDirection;
            }
            if (rawData.EntityDisplaySettingID != null) {
                this.EntityDisplaySettingID = rawData.EntityDisplaySettingID;
            }
            if (rawData["Relation.EntityType.ID"] != null) {
                this["Relation.EntityType.ID"] = rawData["Relation.EntityType.ID"];
            }
        }
        /**
         * Saves or creates the relationship type record.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.POST(`entityRelationType/${this.ID}`, JSON.stringify(this.JSON));
                if (data) {
                    this.Update(data);
                    return this;
                }
                return null;
            });
        }
        /**
         * Deletes the current entity relationship type record.
         * @param api
         * @returns
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.DELETE(`entityRelationType/${this.ID}`);
            });
        }
        /**
         * Returns all entity relationship types from given api instance.
         * @param api
         */
        static GetTypes(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET("entityRelationTypes");
                if (data && data.Items) {
                    let types = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        types.push(new EntityRelationshipType(data.Items[i]));
                    }
                    return types;
                }
                return [];
            });
        }
        /**
         * Returns entity relationship type by id.
         * @param api
         * @param id
         */
        static GetByID(api, id) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET(`entityRelationType/${id}`);
                if (data) {
                    return new EntityRelationshipType(data);
                }
                return null;
            });
        }
    }
    exports.EntityRelationshipType = EntityRelationshipType;
});
define("bruce-models/common/entity-relationship", ["require", "exports", "utils/object-utils", "bruce-models/common/entity-relationship-type"], function (require, exports, object_utils_55, entity_relationship_type_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityRelationship = void 0;
    class EntityRelationship {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                "Principal.Entity.ID": this["Principal.Entity.ID"],
                "Related.Entity.ID": this["Related.Entity.ID"],
                PrincipalEntity: this.PrincipalEntity,
                RelatedEntity: this.RelatedEntity,
                "Relation.Type.ID": this["Relation.Type.ID"],
                RelationType: this.RelationType,
                "Data.Entity.ID": this["Data.Entity.ID"]
            };
            data = object_utils_55.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new EntityRelationship(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData["Principal.Entity.ID"] != null) {
                this["Principal.Entity.ID"] = rawData["Principal.Entity.ID"];
            }
            if (rawData["Related.Entity.ID"] != null) {
                this["Related.Entity.ID"] = rawData["Related.Entity.ID"];
            }
            if (rawData.PrincipalEntity != null) {
                this.PrincipalEntity = rawData.PrincipalEntity;
            }
            if (rawData.RelatedEntity != null) {
                this.RelatedEntity = rawData.RelatedEntity;
            }
            if (rawData["Relation.Type.ID"] != null) {
                this["Relation.Type.ID"] = rawData["Relation.Type.ID"];
            }
            if (rawData.RelationType != null) {
                this.RelationType = new entity_relationship_type_1.EntityRelationshipType(rawData.RelationType);
            }
            if (rawData["Data.Entity.ID"] != null) {
                this["Data.Entity.ID"] = rawData["Data.Entity.ID"];
            }
        }
        /**
         * Creates or updates the current relationship record.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.POST(`entity/${this["Principal.Entity.ID"]}/otherEntityID/${this["Related.Entity.ID"]}/relation/${this["Relation.Type.ID"]}/update`, JSON.stringify(this.JSON));
                if (data) {
                    this.Update(data);
                }
                return this;
            });
        }
        /**
        * Gets a list of relationships for a given entityId
        * @param api
        * @param entityId
        * @param relationshipTypeId If relationships for a specific type should be returned.
        * @param oneWayOnly If it should only get relationships for one direction.
        * @param loadInfo If bruce info should be loaded for the relationships.
        */
        static GetRelations(api, entityId, relationshipTypeId = null, oneWayOnly = false, loadInfo = true) {
            return __awaiter(this, void 0, void 0, function* () {
                let url = `entity/${entityId}/relations`;
                if (relationshipTypeId) {
                    url += "/" + relationshipTypeId;
                }
                url += `?Oneway=${oneWayOnly}&LoadInfo=${loadInfo}`;
                let data = yield api.GET(url);
                if (data && data.Items) {
                    let relationships = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        relationships.push(new EntityRelationship(data.Items[i]));
                    }
                    return relationships;
                }
                return [];
            });
        }
        /**
         * Returns relationship record matching given data entity id.
         * @param api
         * @param dataEntityId
         */
        static GetByDataEntityID(api, dataEntityId) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET(`entity/relation/${dataEntityId}/dataentity`);
                if (data) {
                    return new EntityRelationship(data);
                }
                return null;
            });
        }
    }
    exports.EntityRelationship = EntityRelationship;
});
define("bruce-models/common/program-key", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_56) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProgramKey = void 0;
    /**
     * Describes an arbitrary key for external programs.
     * An example of this can be a Bing, Cesium ION or Google Maps key.
     */
    class ProgramKey {
        constructor(rawData) {
            // If access is restricted.
            // Enabling this means user has to have permission: ProgramKey_<programId> to see retrieve the key.
            this.IsAccessRestricted = true;
            this.Update(rawData);
        }
        /**
         * The permission a session must have to access this key if 'IsAccessRestricted' is marked as true.
         */
        get AccessPermission() {
            return "ProgramKey_" + this.ProgramId;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                ProgramId: this.ProgramId,
                Key: this.Key,
                IsAccessRestricted: this.IsAccessRestricted
            };
            data = object_utils_56.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new ProgramKey(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ProgramId != null) {
                this.ProgramId = rawData.ProgramId;
            }
            if (rawData.Key != null) {
                this.Key = rawData.Key;
            }
            if (rawData.IsAccessRestricted != null) {
                this.IsAccessRestricted = rawData.IsAccessRestricted;
            }
        }
        /**
         * Saves current instance to DB.
         * If key does not exist in DB this will create a new record.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.POST("programkey", JSON.stringify(this.JSON));
                if (data) {
                    this.Update(data);
                }
                return null;
            });
        }
        /**
         * Deletes record associated with current instance.
         * @param api
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.DELETE("programkey/" + this.ProgramId);
            });
        }
        /**
         * Returns access key by program ID.
         * @param api
         */
        static GetByProgramID(api, id) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET(`programkey/${id}`);
                if (data) {
                    return new ProgramKey(data);
                }
                return null;
            });
        }
        /**
         * Returns all access keys.
         * Warning: will not return keys that session does not have access to.
         * @param api
         */
        static GetAll(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET("programkeys");
                if (data && data.Items) {
                    let keys = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        keys.push(new ProgramKey(data.Items[i]));
                    }
                    return keys;
                }
                return [];
            });
        }
    }
    exports.ProgramKey = ProgramKey;
});
define("bruce-models/common/entity-link", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_57) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityLink = void 0;
    class EntityLink {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                URL: this.URL,
                DisplayName: this.DisplayName,
                ID: this.ID,
                "Entity.ID": this["Entity.ID"]
            };
            data = object_utils_57.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new EntityLink(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.DisplayName != null) {
                this.DisplayName = rawData.DisplayName;
            }
            if (rawData["Entity.ID"] != null) {
                this["Entity.ID"] = rawData["Entity.ID"];
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.URL != null) {
                this.URL = rawData.URL;
            }
        }
        /**
         * Saves or creates entity link record.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.POST(`entity/${this["Entity.ID"]}/link/${this.ID ? this.ID : ""}`, JSON.stringify(this.JSON));
                if (data) {
                    this.Update(data);
                }
                return null;
            });
        }
        /**
         * Deletes record associated with current instance.
         * @param api
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.DELETE(`entity/${this["Entity.ID"]}/link/${this.ID}`);
            });
        }
        /**
         * Returns all entity links for given entity id.
         * @param api
         * @param entityId
         */
        static GetForEntityID(api, entityId) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET(`entity/${entityId}/links`);
                if (data && data.Items) {
                    let links = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        links.push(new EntityLink(data.Items[i]));
                    }
                    return links;
                }
                return [];
            });
        }
    }
    exports.EntityLink = EntityLink;
});
define("bruce-models/common/entity-comment", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_58) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityComment = void 0;
    class EntityComment {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                Comment: this.Comment,
                "Created.ByUser.ID": this["Created.ByUser.ID"],
                "Created.Date": this["Created.Date"],
                ID: this.ID,
                RepliesCount: this.RepliesCount,
                "ReplyTo.Comment.ID": this["ReplyTo.Comment.ID"],
                "TargetObject.ID": this["TargetObject.ID"],
                "TargetObject.Type": this["TargetObject.Type"]
            };
            data = object_utils_58.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new EntityComment(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.Comment != null) {
                this.Comment = rawData.Comment;
            }
            if (rawData["Created.ByUser.ID"] != null) {
                this["Created.ByUser.ID"] = rawData["Created.ByUser.ID"];
            }
            if (rawData["Created.Date"] != null) {
                this["Created.Date"] = rawData["Created.Date"];
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.RepliesCount != null) {
                this.RepliesCount = rawData.RepliesCount;
            }
            if (rawData["ReplyTo.Comment.ID"] != null) {
                this["ReplyTo.Comment.ID"] = rawData["ReplyTo.Comment.ID"];
            }
            if (rawData["TargetObject.ID"] != null) {
                this["TargetObject.ID"] = rawData["TargetObject.ID"];
            }
            if (rawData["TargetObject.Type"] != null) {
                this["TargetObject.Type"] = rawData["TargetObject.Type"];
            }
        }
        /**
         * Saves or updates comment record.
         * @param api
         * @returns
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.POST(`entity/${this["TargetObject.ID"]}/comment` + (this.ID == null ? "" : "/" + this.ID), JSON.stringify(this.JSON));
                if (data) {
                    this.Update(data);
                    return this;
                }
                return null;
            });
        }
        /**
         * Deletes record associated with current instance.
         * @param api
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.DELETE(`entity/${this["TargetObject.ID"]}/comment/${this.ID}`);
            });
        }
        /**
         * Returns all comments for an entity.
         * @param api
         * @param entityId
         */
        static GetForEntityID(api, entityId) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET(`entity/${entityId}/comments`);
                if (data && data.Items) {
                    let comments = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        comments.push(new EntityComment(data.Items[i]));
                    }
                    return comments;
                }
                return [];
            });
        }
    }
    exports.EntityComment = EntityComment;
});
define("bruce-models/common/ucs", ["require", "exports", "utils/object-utils", "bruce-models/tileset/tileset", "bruce-models/common/cartographic"], function (require, exports, object_utils_59, tileset_4, cartographic_10) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UCS = exports.EUCSState = void 0;
    var EUCSState;
    (function (EUCSState) {
        // Means that pivot is not set and should be updated at first time (like "automatic" mode).
        EUCSState["Undefined"] = "undef";
        // That pivot is initialized and can be used.
        EUCSState["Prepared"] = "ready";
    })(EUCSState = exports.EUCSState || (exports.EUCSState = {}));
    class UCS {
        constructor(rawData) {
            // Unique ID for the UCS record.
            this.id = 0;
            // EPSG used in combination with the pivot to create a world coordinate.
            this.epsg = 0;
            // State of the UCS. Specifies if needs to be calculated on first usage or not.
            this.state = EUCSState.Undefined;
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                id: this.id,
                name: this.name,
                description: this.description,
                pivot: this.pivot,
                epsg: this.epsg,
                state: this.state
            };
            let location = this.location;
            if (location) {
                data.altitude = location.altitude;
                data.latitude = location.latitude;
                data.longitude = location.longitude;
            }
            let tilesets = this.tilesets;
            if (tilesets) {
                let tilesetsRaw = [];
                for (let i = 0; i < tilesets.length; i++) {
                    let tileset = tilesets[i];
                    let tilesetRaw = tileset.JSON;
                    if (tilesetRaw) {
                        tilesetsRaw.push(tileset.JSON);
                    }
                }
                data.tilesets = tilesetsRaw;
            }
            data = object_utils_59.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new UCS(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.id != null) {
                this.id = rawData.id;
            }
            if (rawData.name != null) {
                this.name = rawData.name;
            }
            if (rawData.description != null) {
                this.description = rawData.description;
            }
            if (rawData.pivot != null) {
                this.pivot = rawData.pivot;
            }
            if (rawData.state != null) {
                this.state = rawData.state;
            }
            if (rawData.latitude != null || rawData.longitude != null || rawData.altitude != null) {
                this.location = new cartographic_10.Cartographic({
                    altitude: rawData.altitude,
                    latitude: rawData.latitude,
                    longitude: rawData.longitude
                });
            }
            if (rawData.tilesets != null) {
                let tilesets = [];
                for (let i = 0; i < rawData.tilesets.length; i++) {
                    let tilesetRaw = rawData.tilesets[i];
                    tilesets.push(new tileset_4.Tileset(tilesetRaw));
                }
                this.tilesets = tilesets;
            }
        }
        /**
         * Creates or updates UCS record.
         * @Warning: New UCS should not have any id set in the model.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let isNew = !this.id;
                let data = this.JSON;
                let res = yield api.POST(`ucs${isNew ? "" : "/" + this.id}`, JSON.stringify(data));
                if (res) {
                    this.id = res.id;
                }
                return this;
            });
        }
        /**
         * Deletes record corresponding to current instance.
         * @param api
         * @returns
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return UCS.Delete(api, this.id);
            });
        }
        /**
         * Deletes record corresponding to given id.
         * @param api
         * @param id
         */
        static Delete(api, id) {
            return api.DELETE(`ucs/${id}`);
        }
        /**
         * Returns record corresponding to given id.
         * @param api
         * @param id
         * @param includeUsage: If related tilesets should be included in returned data. Default = false.
         * @returns
         */
        static GetByID(api, id, includeUsage) {
            return __awaiter(this, void 0, void 0, function* () {
                let params = "";
                if (includeUsage === true) {
                    params += "?$expand=tileset";
                }
                let data = yield api.GET(`ucs/${id}${params}`);
                if (data) {
                    return new UCS(data);
                }
                return null;
            });
        }
        /**
         * Returns list of all UCS records.
         * @param api
         */
        static GetList(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET("ucs");
                if (data) {
                    let list = [];
                    for (let i = 0; i < data.length; i++) {
                        let item = data[i];
                        list.push(new UCS(item));
                    }
                    return list;
                }
                return [];
            });
        }
    }
    exports.UCS = UCS;
});
define("bruce-models/common/entity-attachment-type", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_60) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityAttachmentType = exports.EEntityAttachmentType = void 0;
    /**
     * Set of default entity attachment types.
     */
    var EEntityAttachmentType;
    (function (EEntityAttachmentType) {
        EEntityAttachmentType["Photo"] = "photo";
        EEntityAttachmentType["Document"] = "document";
        EEntityAttachmentType["Video"] = "video";
        EEntityAttachmentType["Drawing"] = "drawing";
        EEntityAttachmentType["Model"] = "model";
    })(EEntityAttachmentType = exports.EEntityAttachmentType || (exports.EEntityAttachmentType = {}));
    class EntityAttachmentType {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = {
                ID: this.ID,
                Description: this.Description,
                Name: this.Name
            };
            data = object_utils_60.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new EntityAttachmentType(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.Description != null) {
                this.Description = rawData.Description;
            }
            if (rawData.Name != null) {
                this.Name = rawData.Name;
            }
        }
        /**
         * Creates or updates record to match current instance.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.POST(`entityAttachmentType/${this.ID}`, JSON.stringify(this.JSON));
                if (data) {
                    this.Update(data);
                    return this;
                }
                return null;
            });
        }
        /**
         * Calls to delete entity attachment type corresponding to current instance.
         * @param api
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.DELETE(`entityAttachmentType/${this.ID}`);
            });
        }
        /**
         * Returns list of all entity attachment types in provided environment.
         * @param api
         */
        static GetAll(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET("entityAttachmentTypes");
                if (data && data.Items) {
                    let types = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        let item = data.Items[i];
                        types.push(new EntityAttachmentType(item));
                    }
                    return types;
                }
                return [];
            });
        }
    }
    exports.EntityAttachmentType = EntityAttachmentType;
});
define("bruce-models/common/entity-attachment", ["require", "exports", "utils/object-utils", "bruce-models/common/client-file"], function (require, exports, object_utils_61, client_file_3) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EntityAttachment = void 0;
    class EntityAttachment {
        constructor(rawData) {
            this.Update(rawData);
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a;
            let data = {
                ClientFile: (_a = this.ClientFile) === null || _a === void 0 ? void 0 : _a.JSON,
                DisplayOrder: this.DisplayOrder,
                "Entity.ID": this["Entity.ID"],
                "EntityAttachmentType.ID": this["EntityAttachmentType.ID"],
                Group: this.Group,
                "ClientFile.ID": this["ClientFile.ID"]
            };
            data = object_utils_61.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new EntityAttachment(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ClientFile != null) {
                this.ClientFile = new client_file_3.ClientFile(rawData.ClientFile);
            }
            if (rawData["ClientFile.ID"] != null) {
                this["ClientFile.ID"] = rawData["ClientFile.ID"];
            }
            if (rawData.DisplayOrder != null) {
                this.DisplayOrder = rawData.DisplayOrder;
            }
            if (rawData["Entity.ID"] != null) {
                this["Entity.ID"] = rawData["Entity.ID"];
            }
            if (rawData["EntityAttachmentType.ID"] != null) {
                this["EntityAttachmentType.ID"] = rawData["EntityAttachmentType.ID"];
            }
            if (rawData.Group != null) {
                this.Group = rawData.Group;
            }
        }
        /**
         * Updates record with existing data.
         * This will NOT create a new record. Use 'UploadAttachment' instead.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.PUT(`entity/${this["Entity.ID"]}/attachment/${this["EntityAttachmentType.ID"]}/${this["ClientFile.ID"]}`, JSON.stringify(this.JSON));
                if (data) {
                    this.Update(data);
                    return this;
                }
                return null;
            });
        }
        /**
         * Uses instance data to create a new record from given blob.
         * This is NOT an update request. Use 'SaveUpdate'.
         * @param api
         * @param file
         * @param progress
         */
        UploadAttachment(api, file, progress) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.UPLOAD(`entity/${this["Entity.ID"]}/attachment/${this["EntityAttachmentType.ID"]}`, file, progress);
                if (data) {
                    this.Update(data);
                    return this;
                }
                return null;
            });
        }
        /**
         * Deletes record corresponding to current instance.
         * @param api
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = {
                    "ClientFile.ID": [this["ClientFile.ID"]]
                };
                return api.POST(`entity/${this["Entity.ID"]}/attachments/${this["EntityAttachmentType.ID"]}/delete`, JSON.stringify(data));
            });
        }
        /**
         * Returns URL to current attachment.
         * @param api
         */
        GetURL(api) {
            return api.BRUCE_URL + `file/${this.ClientFile.ID}${this.ClientFile.FileExt}`;
        }
        /**
         * Returns all attachments for an entity id.
         * @param api
         * @param entityId
         */
        static GetByEntityID(api, entityId) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET("entity/" + entityId + "/attachments");
                if (data && data.Items) {
                    let attachments = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        let item = data.Items[i];
                        attachments.push(new EntityAttachment(item));
                    }
                    return attachments;
                }
                return [];
            });
        }
        /**
         * Deletes multiple entity attachment records for a single entity.
         * @param api
         * @param entityId
         * @param attachmentTypeId
         * @param clientFileIds
         */
        static DeleteByClientFileIDs(api, entityId, attachmentTypeId, clientFileIds) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = {
                    "ClientFile.ID": clientFileIds
                };
                return api.POST(`entity/${entityId}/attachments/${attachmentTypeId}/delete`, JSON.stringify(data));
            });
        }
        /**
         * Updates an entity's attachments order.
         * @param api
         * @param entityId
         * @param attachmentTypeId
         * @param clientFileIds: new order for attachments.
         */
        static UpdateOrder(api, entityId, attachmentTypeId, clientFileIds) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = {
                    "DisplayOrder.Start": 0,
                    "ClientFile.ID": clientFileIds
                };
                return api.POST(`entity/${entityId}/attachments/${attachmentTypeId}/setOrder`, JSON.stringify(data));
            });
        }
    }
    exports.EntityAttachment = EntityAttachment;
});
define("bruce-models/ui-plugin/ui-plugin", ["require", "exports", "utils/object-utils", "bruce-models/common/utc"], function (require, exports, object_utils_62, utc_9) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UIPlugin = void 0;
    class UIPlugin {
        constructor(rawData) {
            this.Version = 0;
            this.IsAccessRestricted = false;
            this.IsLoginRequired = false;
            this.Update(rawData);
        }
        /**
         * The permission a session must have to access this key if 'IsAccessRestricted' is marked as true.
         */
        get AccessPermission() {
            return "UIPlugin_" + this.ID;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            var _a, _b;
            let data = {
                ID: this.ID,
                Name: this.Name,
                IsAccessRestricted: this.IsAccessRestricted,
                IsLoginRequired: this.IsLoginRequired,
                Location: this.Location,
                Icon: this.Icon,
                Version: this.Version,
                "Created.Date": (_a = this.CreatedDate) === null || _a === void 0 ? void 0 : _a.JSON,
                "LastUpdated.Date": (_b = this.LastUpdatedDate) === null || _b === void 0 ? void 0 : _b.JSON
            };
            data = object_utils_62.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new UIPlugin(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
            if (rawData.ID != null) {
                this.ID = rawData.ID;
            }
            if (rawData.Name != null) {
                this.Name = rawData.Name;
            }
            if (rawData.Version != null) {
                this.Version = rawData.Version;
            }
            if (rawData.IsAccessRestricted != null) {
                this.IsAccessRestricted = rawData.IsAccessRestricted;
            }
            if (rawData.IsLoginRequired != null) {
                this.IsLoginRequired = rawData.IsLoginRequired;
            }
            if (rawData.Location != null) {
                this.Location = rawData.Location;
            }
            if (rawData.Icon != null) {
                this.Icon = rawData.Icon;
            }
            if (rawData["Created.Date"] != null) {
                this.CreatedDate = new utc_9.UTC(rawData["Created.Date"]);
            }
            if (rawData["LastUpdated.Date"] != null) {
                this.LastUpdatedDate = new utc_9.UTC(rawData["LastUpdated.Date"]);
            }
        }
        /**
         * Saves or updates plugin record.
         * ID must be set.
         * @param api
         */
        SaveUpdate(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return yield api.POST("ui.plugin/" + this.ID, JSON.stringify(this.JSON));
            });
        }
        /**
         * Deletes plugin corresponding to current instance.
         * @param api
         */
        Delete(api) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.DELETE("ui.plugin/" + this.ID);
            });
        }
        /**
         * Uploads and replaces the plugin source file.
         * Provided file MUST be a zip.
         * @param api
         * @param blob
         * @param progress
         * @param onError
         */
        UploadZIP(api, blob, progress = null, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return api.UPLOAD(`ui.plugin/${this.ID}/file`, blob, progress, onError);
            });
        }
        /**
         * Returns URL to file within plugin ZIP by given path.
         * @param api
         * @param path
         */
        getFileURL(api, path) {
            return api.BRUCE_URL + `ui.plugin/${this.ID}/file/${path}`;
        }
        /**
         * Returns all plugins in account.
         * @param api
         */
        static GetAll(api) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET("ui.plugins");
                if (data && data.Items) {
                    let keys = [];
                    for (let i = 0; i < data.Items.length; i++) {
                        keys.push(new UIPlugin(data.Items[i]));
                    }
                    return keys;
                }
                return [];
            });
        }
        /**
         * Returns plugin corresponding to given id.
         * @param api
         * @param id
         */
        static GetByID(api, id) {
            return __awaiter(this, void 0, void 0, function* () {
                let data = yield api.GET(`ui.plugin/${id}`);
                if (data) {
                    return new UIPlugin(data);
                }
                return null;
            });
        }
        /**
         * Returns access permission user needs to have to access plugin by given id.
         * @param id
         */
        static GetAccessPermission(id) {
            return "UIPlugin_" + id;
        }
    }
    exports.UIPlugin = UIPlugin;
});
define("utils/url-utils", ["require", "exports"], function (require, exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.URLUtils = void 0;
    class URLUtils {
        /**
         * Converts the Query String of the current page URL into JSON object.
         */
        static GetQueryString(doc) {
            let qs = {};
            let p0 = doc.location.href.indexOf("?");
            if (p0 >= 0) {
                let str = doc.location.href.substring(p0 + 1);
                let tokens = str.split("&");
                tokens.forEach(token => {
                    let p = token.split("=");
                    if (p.length == 2) {
                        qs[p[0]] = p[1];
                    }
                });
            }
            return qs;
        }
    }
    exports.URLUtils = URLUtils;
});
define("utils/window-url-handler", ["require", "exports", "utils/url-utils"], function (require, exports, url_utils_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WindowURLHandler = void 0;
    /**
     * Helps manage the process of updating and reading current URL state.
     */
    class WindowURLHandler {
        constructor(window, allowedKeys) {
            // What param keys are allowed in URL.
            // If null then all keys are allowed.
            this._allowedKeys = null;
            this._window = window;
            this._allowedKeys = allowedKeys;
        }
        get window() {
            return this._window;
        }
        get document() {
            var _a;
            return (_a = this.window) === null || _a === void 0 ? void 0 : _a.document;
        }
        get allowedKeys() {
            return this._allowedKeys;
        }
        /**
         * Updates what keys are allowed in URL and calls a refresh.
         * @param allowedKeys
         */
        UpdateAllowedKeys(allowedKeys) {
            this._allowedKeys = allowedKeys;
            let params = this.GetParams();
            this.refresh(params);
        }
        /**
         * Updates a key/value pair from URL matching given key.
         * @param key
         */
        UpdateParam(key, value) {
            let params = this.GetParams();
            params[key + ""] = value + "";
            this.refresh(params);
        }
        /**
         * Returns a key/value pair from URL matching given key.
         * @param key
         */
        RemoveParam(key) {
            let params = this.GetParams();
            params[key + ""] = null;
            this.refresh(params);
        }
        /**
         * @returns: array of all param keys.
         */
        GetParamKeys() {
            let params = url_utils_1.URLUtils.GetQueryString(this.document);
            return Object.keys(params);
        }
        /**
         * @returns: dictionary of all param keys and their values.
         */
        GetParams() {
            return url_utils_1.URLUtils.GetQueryString(this.document);
        }
        /**
         * @param key
         * @returns: returns param value by given key.
         */
        GetParam(key) {
            let params = this.GetParams();
            return params[key + ""];
        }
        /**
         * Clears all params.
         */
        Clear() {
            this.refresh({});
        }
        /**
         * Refreshes URL with given dictionary.
         */
        refresh(data) {
            let params = [];
            let keys = Object.keys(data);
            for (let i = 0; i < keys.length; i++) {
                let key = keys[i];
                if (this._allowedKeys == null || this._allowedKeys.includes(key)) {
                    let val = data[key];
                    if (!!val || val == 0) {
                        params.push(`${key}=${val}`);
                    }
                }
            }
            if (params.length > 0) {
                this.window.history.replaceState({}, null, "?" + params.join("&"));
            }
            else {
                this.window.history.replaceState({}, null, "");
            }
        }
    }
    exports.WindowURLHandler = WindowURLHandler;
});
define("api/account-api", ["require", "exports", "bruce-maps-widget", "api/abstract-api"], function (require, exports, bruce_maps_widget_8, abstract_api_4) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AccountAPI = void 0;
    class AccountAPI extends abstract_api_4.AbstractAPI {
        constructor(environment) {
            super("SSID");
            this.environment = environment;
            this.init();
        }
        /**
         * Returns account api instance corresponding to provided parameters.
         * @param environment
         */
        static getInstance(environment) {
            if (environment == null) {
                throw ("Cannot create instance of account api without environment");
            }
            let instances = AccountAPI._instances;
            let instance = instances.find(x => x.environment == environment);
            if (instance) {
                return instance;
            }
            else {
                let newInstance = new AccountAPI(environment);
                AccountAPI._instances.push(newInstance);
                return newInstance;
            }
        }
        /**
         * Initializes the session api link.
         */
        init() {
            let base = "";
            switch (this.environment) {
                case bruce_maps_widget_8.EEnvironmentType.DEV:
                    base = "https://cam.nextspace-dev.net/";
                    break;
                case bruce_maps_widget_8.EEnvironmentType.STAGING:
                    base = "https://cam.nextspace-stg.net/";
                    break;
                case bruce_maps_widget_8.EEnvironmentType.UAT:
                    base = "https://cam.nextspace-uat.net/";
                    break;
                default:
                    base = "https://cam.nextspace.host";
                    break;
            }
            this.BASE_URL = base;
        }
        /**
         * Performs GET request with AccountAPI instance prefix.
         * @param url
         * @param onError
         */
        GET(url, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.get(this.BASE_URL + url, onError);
            });
        }
        /**
         * Performs POST request with AccountAPI instance prefix.
         * @param url
         * @param data
         * @param onError
         */
        POST(url, data, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.post(this.BASE_URL + url, data, onError);
            });
        }
        /**
         * Performs PUT request with AccountAPI instance prefix.
         * @param url
         * @param data
         * @param onError
         */
        PUT(url, data, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.put(this.BASE_URL + url, data, onError);
            });
        }
        /**
         * Performs DELETE request with AccountAPI instance prefix.
         * @param url
         * @param onError
         */
        DELETE(url, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.delete(this.BASE_URL + url, onError);
            });
        }
        /**
         * Performs POST UPLOAD request with AccountAPI instance prefix.
         * @param url
         * @param blob
         * @param progress
         * @param onError
         */
        UPLOAD(url, blob, progress = null, onError = null) {
            return __awaiter(this, void 0, void 0, function* () {
                return this.upload(this.BASE_URL + url, blob, progress, onError);
            });
        }
    }
    exports.AccountAPI = AccountAPI;
    // Array of all unique instances.
    AccountAPI._instances = [];
});
define("bruce-maps-widget", ["require", "exports", "entry-points/cesium/bruce-cesium", "entry-points/cesium/common/cesium-drawing-utils", "entry-points/cesium/common/cesium-measure-handler", "entry-points/cesium/common/cesium-mouse-events", "entry-points/cesium/common/cesium-tileset-utils", "entry-points/cesium/common/cesium-entity-utils", "entry-points/cesium/common/cesium-bruce-info-utils", "entry-points/cesium/common/cesium-utils", "entry-points/cesium/getters/cesium-entities-getter-pages", "entry-points/cesium/menu-items/cesium-menu-item-arbitrary-tileset-extended", "entry-points/cesium/menu-items/cesium-menu-item-bruce-entities-extended", "entry-points/cesium/menu-items/cesium-visual-register", "entry-points/cesium/viewer/cesium-view-monitor", "entry-points/cesium/viewer/cesium-camera-handler", "entry-points/cesium/visuals/cesium-bruce-entity", "entry-points/cesium/visuals/cesium-generator-model", "entry-points/cesium/visuals/cesium-generator-geometry", "entry-points/cesium/visuals/cesium-generator-tileset", "entry-points/cesium/menu-items/cesium-menu-item-manager", "entry-points/cesium/menu-items/cesium-menu-item-loaded-bruce-entities-extended", "entry-points/cesium/menu-items/cesium-menu-item-unknown", "entry-points/cesium/menu-items/cesium-menu-item-ifs", "entry-points/cesium/common/cesium-point-out", "entry-points/cesium/common/cesium-render-listener", "entry-points/cesium/common/cesium-position-map", "entry-points/cesium/common/cesium-polygon-hierarchy-map", "entry-points/cesium/common/cesium-polygon-geometry-editor", "entry-points/cesium/common/cesium-polygon-geometry-editor2", "entry-points/cesium/common/cesium-polygon-geometry-editor3", "entry-points/cesium/common/cesium-geometry-editor-point", "entry-points/cesium/common/cesium-polygon-geometry-creator", "entry-points/cesium/common/cesium-polygon-geometry-creator2", "entry-points/cesium/common/cesium-polygon-geometry-restricted-editor", "entry-points/cesium/common/cesium-bruce-imagery-provider", "entry-points/cesium/common/cesium-bruce-terrain-provider", "entry-points/cesium/common/cesium-imagery-handler", "entry-points/cesium/common/cesium-terrain-handler", "entry-points/cesium/common/cesium-snapped-rectangle-creator", "entry-points/cesium/common/cesium-player-mode", "entry-points/cesium/common/cesium-cached-picking-height-util", "entry-points/cesium/common/cesium-line-creator", "entry-points/cesium/common/cesium-shadow-handler", "entry-points/cesium/common/cesium-outline3d", "entry-points/cesium/common/cesium-ambient-occlusion-handler", "entry-points/cesium/common/cesium-polyline-geometry-creator", "entry-points/cesium/common/cesium-polyline-geometry-editor", "entry-points/cesium/common/cesium-rectangle-drawer", "entry-points/common/bruce-meta", "entry-points/common/calculator", "entry-points/common/entities-getter-interface", "entry-points/common/fixed-view-monitor", "entry-points/cesium/viewer/cesium-load-manager", "entry-points/common/view-monitor-ifs", "bruce-models/session/bruce-permission", "bruce-models/common/boundaries", "bruce-models/common/bruce", "bruce-models/common/bruce-headers", "bruce-models/common/bruce-info", "bruce-models/common/bruce-tileset", "bruce-models/common/bruce-tileset-style-mapping", "bruce-models/common/camera", "bruce-models/common/camera-zoom-control", "bruce-models/common/dictionary", "bruce-models/common/entity-filter", "bruce-models/common/geometry", "bruce-models/common/bruce-location", "bruce-models/common/polygon", "bruce-models/common/camera-position", "bruce-models/common/sort-order", "bruce-models/common/test", "bruce-models/common/transformation", "bruce-models/common/utc", "bruce-models/common/altitude-options", "bruce-models/common/authoring-settings", "bruce-models/common/color", "bruce-models/common/bruce-list", "bruce-models/common/cartesian2", "bruce-models/common/cartesian3", "bruce-models/common/height-reference", "bruce-models/common/bruce-tileset", "bruce-models/common/client-file", "bruce-models/common/complex-files-filter", "bruce-models/common/complex-files-filter-row", "bruce-models/common/entity-style", "bruce-models/common/entity-type-visual-settings", "bruce-models/common/entity-type", "bruce-models/common/mouse-event", "bruce-models/common/relationship-style", "bruce-models/common/rotation", "bruce-models/common/style", "bruce-models/common/cartographic", "bruce-models/common/lod", "bruce-models/common/layer", "bruce-models/common/bruce-entity-source", "bruce-models/common/line", "bruce-models/common/environment", "bruce-models/common/shadow-settings", "bruce-models/common/client-account", "bruce-models/common/camera-frustum", "bruce-models/session/user-application-settings", "bruce-models/common/entity-relationship", "bruce-models/common/entity-relationship-type", "bruce-models/common/program-key", "bruce-models/common/units", "bruce-models/common/entity-link", "bruce-models/common/entity-comment", "bruce-models/common/ucs", "bruce-models/menu-item/menu-item", "bruce-models/menu-item/menu-item-arbitrary-tileset", "bruce-models/menu-item/menu-item-base", "bruce-models/menu-item/menu-item-bruce-entities", "bruce-models/menu-item/menu-item-bruce-entity", "bruce-models/menu-item/menu-item-legend", "bruce-models/menu-item/menu-item-single-entity", "bruce-models/menu-item/menu-item-utils", "bruce-models/menu-item/menu-item-loaded-entities", "bruce-models/project-view/project-view", "bruce-models/project-view/project-view-bookmark", "bruce-models/project-view/project-view-bookmark-settings", "bruce-models/project-view/project-view-settings", "bruce-models/project-view/project-view-settings-shadows", "bruce-models/project-view/project-view-settings-ambient-occlusion", "bruce-models/session/cam-account", "bruce-models/session/idm-session", "bruce-models/tileset/tileset-entity-lod", "bruce-models/tileset/tileset", "bruce-models/tileset/tileset-transform", "bruce-models/tileset/tileset-pointcloud-settings", "bruce-models/tileset/tileset-geo-map-settings", "bruce-models/tileset/tileset-entities-map-settings", "bruce-models/tileset/tileset-model-settings", "bruce-models/tileset/tileset-entities-set-settings", "bruce-models/tileset-old/tileset-old", "bruce-models/tileset-old/tileset-creation-settings", "bruce-models/tileset-old/tileset-creation-settings-location", "bruce-models/tileset-old/tileset-creation-terrain-source", "bruce-models/tileset-old/tileset-settings-old", "bruce-models/tileset-old/tileset-settings-etc", "bruce-models/tileset-old/tileset-settings-origin", "bruce-models/tileset-old/tileset-settings-position-offset", "bruce-models/tileset-old/tileset-settings-rotation", "bruce-models/tileset-old/tileset-settings-visual", "bruce-models/pending-action/pending-action", "bruce-models/pending-action/pending-action-progress-message", "bruce-models/common/entity-attachment", "bruce-models/common/entity-attachment-type", "bruce-models/ui-plugin/ui-plugin", "utils/bruce-event", "utils/bruce-event-disposable", "utils/cache-control", "utils/limited-cache-control", "utils/hash", "utils/object-utils", "utils/delay-queue", "utils/error-utils", "utils/keyboard-events", "utils/drawing-utils", "utils/math-utils", "utils/console-utils", "utils/console-stack", "utils/cursor-css-handler", "utils/storage-utils", "utils/url-utils", "utils/window-url-handler", "utils/browser-utils", "utils/bruce-path-utils", "api/bruce-api", "api/session-api", "api/abstract-api", "api/account-api"], function (require, exports, bruce_cesium_1, cesium_drawing_utils_20, cesium_measure_handler_3, cesium_mouse_events_13, cesium_tileset_utils_3, cesium_entity_utils_11, cesium_bruce_info_utils_3, cesium_utils_27, cesium_entities_getter_pages_3, cesium_menu_item_arbitrary_tileset_extended_3, cesium_menu_item_bruce_entities_extended_3, cesium_visual_register_6, cesium_view_monitor_2, cesium_camera_handler_2, cesium_bruce_entity_9, cesium_generator_model_4, cesium_generator_geometry_4, cesium_generator_tileset_3, cesium_menu_item_manager_6, cesium_menu_item_loaded_bruce_entities_extended_2, cesium_menu_item_unknown_2, cesium_menu_item_ifs_1, cesium_point_out_1, cesium_render_listener_1, cesium_position_map_4, cesium_polygon_hierarchy_map_7, cesium_polygon_geometry_editor_1, cesium_polygon_geometry_editor2_1, cesium_polygon_geometry_editor3_1, cesium_geometry_editor_point_9, cesium_polygon_geometry_creator_1, cesium_polygon_geometry_creator2_1, cesium_polygon_geometry_restricted_editor_1, cesium_bruce_imagery_provider_2, cesium_bruce_terrain_provider_3, cesium_imagery_handler_2, cesium_terrain_handler_2, cesium_snapped_rectangle_creator_1, cesium_player_mode_1, cesium_cached_picking_height_util_9, cesium_line_creator_1, cesium_shadow_handler_2, cesium_outline3d_1, cesium_ambient_occlusion_handler_2, cesium_polyline_geometry_creator_1, cesium_polyline_geometry_editor_1, cesium_rectangle_drawer_1, bruce_meta_10, calculator_6, entities_getter_interface_3, fixed_view_monitor_1, cesium_load_manager_2, view_monitor_ifs_2, bruce_permission_1, boundaries_5, bruce_2, bruce_headers_2, bruce_info_7, bruce_tileset_3, bruce_tileset_style_mapping_3, camera_2, camera_zoom_control_7, dictionary_3, entity_filter_2, geometry_9, bruce_location_1, polygon_13, camera_position_3, sort_order_4, test_1, transformation_2, utc_10, altitude_options_4, authoring_settings_1, color_4, bruce_list_1, cartesian2_3, cartesian3_1, height_reference_2, bruce_tileset_4, client_file_4, complex_files_filter_1, complex_files_filter_row_2, entity_style_1, entity_type_visual_settings_1, entity_type_4, mouse_event_1, relationship_style_1, rotation_1, style_2, cartographic_11, lod_2, layer_1, bruce_entity_source_1, line_3, environment_2, shadow_settings_2, client_account_2, camera_frustum_2, user_application_settings_2, entity_relationship_1, entity_relationship_type_2, program_key_1, units_2, entity_link_1, entity_comment_1, ucs_1, menu_item_1, menu_item_arbitrary_tileset_2, menu_item_base_9, menu_item_bruce_entities_3, menu_item_bruce_entity_6, menu_item_legend_2, menu_item_single_entity_3, menu_item_utils_3, menu_item_loaded_entities_2, project_view_3, project_view_bookmark_2, project_view_bookmark_settings_2, project_view_settings_3, project_view_settings_shadows_3, project_view_settings_ambient_occlusion_3, cam_account_2, idm_session_5, tileset_entity_lod_1, tileset_5, tileset_transform_3, tileset_pointcloud_settings_2, tileset_geo_map_settings_2, tileset_entities_map_settings_2, tileset_model_settings_2, tileset_entities_set_settings_2, tileset_old_1, tileset_creation_settings_2, tileset_creation_settings_location_2, tileset_creation_terrain_source_2, tileset_settings_old_2, tileset_settings_etc_2, tileset_settings_origin_2, tileset_settings_position_offset_2, tileset_settings_rotation_2, tileset_settings_visual_2, pending_action_2, pending_action_progress_message_2, entity_attachment_1, entity_attachment_type_1, ui_plugin_1, bruce_event_15, bruce_event_disposable_9, cache_control_2, limited_cache_control_3, hash_3, object_utils_63, delay_queue_11, error_utils_2, keyboard_events_2, drawing_utils_8, math_utils_2, console_utils_3, console_stack_2, cursor_css_handler_1, storage_utils_3, url_utils_2, window_url_handler_1, browser_utils_2, bruce_path_utils_2, bruce_api_3, session_api_2, abstract_api_5, account_api_1) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RecommendedCesiumVersion = exports.Version = void 0;
    exports.Version = "3.9.9";
    exports.RecommendedCesiumVersion = "1.80.0";
    // BruceCesium.
    __exportStar(bruce_cesium_1, exports);
    __exportStar(cesium_drawing_utils_20, exports);
    __exportStar(cesium_measure_handler_3, exports);
    __exportStar(cesium_mouse_events_13, exports);
    __exportStar(cesium_tileset_utils_3, exports);
    __exportStar(cesium_entity_utils_11, exports);
    __exportStar(cesium_bruce_info_utils_3, exports);
    __exportStar(cesium_utils_27, exports);
    __exportStar(cesium_entities_getter_pages_3, exports);
    __exportStar(cesium_menu_item_arbitrary_tileset_extended_3, exports);
    __exportStar(cesium_menu_item_bruce_entities_extended_3, exports);
    __exportStar(cesium_visual_register_6, exports);
    __exportStar(cesium_view_monitor_2, exports);
    __exportStar(cesium_camera_handler_2, exports);
    __exportStar(cesium_bruce_entity_9, exports);
    __exportStar(cesium_generator_model_4, exports);
    __exportStar(cesium_generator_geometry_4, exports);
    __exportStar(cesium_generator_tileset_3, exports);
    __exportStar(cesium_menu_item_manager_6, exports);
    __exportStar(cesium_menu_item_loaded_bruce_entities_extended_2, exports);
    __exportStar(cesium_menu_item_unknown_2, exports);
    __exportStar(cesium_menu_item_ifs_1, exports);
    __exportStar(cesium_point_out_1, exports);
    __exportStar(cesium_render_listener_1, exports);
    __exportStar(cesium_position_map_4, exports);
    __exportStar(cesium_polygon_hierarchy_map_7, exports);
    __exportStar(cesium_polygon_geometry_editor_1, exports);
    __exportStar(cesium_polygon_geometry_editor2_1, exports);
    __exportStar(cesium_polygon_geometry_editor3_1, exports);
    __exportStar(cesium_geometry_editor_point_9, exports);
    __exportStar(cesium_polygon_geometry_creator_1, exports);
    __exportStar(cesium_polygon_geometry_creator2_1, exports);
    __exportStar(cesium_polygon_geometry_restricted_editor_1, exports);
    __exportStar(cesium_bruce_imagery_provider_2, exports);
    __exportStar(cesium_bruce_terrain_provider_3, exports);
    __exportStar(cesium_imagery_handler_2, exports);
    __exportStar(cesium_terrain_handler_2, exports);
    __exportStar(cesium_snapped_rectangle_creator_1, exports);
    __exportStar(cesium_player_mode_1, exports);
    __exportStar(cesium_cached_picking_height_util_9, exports);
    __exportStar(cesium_line_creator_1, exports);
    __exportStar(cesium_shadow_handler_2, exports);
    __exportStar(cesium_outline3d_1, exports);
    __exportStar(cesium_ambient_occlusion_handler_2, exports);
    __exportStar(cesium_polyline_geometry_creator_1, exports);
    __exportStar(cesium_polyline_geometry_editor_1, exports);
    __exportStar(cesium_rectangle_drawer_1, exports);
    // Entry point commons.
    __exportStar(bruce_meta_10, exports);
    __exportStar(calculator_6, exports);
    __exportStar(entities_getter_interface_3, exports);
    __exportStar(fixed_view_monitor_1, exports);
    __exportStar(cesium_load_manager_2, exports);
    __exportStar(view_monitor_ifs_2, exports);
    // Models.
    __exportStar(bruce_permission_1, exports);
    __exportStar(boundaries_5, exports);
    __exportStar(bruce_2, exports);
    __exportStar(bruce_headers_2, exports);
    __exportStar(bruce_info_7, exports);
    __exportStar(bruce_tileset_3, exports);
    __exportStar(bruce_tileset_style_mapping_3, exports);
    __exportStar(camera_2, exports);
    __exportStar(camera_zoom_control_7, exports);
    __exportStar(dictionary_3, exports);
    __exportStar(entity_filter_2, exports);
    __exportStar(geometry_9, exports);
    __exportStar(bruce_location_1, exports);
    __exportStar(polygon_13, exports);
    __exportStar(camera_position_3, exports);
    __exportStar(sort_order_4, exports);
    __exportStar(test_1, exports);
    __exportStar(transformation_2, exports);
    __exportStar(utc_10, exports);
    __exportStar(altitude_options_4, exports);
    __exportStar(authoring_settings_1, exports);
    __exportStar(color_4, exports);
    __exportStar(bruce_list_1, exports);
    __exportStar(cartesian2_3, exports);
    __exportStar(cartesian3_1, exports);
    __exportStar(height_reference_2, exports);
    __exportStar(bruce_tileset_4, exports);
    __exportStar(client_file_4, exports);
    __exportStar(complex_files_filter_1, exports);
    __exportStar(complex_files_filter_row_2, exports);
    __exportStar(entity_style_1, exports);
    __exportStar(entity_type_visual_settings_1, exports);
    __exportStar(entity_type_4, exports);
    __exportStar(mouse_event_1, exports);
    __exportStar(relationship_style_1, exports);
    __exportStar(rotation_1, exports);
    __exportStar(style_2, exports);
    __exportStar(cartographic_11, exports);
    __exportStar(lod_2, exports);
    __exportStar(layer_1, exports);
    __exportStar(bruce_entity_source_1, exports);
    __exportStar(line_3, exports);
    __exportStar(environment_2, exports);
    __exportStar(shadow_settings_2, exports);
    __exportStar(client_account_2, exports);
    __exportStar(camera_frustum_2, exports);
    __exportStar(user_application_settings_2, exports);
    __exportStar(entity_relationship_1, exports);
    __exportStar(entity_relationship_type_2, exports);
    __exportStar(program_key_1, exports);
    __exportStar(units_2, exports);
    __exportStar(entity_link_1, exports);
    __exportStar(entity_comment_1, exports);
    __exportStar(ucs_1, exports);
    __exportStar(menu_item_1, exports);
    __exportStar(menu_item_arbitrary_tileset_2, exports);
    __exportStar(menu_item_base_9, exports);
    __exportStar(menu_item_bruce_entities_3, exports);
    __exportStar(menu_item_bruce_entity_6, exports);
    __exportStar(menu_item_legend_2, exports);
    __exportStar(menu_item_single_entity_3, exports);
    __exportStar(menu_item_utils_3, exports);
    __exportStar(menu_item_loaded_entities_2, exports);
    __exportStar(project_view_3, exports);
    __exportStar(project_view_bookmark_2, exports);
    __exportStar(project_view_bookmark_settings_2, exports);
    __exportStar(project_view_settings_3, exports);
    __exportStar(project_view_settings_shadows_3, exports);
    __exportStar(project_view_settings_ambient_occlusion_3, exports);
    __exportStar(cam_account_2, exports);
    __exportStar(idm_session_5, exports);
    __exportStar(tileset_entity_lod_1, exports);
    __exportStar(tileset_5, exports);
    __exportStar(tileset_transform_3, exports);
    __exportStar(tileset_pointcloud_settings_2, exports);
    __exportStar(tileset_geo_map_settings_2, exports);
    __exportStar(tileset_entities_map_settings_2, exports);
    __exportStar(tileset_model_settings_2, exports);
    __exportStar(tileset_entities_set_settings_2, exports);
    __exportStar(tileset_old_1, exports);
    __exportStar(tileset_creation_settings_2, exports);
    __exportStar(tileset_creation_settings_location_2, exports);
    __exportStar(tileset_creation_terrain_source_2, exports);
    __exportStar(tileset_settings_old_2, exports);
    __exportStar(tileset_settings_etc_2, exports);
    __exportStar(tileset_settings_origin_2, exports);
    __exportStar(tileset_settings_position_offset_2, exports);
    __exportStar(tileset_settings_rotation_2, exports);
    __exportStar(tileset_settings_visual_2, exports);
    __exportStar(pending_action_2, exports);
    __exportStar(pending_action_progress_message_2, exports);
    __exportStar(entity_attachment_1, exports);
    __exportStar(entity_attachment_type_1, exports);
    __exportStar(ui_plugin_1, exports);
    // Utils.
    __exportStar(bruce_event_15, exports);
    __exportStar(bruce_event_disposable_9, exports);
    __exportStar(cache_control_2, exports);
    __exportStar(limited_cache_control_3, exports);
    __exportStar(hash_3, exports);
    __exportStar(object_utils_63, exports);
    __exportStar(delay_queue_11, exports);
    __exportStar(error_utils_2, exports);
    __exportStar(keyboard_events_2, exports);
    __exportStar(drawing_utils_8, exports);
    __exportStar(math_utils_2, exports);
    __exportStar(console_utils_3, exports);
    __exportStar(console_stack_2, exports);
    __exportStar(cursor_css_handler_1, exports);
    __exportStar(storage_utils_3, exports);
    __exportStar(url_utils_2, exports);
    __exportStar(window_url_handler_1, exports);
    __exportStar(browser_utils_2, exports);
    __exportStar(bruce_path_utils_2, exports);
    // api.
    __exportStar(bruce_api_3, exports);
    __exportStar(session_api_2, exports);
    __exportStar(abstract_api_5, exports);
    __exportStar(account_api_1, exports);
});
define("bruce-models/data-model-template", ["require", "exports", "utils/object-utils"], function (require, exports, object_utils_64) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataModelTemplate = void 0;
    class DataModelTemplate {
        constructor(rawData) {
            this._raw = rawData;
            this.Update(rawData);
        }
        // Returns raw data for this instance.
        get raw() {
            return this._raw;
        }
        /**
         * Returns current instance as raw data.
         */
        get JSON() {
            let data = Object.assign({}, this.raw
            // Add class values after the ...raw to override original data.
            );
            data = object_utils_64.ObjectUtils.Dereference(data, true);
            return data;
        }
        /**
         * Returns a cloned instance.
         */
        Clone() {
            return new DataModelTemplate(this.JSON);
        }
        /**
         * Updates instance using given raw data.
         * @param rawData
         */
        Update(rawData) {
            // Cannot update with null data.
            if (!rawData) {
                return;
            }
        }
    }
    exports.DataModelTemplate = DataModelTemplate;
});
